// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.10/esri/copyright.txt for details.
//>>built
define(["require","exports"],function(a,b){return{edgeRenderer:{"adjustProjectedPosition.glsl":"uniform vec2 uDepthBias;\r\nuniform vec2 uViewportDimInv;\r\n\r\n// Utility function to check for NaN values\r\nbool isNaN(float val) {\r\n  return ( val \x3c 0.0 || 0.0 \x3c val || val \x3d\x3d 0.0 ) ? false : true;\r\n  // important: some nVidias failed to cope with version below.\r\n  // Probably wrong optimization.\r\n  /*return ( val \x3c\x3d 0.0 || 0.0 \x3c\x3d val ) ? false : true;*/\r\n}\r\n\r\n// An offset in xy screen space, along the projected normal of the edge\r\n// This reduces depth fighting when looking at a face from a flat angle\r\nvec2 calculateProjectedBiasXY(vec4 projPos, vec3 worldNormal) {\r\n  float offsetXY \x3d uDepthBias.x;\r\n  float offsetZ  \x3d uDepthBias.y;\r\n\r\n  // screen space pixel offset\r\n  // we multiply by two to account for the fact that NDC go from -1 to 1\r\n  // we multiply by projPos.w to compensate for the perspective divison that happens later\r\n  // normalizing over xyz means that the xy influence is reduced the more the normal is pointing\r\n  // towards the camera\r\n  vec4 projNormal \x3d uProj * uView * vec4(worldNormal, 0.0);\r\n\r\n  return offsetXY * projPos.w * 2.0 * uViewportDimInv * normalize(projNormal.xyz).xy;\r\n}\r\n\r\n// A z-offset, using a depth based heuristic.\r\nfloat calculateProjectedBiasZ(vec4 projPos) {\r\n  float offsetZ \x3d uDepthBias.y;\r\n  return sqrt(projPos.z) * offsetZ;\r\n}\r\n\r\nvec4 adjustProjectedPosition(vec4 projPos, vec3 worldNormal, float lineWidth) {\r\n  vec2 offsetXY \x3d calculateProjectedBiasXY(projPos, worldNormal);\r\n\r\n  // we currently have to do this check because some geometries come with 0 length edge normals.\r\n  // see https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/12890\r\n  if (!isNaN(offsetXY.x) \x26\x26 !isNaN(offsetXY.y)) {\r\n    projPos.xy +\x3d offsetXY;\r\n  }\r\n\r\n  projPos.z +\x3d calculateProjectedBiasZ(projPos);\r\n\r\n  return projPos;\r\n}\r\n",
"edgeRenderer.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n\r\nvarying vec4 vColor;\r\nvarying float vRadius;\r\nvarying vec3 vPosition;\r\nvarying vec3 vWorldPosition;\r\nvarying float vLineLengthPixels;\r\nvarying float vSizeFalloffFactor;\r\nvarying float vLineIndex;\r\n\r\n// At which coverage threshold we discard a fragment completely\r\n#define COVERAGE_TEST_THRESHOLD 0.01\r\n\r\n#include \x3cedgeRenderer/lineOffset.glsl\x3e\r\n\r\nvec2 lineWithCapsDistance(float radius, vec2 position, float lineLength) {\r\n  float lineOffset \x3d calculateLineOffset();\r\n  float positionX \x3d position.x - lineOffset;\r\n\r\n  if (radius \x3c 1.0) {\r\n    // Handle this specifically for subpixel sizes:\r\n    // 1. Compute correct coverage (note coverage is computed by\r\n    //    0.5 - dist, so we make sure that that will lead to correct\r\n    //    subpixel coverage\r\n    // 2. Ignore rounded caps\r\n    float coverageX \x3d clamp(min(radius, positionX + 0.5) - max(-radius, positionX - 0.5), 0.0, 1.0);\r\n    float coverageY \x3d clamp(min(lineLength, position.y + 0.5) - max(0.0, position.y - 0.5), 0.0, 1.0);\r\n\r\n    float coverage \x3d min(coverageX, coverageY);\r\n\r\n    return vec2(0.5 - coverage, 0.0);\r\n  }\r\n  else {\r\n    // Between -radius -\x3e 0 for start cap, 0 for line, 0 -\x3e radius\r\n    float positionOnCap \x3d position.y - clamp(position.y, 0.0, lineLength);\r\n\r\n    vec2 lineToPosition \x3d vec2(positionX, positionOnCap);\r\n    return vec2(length(lineToPosition) - radius, positionOnCap / radius);\r\n  }\r\n}\r\n\r\nvoid main() {\r\n\r\n  float radius \x3d vRadius * calculateLinePressure();\r\n\r\n  vec2 distance \x3d lineWithCapsDistance(radius, vPosition.xy, vLineLengthPixels);\r\n  float coverage \x3d clamp(0.5 - distance.x, 0.0, 1.0);\r\n\r\n#ifdef ANTIALIASING\r\n\r\n  const float coverageLimit \x3d COVERAGE_TEST_THRESHOLD;\r\n\r\n#else /* ANTIALIASING */\r\n\r\n  // Use subpixel coverage computation when lines get subpixel widths\r\n  // so we still render them appropriately. Otherwise discard anything\r\n  // that is not fully within the line\r\n  float coverageLimit \x3d radius \x3c\x3d 0.5 ? COVERAGE_TEST_THRESHOLD : 0.75;\r\n\r\n#endif /* ANTIALIASING */\r\n\r\n  if (coverage \x3c coverageLimit) {\r\n    discard;\r\n  }\r\n\r\n  discardBySlice(vWorldPosition);\r\n\r\n  float alpha \x3d vColor.a * coverage;\r\n\r\n  gl_FragColor \x3d vec4(vColor.rgb, alpha);\r\n}\r\n",
"edgeRenderer.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\n// Transformations\r\nuniform mat4 uProj;\r\nuniform mat4 uView;\r\nuniform mat4 uModel;\r\nuniform vec3 uCameraPosition;\r\n\r\n// Line configuration\r\n\r\n// Conversion constants\r\nuniform vec2 uPixelToNDC;\r\nuniform vec2 uNDCToPixel;\r\nuniform float uPixelRatio;\r\n\r\n// Inputs\r\nattribute vec3 aPosition0;\r\nattribute vec3 aPosition1;\r\nattribute float aVariantOffset;\r\nattribute float aVariantStroke;\r\nattribute float aVariantExtension;\r\n\r\n#ifdef SILHOUETTE\r\n\r\nattribute vec3 aNormalA;\r\nattribute vec3 aNormalB;\r\n\r\n#else /* SILHOUETTE */\r\n\r\nattribute vec3 aNormal;\r\n\r\n#endif /* SILHOUETTE */\r\n\r\nattribute vec2 aSideness;\r\nattribute vec2 aPackedAttributes;\r\n\r\nstruct UnpackedAttributes {\r\nvec2 sideness;\r\nvec2 sidenessNorm;\r\nfloat lineWidthPixels;\r\nfloat extensionLengthPixels;\r\n\r\n#if (MODE \x3d\x3d MODE_UBER)\r\n\r\nfloat type;\r\n\r\n#endif\r\n};\r\n\r\n// Output required to compute color\r\nvarying vec4 vColor;\r\n\r\n// Output required to compute distance to line/caps\r\nvarying vec3 vPosition;\r\nvarying vec3 vWorldPosition;\r\nvarying float vRadius;\r\nvarying float vLineLengthPixels;\r\nvarying float vSizeFalloffFactor;\r\n\r\n#include \x3cedgeRenderer/adjustProjectedPosition.glsl\x3e\r\n#include \x3cedgeRenderer/styleOutputs.glsl\x3e\r\n#include \x3cedgeRenderer/lineAmplitude.glsl\x3e\r\n#include \x3cedgeRenderer/util.glsl\x3e\r\n\r\nvec4 calculateGeometricOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n  vec2 sideness \x3d unpackedAttributes.sideness;\r\n  vec2 sidenessNorm \x3d unpackedAttributes.sidenessNorm;\r\n\r\n  vWorldPosition \x3d mix(worldPosV0, worldPosV1, sidenessNorm.y).xyz;\r\n\r\n  vec4 viewPos \x3d mix(viewPosV0, viewPosV1, sidenessNorm.y);\r\n  vec4 projPosV0 \x3d uProj * viewPosV0;\r\n  vec4 projPosV1 \x3d uProj * viewPosV1;\r\n  vec4 projPos \x3d uProj * viewPos;\r\n\r\n  vec3 screenSpaceLineNDC \x3d (projPosV1.xyz / projPosV1.w - projPosV0.xyz / projPosV0.w);\r\n  vec2 screenSpaceLinePixels \x3d screenSpaceLineNDC.xy * uNDCToPixel;\r\n  float lineLengthPixels \x3d length(screenSpaceLinePixels);\r\n\r\n  float dzPerPixel \x3d screenSpaceLineNDC.z / lineLengthPixels;\r\n  vec2 screenSpaceDirection \x3d screenSpaceLinePixels / lineLengthPixels;\r\n  vec2 perpendicularScreenSpaceDirection \x3d vec2(screenSpaceDirection.y, -screenSpaceDirection.x) * sideness.x;\r\n\r\n  float falloffFactor \x3d distanceBasedPerspectiveFactor(-viewPos.z) * uPixelRatio;\r\n  float lineWidthPixels \x3d unpackedAttributes.lineWidthPixels * falloffFactor;\r\n\r\n  float extensionLengthPixels \x3d calculateExtensionLength(unpackedAttributes.extensionLengthPixels, lineLengthPixels) * falloffFactor;\r\n  float lineAmplitudePixels \x3d calculateLineAmplitude(unpackedAttributes) * uPixelRatio;\r\n\r\n  vSizeFalloffFactor \x3d falloffFactor;\r\n\r\n  float lineWidthAndAmplitudePixels \x3d lineWidthPixels + lineAmplitudePixels + lineAmplitudePixels;\r\n  float extendedLineLengthPixels \x3d lineLengthPixels + extensionLengthPixels + extensionLengthPixels;\r\n\r\n#ifdef ANTIALIASING\r\n\r\n  const float aaPaddingPixels \x3d 1.0;\r\n\r\n  // Line size with padding\r\n  float halfAAPaddedLineWidthAndAmplitudePixels \x3d lineWidthAndAmplitudePixels * 0.5 + aaPaddingPixels;\r\n  float aaPaddedRoundedCapSizePixels \x3d lineWidthPixels * 0.5 + aaPaddingPixels;\r\n\r\n  // Line length with padding\r\n  float aaPaddedLineLengthPixels \x3d extendedLineLengthPixels + aaPaddingPixels + aaPaddingPixels;\r\n  float halfAAPaddedLineLengthPixels \x3d aaPaddedLineLengthPixels * 0.5;\r\n\r\n#else /* ANTIALIASING */\r\n\r\n  // Even if there is no AA, we still want to do proper \x3c1px rendering,\r\n  // so we effectively clamp the pixel sizes to minimum of 1px and compute\r\n  // coverage in the fragment shader\r\n  float halfAAPaddedLineWidthAndAmplitudePixels \x3d max(lineWidthAndAmplitudePixels, 1.0) * 0.5;\r\n  float aaPaddedRoundedCapSizePixels \x3d max(lineWidthPixels, 1.0) * 0.5;\r\n\r\n  float halfAAPaddedLineLengthPixels \x3d max(extendedLineLengthPixels, 1.0) * 0.5;\r\n\r\n#endif /* ANTIALIASING */\r\n\r\n  // Half line width in NDC including padding for anti aliasing\r\n  vec2 halfAAPaddedLineWidthAndAmplitudeNDC \x3d halfAAPaddedLineWidthAndAmplitudePixels * uPixelToNDC;\r\n  vec2 aaPaddedRoundedCapSizeNDC \x3d aaPaddedRoundedCapSizePixels * uPixelToNDC;\r\n  vec2 extensionLengthNDC \x3d extensionLengthPixels * uPixelToNDC;\r\n\r\n  // Compute screen space position of vertex, offsetting for line size and end caps\r\n  vec2 ndcOffset \x3d (\r\n      screenSpaceDirection * sideness.y * (aaPaddedRoundedCapSizeNDC + extensionLengthNDC)\r\n    + perpendicularScreenSpaceDirection * halfAAPaddedLineWidthAndAmplitudeNDC\r\n  );\r\n\r\n  projPos.xy +\x3d ndcOffset * projPos.w;\r\n  projPos.z +\x3d (dzPerPixel * (aaPaddedRoundedCapSizePixels + extensionLengthPixels)) * sideness.y * projPos.w;\r\n\r\n  projPos \x3d adjustProjectedPosition(projPos, worldNormal, 1.0 + max((lineWidthAndAmplitudePixels - 1.0) * 0.5, 0.0));\r\n\r\n  // Line length with end caps\r\n  float aaPaddedLineWithCapsLengthPixels \x3d extendedLineLengthPixels + aaPaddedRoundedCapSizePixels + aaPaddedRoundedCapSizePixels;\r\n\r\n  float pixelPositionAlongLine \x3d aaPaddedLineWithCapsLengthPixels * sidenessNorm.y - aaPaddedRoundedCapSizePixels;\r\n\r\n  // Position in pixels with origin at first vertex of line segment\r\n  vPosition \x3d vec3(\r\n    halfAAPaddedLineWidthAndAmplitudePixels * sideness.x,\r\n    pixelPositionAlongLine,\r\n    pixelPositionAlongLine / extendedLineLengthPixels\r\n  );\r\n\r\n  // The line width radius in pixels\r\n  vRadius \x3d lineWidthPixels * 0.5;\r\n  vLineLengthPixels \x3d extendedLineLengthPixels;\r\n\r\n#ifdef SILHOUETTE\r\n\r\n  gl_Position \x3d isSilhouetteEdge(viewPosV0, aNormalA, aNormalB) ? projPos : vec4(10.0, 10.0, 10.0, 1.0);\r\n\r\n#else /* SILHOUETTE */\r\n\r\n  gl_Position \x3d projPos;\r\n\r\n#endif /* SILHOUETTE */\r\n\r\n#if (MODE \x3d\x3d MODE_UBER)\r\n\r\n  if (unpackedAttributes.type \x3c\x3d 0.0 \x26\x26 lineLengthPixels \x3c\x3d 3.0) {\r\n    gl_Position \x3d vec4(10.0, 10.0, 10.0, 1.0);\r\n  }\r\n\r\n#elif (MODE \x3d\x3d MODE_SKETCH)\r\n\r\n  if (lineLengthPixels \x3c\x3d 3.0) {\r\n    gl_Position \x3d vec4(10.0, 10.0, 10.0, 1.0);\r\n  }\r\n\r\n#endif\r\n\r\n  return projPos;\r\n}\r\n\r\n#if (MODE \x3d\x3d MODE_UBER)\r\n\r\nUnpackedAttributes unpackAttributes(ComponentData component) {\r\n\r\n  vec2 sidenessNorm \x3d aSideness;\r\n  vec2 sideness \x3d sidenessNorm * 2.0 - 1.0;\r\n\r\n  float fType \x3d component.type;\r\n  float extensionLengthPixels \x3d component.extensionLength;\r\n  float lineWidth \x3d component.lineWidth;\r\n\r\n  if (fType \x3c\x3d 0.0) {\r\n    extensionLengthPixels *\x3d aVariantExtension * 2.0 - 1.0;\r\n  }\r\n\r\n  return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels, fType);\r\n}\r\n\r\n#else /* (MODE \x3d\x3d MODE_UBER) */\r\n\r\nUnpackedAttributes unpackAttributes(ComponentData component) {\r\n  vec2 sidenessNorm \x3d aSideness;\r\n  vec2 sideness \x3d sidenessNorm * 2.0 - 1.0;\r\n  float extensionLengthPixels \x3d component.extensionLength;\r\n\r\n#if (MODE \x3d\x3d MODE_SKETCH)\r\n\r\n  extensionLengthPixels *\x3d aVariantExtension * 2.0 - 1.0;\r\n\r\n#endif\r\n\r\n  float lineWidth \x3d component.lineWidth;\r\n\r\n  return UnpackedAttributes(sideness, sidenessNorm, lineWidth, extensionLengthPixels);\r\n}\r\n\r\n#endif /* (MODE \x3d\x3d MODE_UBER) */\r\n\r\nvoid main() {\r\n  ComponentData component \x3d readComponentData();\r\n  UnpackedAttributes unpackedAttributes \x3d unpackAttributes(component);\r\n\r\n  vec4 worldPosV0 \x3d uModel * vec4(aPosition0, 1.0);\r\n  vec4 worldPosV1 \x3d uModel * vec4(aPosition1, 1.0);\r\n\r\n  vec4 viewPosV0 \x3d uView * worldPosV0;\r\n  vec4 viewPosV1 \x3d uView * worldPosV1;\r\n\r\n#ifdef SILHOUETTE\r\n\r\n  vec3 worldNormal \x3d silhouetteWorldNormal(aNormalA, aNormalB);\r\n\r\n#else /* SILHOUETTE */\r\n\r\n  vec3 worldNormal \x3d modelToWorldNormal(aNormal);\r\n\r\n#endif /* SILHOUETTE */\r\n\r\n  // General geometric computation for all types of edges\r\n  vec4 projPos \x3d calculateGeometricOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, worldNormal, unpackedAttributes);\r\n\r\n  // Component color\r\n  vColor \x3d component.color;\r\n\r\n  // Specific computation for different edge styles\r\n  calculateStyleOutputs(viewPosV0, viewPosV1, worldPosV0, worldPosV1, projPos, worldNormal, unpackedAttributes);\r\n}\r\n",
"lineAmplitude.glsl":"// Solid\r\n\r\n#if (MODE \x3d\x3d MODE_UBER || MODE \x3d\x3d MODE_SOLID)\r\n\r\n  float calculateLineAmplitudeSolid() {\r\n    return 0.0;\r\n  }\r\n\r\n#endif\r\n\r\n#if (MODE \x3d\x3d MODE_SOLID)\r\n\r\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\r\n    return calculateLineAmplitudeSolid();\r\n  }\r\n\r\n#endif\r\n\r\n// Sketch\r\n\r\n#if (MODE \x3d\x3d MODE_UBER || MODE \x3d\x3d MODE_SKETCH)\r\n\r\n  uniform float uStrokesAmplitude;\r\n\r\n  float calculateLineAmplitudeSketch() {\r\n    return uStrokesAmplitude;\r\n  }\r\n\r\n#endif\r\n\r\n#if (MODE \x3d\x3d MODE_SKETCH)\r\n\r\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\r\n    return calculateLineAmplitudeSketch();\r\n  }\r\n\r\n#endif\r\n\r\n// Uber\r\n\r\n#if (MODE \x3d\x3d MODE_UBER)\r\n\r\n  float calculateLineAmplitude(UnpackedAttributes unpackedAttributes) {\r\n    float type \x3d unpackedAttributes.type;\r\n\r\n    if (type \x3c\x3d 0.0) {\r\n      return calculateLineAmplitudeSketch();\r\n    }\r\n    else {\r\n      return calculateLineAmplitudeSolid();\r\n    }\r\n  }\r\n\r\n#endif\r\n",
"lineOffset.glsl":"#include \x3cutil/encoding.glsl\x3e\r\n\r\n// Sketch\r\n\r\n#if (MODE \x3d\x3d MODE_UBER || MODE \x3d\x3d MODE_SKETCH)\r\n\r\n  uniform sampler2D uStrokesTexture;\r\n  uniform float uStrokesNormalizationScale;\r\n\r\n  varying vec2 vStrokeUV;\r\n\r\n  float calculateLineOffsetSketch() {\r\n    float offsetNorm \x3d rgba2float(texture2D(uStrokesTexture, vStrokeUV));\r\n    return (offsetNorm - 0.5) * uStrokesNormalizationScale;\r\n  }\r\n\r\n  float calculateLinePressureSketch() {\r\n    return rgba2float(texture2D(uStrokesTexture, vStrokeUV + vec2(0.0, 0.5)));\r\n  }\r\n\r\n#endif\r\n\r\n#if (MODE \x3d\x3d MODE_SKETCH)\r\n\r\n  float calculateLineOffset() {\r\n    return calculateLineOffsetSketch();\r\n  }\r\n\r\n  float calculateLinePressure() {\r\n    return calculateLinePressureSketch();\r\n  }\r\n\r\n#endif\r\n\r\n// Solid\r\n\r\n#if (MODE \x3d\x3d MODE_UBER || MODE \x3d\x3d MODE_SOLID)\r\n\r\n  float calculateLineOffsetSolid() {\r\n    return 0.0;\r\n  }\r\n\r\n  float calculateLinePressureSolid() {\r\n    return 1.0;\r\n  }\r\n\r\n#endif\r\n\r\n#if (MODE \x3d\x3d MODE_SOLID)\r\n\r\n  float calculateLineOffset() {\r\n    return calculateLineOffsetSolid();\r\n  }\r\n\r\n  float calculateLinePressure() {\r\n    return calculateLinePressureSolid();\r\n  }\r\n\r\n#endif\r\n\r\n// Uber\r\n\r\n#if (MODE \x3d\x3d MODE_UBER)\r\n  varying float vType;\r\n\r\n  float calculateLineOffset() {\r\n    if (vType \x3c\x3d 0.0) {\r\n      return calculateLineOffsetSketch();\r\n    }\r\n    else {\r\n      return calculateLineOffsetSolid();\r\n    }\r\n  }\r\n\r\n  float calculateLinePressure() {\r\n    if (vType \x3c\x3d 0.0) {\r\n      return calculateLinePressureSketch();\r\n    }\r\n    else {\r\n      return calculateLinePressureSolid();\r\n    }\r\n  }\r\n#endif\r\n",
"styleOutputs.glsl":"#if (MODE \x3d\x3d MODE_UBER || MODE \x3d\x3d MODE_SKETCH)\r\n\r\n  uniform vec2 uStrokesTextureScale;\r\n  uniform float uStrokesLog2Resolution;\r\n  uniform float uStrokeVariants;\r\n\r\n  varying vec2 vStrokeUV;\r\n  varying float vLineIndex;\r\n\r\n  void calculateStyleOutputsSketch(float lineLength, UnpackedAttributes unpackedAttributes) {\r\n    vec2 sidenessNorm \x3d unpackedAttributes.sidenessNorm;\r\n\r\n    float lineIndex \x3d clamp(ceil(log2(lineLength)), 0.0, uStrokesLog2Resolution);\r\n\r\n    vStrokeUV \x3d vec2(exp2(lineIndex) * sidenessNorm.y, lineIndex * uStrokeVariants + aVariantStroke + 0.5) * uStrokesTextureScale;\r\n    vStrokeUV.x +\x3d aVariantOffset;\r\n\r\n    vLineIndex \x3d lineIndex;\r\n  }\r\n#endif\r\n\r\n#if (MODE \x3d\x3d MODE_SOLID)\r\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n  }\r\n#elif (MODE \x3d\x3d MODE_SKETCH)\r\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n    calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);\r\n  }\r\n#elif (MODE \x3d\x3d MODE_UBER)\r\n  varying float vType;\r\n\r\n  void calculateStyleOutputs(vec4 viewPosV0, vec4 viewPosV1, vec4 worldPosV0, vec4 worldPosV1, vec4 projPos, vec3 worldNormal, UnpackedAttributes unpackedAttributes) {\r\n    vType \x3d unpackedAttributes.type;\r\n\r\n    if (unpackedAttributes.type \x3c\x3d 0.0) {\r\n      calculateStyleOutputsSketch(vLineLengthPixels, unpackedAttributes);\r\n    }\r\n  }\r\n#endif\r\n",
"util.glsl":"uniform float uDistanceFalloffFactor;\r\n\r\nfloat distanceBasedPerspectiveFactor(float distance) {\r\n  return clamp(sqrt(uDistanceFalloffFactor / distance), 0.0, 1.0);\r\n}\r\n\r\nuniform sampler2D uComponentDataTex;\r\nuniform vec2 uComponentDataTexInvDim;\r\n\r\nattribute float aComponentIndex;\r\n\r\n#define COMPONENT_COLOR_FIELD_OFFSET 0.0\r\n#define COMPONENT_OTHER_FIELDS_OFFSET 1.0\r\n#define COMPONENT_FIELD_COUNT 2.0\r\n\r\n#define LINE_WIDTH_FRACTION_FACTOR 8.0\r\n#define EXTENSION_LENGTH_OFFSET 128.0\r\n\r\n#define COMPONENT_TEX_WIDTH 4096.0\r\n\r\nvec2 componentTextureCoords(float componentIndex, float fieldOffset) {\r\n  float fieldIndex \x3d COMPONENT_FIELD_COUNT * componentIndex + fieldOffset;\r\n\r\n  float rowIndex \x3d floor(fieldIndex / COMPONENT_TEX_WIDTH);\r\n  float colIndex \x3d mod(fieldIndex, COMPONENT_TEX_WIDTH);\r\n\r\n  vec2 linearIndex \x3d vec2(\r\n    (colIndex + 0.5) / COMPONENT_TEX_WIDTH,\r\n    (rowIndex + 0.5) * uComponentDataTexInvDim.y\r\n  );\r\n\r\n  return linearIndex;\r\n}\r\n\r\nstruct ComponentData {\r\n  vec4 color;\r\n  float lineWidth;\r\n  float extensionLength;\r\n  float type;\r\n};\r\n\r\nComponentData readComponentData() {\r\n  vec2 colorIndex \x3d componentTextureCoords(aComponentIndex, COMPONENT_COLOR_FIELD_OFFSET);\r\n  vec2 otherIndex \x3d componentTextureCoords(aComponentIndex, COMPONENT_OTHER_FIELDS_OFFSET);\r\n\r\n  vec4 colorValue \x3d texture2D(uComponentDataTex, colorIndex);\r\n  vec4 otherValue \x3d texture2D(uComponentDataTex, otherIndex);\r\n\r\n  return ComponentData(\r\n    vec4(colorValue.rgb, colorValue.a * otherValue.w), // otherValue.w stores separate opacity\r\n    otherValue.x * (255.0 / LINE_WIDTH_FRACTION_FACTOR),\r\n    otherValue.y * 255.0 - EXTENSION_LENGTH_OFFSET,\r\n    -(otherValue.z * 255.0) + 0.5 // SOLID (\x3d0/255) needs to be \x3e 0.0, SKETCHY (\x3d1/255) needs to be \x3c\x3d 0;\r\n  );\r\n}\r\n\r\nvec3 modelToWorldNormal(vec3 normal) {\r\n  return (uModel * vec4(normal, 0.0)).xyz;\r\n}\r\n\r\nvec3 silhouetteWorldNormal(vec3 normalA, vec3 normalB) {\r\n  return modelToWorldNormal(normalize(normalA + normalB));\r\n}\r\n\r\n// Fall-off extension length for shorter strokes, starting from strokes that are 256 size,\r\n// fall-off exponentially\r\nfloat calculateExtensionLength(float extensionLength, float lineLength) {\r\n  return extensionLength / (log2(max(1.0, 256.0 / lineLength)) * 0.2 + 1.0);\r\n}\r\n\r\n#ifdef SILHOUETTE\r\n\r\n// #uniforms: uView, uModel\r\nbool isSilhouetteEdge(vec4 viewPos, vec3 normalA, vec3 normalB) {\r\n  // transform the two face normals\r\n  vec3 viewNormalA \x3d (uView * uModel * vec4(normalA, 0.0)).xyz;\r\n  vec3 viewNormalB \x3d (uView * uModel * vec4(normalB, 0.0)).xyz;\r\n\r\n  // compute the direction from the edge to the camera\r\n  vec3 viewDir \x3d -viewPos.xyz;\r\n\r\n  // check which of the two faces are visible\r\n  // display the edge if exactly one of the two is visible\r\n  float faceAVisible \x3d dot(viewDir, viewNormalA); // positive if visible\r\n  float faceBVisible \x3d dot(viewDir, viewNormalB); // positive if visible\r\n\r\n  // 1 if exactly one face visible, 0 otherwise\r\n  return faceAVisible * faceBVisible \x3c 0.0;\r\n}\r\n\r\n#endif /* SILHOUETTE */\r\n"},
environment:{"realisticAtmosphere.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/encoding.glsl\x3e\r\n#include \x3cutil/color.glsl\x3e\r\n\r\n// Light\r\nuniform vec3 v3LightDir;      // The direction vector to the light source\r\nuniform vec3 v3InvWavelength; // 1 / pow(wavelength, 4) for the red, green, and blue channels\r\nuniform vec3 v3InvWavelengthScaled; //v3InvWavelength * fKr4PI + fKm4PI\r\n\r\n// Atmosphere\r\nconst float fKrESun \x3d 0.075;        // Kr * ESun \x3d 0.005 * 15.0\r\nconst float fKmESun \x3d 0.015;        // Km * ESun \x3d 0.005 * 15\r\n\r\n// Radii\r\nuniform vec4 v4Radii; // (fInnerRadius, fInnerRadius^2, fOuterRadius, fOuterRadius^2)\r\n\r\nfloat fInnerRadius \x3d v4Radii[0];   // The inner (planetary) radius\r\nfloat fInnerRadius2 \x3d v4Radii[1];  // fInnerRadius^2\r\nfloat fOuterRadius \x3d v4Radii[2];   // The outer (atmosphere) radius\r\nfloat fOuterRadius2 \x3d v4Radii[3];  // fOuterRadius^2\r\n\r\n// Atmosphere parameters:\r\n// fScale:                    1.0 / (fOuterRadius - fInnerRadius)\r\n// fScaleDepth:               The scale depth (i.e. the altitude at which the atmosphere's average density is found)\r\n// fScaleOverScaleDepth:      fScale / fScaleDepth\r\n// fOneOverScaleDepth:        1.0 / fScaleDepth\r\n\r\n// fScaleDepthBlue:           The scale depth (i.e. the altitude at which the atmosphere's average density is found)\r\n// fScaleOverScaleDepthBlue:  fScale / fScaleDepthBlue\r\n// fOneOverScaleDepthBlue;    1.0 / fScaleDepthBlue\r\n\r\nuniform vec4 v4AtmosParams1; // (fScale, fScaleDepth, fScaleOverScaleDepth, fOneOverScaleDepth)\r\nuniform vec4 v4AtmosParams2; // (g, fScaleDepthBlue, fScaleOverScaleDepthBlue, fOneOverScaleDepthBlue)\r\n\r\nfloat fScale \x3d v4AtmosParams1.x;\r\nvec2 v2ScaleDepth \x3d vec2(v4AtmosParams1.y,v4AtmosParams2.y);//fScaleDepth, fScaleDepthBlue\r\nvec2 v2ScaleOverScaleDepth \x3d vec2(v4AtmosParams1.z,v4AtmosParams2.z);//fScaleOverScaleDepth, fScaleOverScaleDepthBlue\r\nvec2 v2OneOverScaleDepth \x3d vec2(v4AtmosParams1.w,v4AtmosParams2.w);//fOneOverScaleDepth, fOneOverScaleDepthBlue\r\n\r\n#ifndef HAZE\r\nuniform vec4 v4AtmosParams3; // (g2, fMiePhaseCoefficients, fLowerAlphaBlendBound, fOneOverOuterRadiusMinusAlphaBlendBound)\r\nuniform float fInnerFadeDistance;\r\nuniform float fAltitudeFade;\r\n\r\nfloat g \x3d v4AtmosParams2.x;\r\nfloat g2 \x3d v4AtmosParams3.x;\r\nfloat fMiePhaseCoefficients \x3d v4AtmosParams3.y;\r\nfloat fLowerAlphaBlendBound \x3d v4AtmosParams3.z;\r\nfloat fOneOverOuterRadiusMinusAlphaBlendBound \x3d v4AtmosParams3.w;\r\n#endif\r\n\r\n// Camera\r\nuniform vec3 v3CameraPos;     // The camera's current position\r\nuniform vec2 nearFar;\r\n\r\nuniform vec4 v4SphereComp;              // (fCameraHeight, fCameraHeight2, fC, fCSur)\r\nfloat fCameraHeight \x3d v4SphereComp[0];  // The camera's current height\r\nfloat fCameraHeight2 \x3d v4SphereComp[1]; // fCameraHeight^2\r\nfloat fC \x3d v4SphereComp[2];             // fCameraHeight2 - fOuterRadius2; // C \x3d ||o-c||^2 - r^2\r\nfloat fCSur \x3d v4SphereComp[3];          // fCameraHeight2 - (fInnerRadius2 - 63756370000.0); // C \x3d ||o-c||^2 - r^2\r\n\r\n// Camera HDR\r\n#ifdef HAZE\r\nconst float fExposure \x3d 1.5;\r\n#else\r\nconst float fExposure \x3d 2.0;\r\n#endif\r\n\r\n#ifdef HAZE\r\n// Depth texture\r\nuniform sampler2D tDepth;\r\n#endif\r\n\r\n// Testing variables\r\nuniform float showTest;\r\n\r\n// Varyings\r\nvarying vec3 v3EyeDir;\r\nvarying vec3 v3WorldRay;\r\nvarying vec2 vtc;\r\n\r\n// Loop constants for integral approximation\r\nconst float fSamples \x3d 5.0;\r\nconst int maxSamples \x3d 5;\r\n\r\n#ifdef HAZE\r\n  const float fOneOverGamma \x3d 1.0;//Gamma \x3d 1.0\r\n#else\r\n  const float fOneOverGamma \x3d 0.454545; // Gamma \x3d 2.2\r\n#endif\r\n  const vec3 v3OneOverGamma \x3d vec3(fOneOverGamma);\r\n\r\n// ToneMapping operators\r\nvec3 expTM(vec3 inputColor,float exposure){\r\n    return pow(1.0 - exp(inputColor * -exposure), v3OneOverGamma);\r\n}\r\n\r\n#ifndef HAZE\r\nvec3 reinhardTM(vec3 inputColor, float exposure){\r\n  vec3 intermediate \x3d inputColor *exposure;\r\n  intermediate /\x3d (1.0+intermediate);\r\n  return pow(intermediate, v3OneOverGamma);\r\n}\r\n#endif\r\n\r\n// Approximation for inner integral based on a radii ratio of 10.25:10\r\nfloat scale(float fCos){\r\n  float x \x3d 1.0 - fCos;\r\n  return exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\nvoid main() {\r\n  vec3 cameraPosition \x3d v3CameraPos;\r\n\r\n  // Debug variables\r\n  vec3 test \x3d vec3(0.0,0.0,0.0);\r\n\r\n  // Obtain ray from Camera\r\n  vec3 worldSpaceRay \x3d normalize(v3WorldRay);\r\n\r\n  // Compute Atmosphere intersection; i.e. ray/sphere intersection\r\n  float B \x3d 2.0 * dot(cameraPosition, worldSpaceRay); // B \x3d 2(l * (o-c))\r\n  float det \x3d B*B - 4.0 * fC; // det \x3d B^2 - 4.0* C\r\n\r\n  // idealized sphere intersection to discard early some pixels\r\n  float detSur \x3d B*B - 4.0 * fCSur; // det \x3d B^2 - 4.0* C\r\n\r\n  // the minimal sample start position:\r\n  // at the camera by default, on the earth radius surface if the camera is underground.\r\n  float fMinRayStart \x3d 0.0;\r\n#ifndef HAZE\r\n  // When the ray intersects the earth surface, fade the sky to a simple light direction\r\n  // based color. This is used to make sure we have a white background in underground\r\n  // mode (at noon).\r\n  float fSurfaceBlend \x3d 0.0;\r\n  vec4 surfaceColor \x3d vec4(0.0);\r\n  if (detSur \x3e\x3d 0.0) {\r\n    float nearSurfaceT \x3d max(0.0, 0.5 *(-B - sqrt(detSur)));\r\n    float farSurfaceT \x3d max(0.0, 0.5 *(-B + sqrt(detSur)));\r\n\r\n    if (nearSurfaceT \x3d\x3d 0.0) {\r\n      fMinRayStart \x3d farSurfaceT;\r\n    }\r\n\r\n    // Compute lighting at the point where the ray enters the earth surface\r\n    // Lighting computation is copied from the terrain shader.\r\n    vec3 vPos \x3d cameraPosition + worldSpaceRay * nearSurfaceT;\r\n    float fLightAngle \x3d dot(v3LightDir, normalize(vPos));\r\n    float fBrightness \x3d max(0.0, (smoothstep(-1.0, 0.8, 2.0 * fLightAngle)));\r\n\r\n    // Make the surface transparent based on altitude\r\n    surfaceColor \x3d vec4(fBrightness, fBrightness, fBrightness, 1.0 - fAltitudeFade);\r\n\r\n    // Fade based on the distance the ray travels below the earth surface\r\n    float fRelDist \x3d (farSurfaceT - nearSurfaceT) / fInnerFadeDistance;\r\n\r\n    // early exit\r\n    if (fRelDist \x3e 1.0) {\r\n      gl_FragColor \x3d surfaceColor;\r\n      return;\r\n    }\r\n\r\n    fSurfaceBlend \x3d smoothstep(0.0, 1.0, fRelDist * fRelDist);\r\n  }\r\n#endif\r\n\r\n  // Inside Atmosphere\r\n  if (det \x3e\x3d 0.0) {\r\n#ifdef HAZE\r\n    // only use red channel from depth texture.\r\n    // see 'Issues' at https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture\r\n    float depthSample \x3d texture2D(tDepth, vtc).r;\r\n\r\n    float zNear \x3d nearFar[0];\r\n    float zFar \x3d nearFar[1];\r\n\r\n    // http://web.archive.org/web/20130416194336/http://olivers.posterous.com/linear-depth-in-glsl-for-real\r\n    float zNorm \x3d 2.0 * depthSample - 1.0;\r\n    float linDepth \x3d 2.0 * zNear * zFar /\r\n      (zFar + zNear - zNorm * (zFar - zNear));\r\n\r\n    float rayEndT;\r\n    float altitudeAlpha \x3d 1.0;\r\n\r\n    // find intersections with ground, but only between the near and far\r\n    // clipping planes.\r\n    if (depthSample \x3c 1.0 \x26\x26 depthSample \x3e 0.0) {\r\n      vec3 cameraSpaceRay \x3d normalize(v3EyeDir);\r\n      cameraSpaceRay /\x3d cameraSpaceRay.z;\r\n      cameraSpaceRay *\x3d linDepth;\r\n\r\n      float cameraSpaceRayLength \x3d length(cameraSpaceRay);\r\n\r\n      vec3 v3World \x3d cameraPosition + worldSpaceRay * cameraSpaceRayLength;\r\n      float v3WorldRadius2 \x3d dot(v3World, v3World);\r\n\r\n      // Handle tall structures:\r\n      // https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/5450\r\n      float transitionStart \x3d fInnerRadius + 20000.0;\r\n      float transitionHeight \x3d 25000.0;\r\n      float transitionEnd \x3d transitionStart + transitionHeight;\r\n\r\n      float edge0 \x3d transitionStart * transitionStart;\r\n      float edge1 \x3d transitionEnd * transitionEnd;\r\n\r\n      altitudeAlpha \x3d 1.0 - clamp((v3WorldRadius2 - edge0) / (edge1 - edge0), 0.0, 1.0);\r\n      rayEndT \x3d cameraSpaceRayLength;\r\n\r\n      if (altitudeAlpha \x3e 0.0 \x26\x26 detSur \x3e 0.0) {\r\n        float nearSurfaceT \x3d 0.5 *(-B - sqrt(detSur));\r\n        float interp \x3d clamp(((fCameraHeight - fInnerRadius) - 2000000.0) / 6000000.0, 0.0, 1.0);\r\n        rayEndT \x3d mix(cameraSpaceRayLength, nearSurfaceT, interp);\r\n      }\r\n    }\r\n#endif\r\n\r\n    float rayStartT \x3d 0.5 *(-B - sqrt(det)); //near intersection with atmosphere\r\n#ifdef HAZE\r\n    float nearT \x3d abs(rayStartT);\r\n    float farT \x3d abs(rayEndT);\r\n#else\r\n    float rayEndT \x3d 0.5 *(-B + sqrt(det)); //far intersection with atmosphere\r\n\r\n#endif\r\n\r\n    float fDistance; // calculate its scattering offset\r\n    // Calculate the ray's starting position\r\n    if (rayStartT \x3c fMinRayStart)\r\n    { // ray starts from camera or inner radius sphere to far\r\n      rayStartT \x3d fMinRayStart;\r\n#ifndef HAZE\r\n      // clamp to value at inner radius altitude\r\n      fDistance \x3d fScale * min(0.0, fInnerRadius - fCameraHeight);\r\n#endif\r\n    }\r\n#ifndef HAZE\r\n    else\r\n    { // outside atmosphere\r\n      fDistance \x3d -1.0;\r\n    }\r\n#endif\r\n\r\n    // Initialize the scattering loop variables\r\n    vec3 v3Start \x3d cameraPosition + worldSpaceRay * rayStartT;\r\n\r\n#ifdef HAZE\r\n    vec3 v3End \x3d cameraPosition + worldSpaceRay * rayEndT;\r\n\r\n    float fEndLength \x3d length(v3End);\r\n    float fAltitudeEnd \x3d fEndLength - fInnerRadius;\r\n    float fAltitudeStart \x3d length(v3Start) - fInnerRadius;\r\n\r\n    // for camera positions below altitude 0, invert the altitudes, to achieve\r\n    // a similar haze as above ground. Note that there is a small but visible change\r\n    // when the camera passes altitude 0.\r\n    if (fAltitudeStart \x3c 0.0) {\r\n      fAltitudeStart \x3d -fAltitudeStart;\r\n      fAltitudeEnd \x3d -fAltitudeEnd;\r\n    }\r\n\r\n    // computed for the original end point to get consistent light angles after possible inversions\r\n    float fLightAngle \x3d dot(v3LightDir, v3End) / fEndLength;\r\n\r\n    if (nearT \x3e farT)\r\n    {\r\n      if (fAltitudeStart \x3c fAltitudeEnd)\r\n      {\r\n        // Switch positive slopes for flipped rays\r\n        v3End \x3d cameraPosition + worldSpaceRay * rayStartT;\r\n        v3Start \x3d cameraPosition + worldSpaceRay * rayEndT;\r\n        worldSpaceRay *\x3d -1.0;\r\n        float fTmp \x3d fAltitudeStart;\r\n        fAltitudeStart \x3d fAltitudeEnd;\r\n        fAltitudeEnd \x3d fTmp;\r\n      }\r\n      else if (fAltitudeStart \x3d\x3d fAltitudeEnd)\r\n      { // create minuscule fake slope for integration if the slope is zero\r\n        fAltitudeStart +\x3d 1.0; //BUGFIX, if the height of camera and ground is equal the equation breaks, add fake meter to camera height to get\r\n        // slope for the camera function\r\n      }\r\n    }\r\n\r\n    // Calculate its scattering offset\r\n    // Assumes camera constrains of WSV 3.8\r\n    float fCameraDepth;\r\n    float fCameraDepthBlue;\r\n    if (fAltitudeStart \x3e fOuterRadius - fInnerRadius)\r\n    { // outside atmosphere\r\n      fDistance \x3d fInnerRadius - fOuterRadius;\r\n    } else\r\n    {\r\n      fDistance \x3d fAltitudeEnd - fAltitudeStart;\r\n    }\r\n\r\n#endif\r\n    vec2 v2OpticalStartDepth \x3d exp(fDistance * v2OneOverScaleDepth);\r\n\r\n    float fRayLength \x3d rayEndT - rayStartT;\r\n    float fSampleLength \x3d fRayLength / fSamples;\r\n    float fScaledLength \x3d fSampleLength * fScale;\r\n    vec3 v3SampleRay \x3d worldSpaceRay * fSampleLength;\r\n    vec3 v3SamplePoint \x3d v3Start + v3SampleRay * 0.5;\r\n\r\n#ifdef HAZE\r\n    float fCameraAngle \x3d dot(-worldSpaceRay, v3End) / length(v3End);\r\n    float fScaleCameraAngle \x3d scale(fCameraAngle);\r\n    vec2 v2CameraOffset \x3d fScaleCameraAngle*v2OpticalStartDepth;\r\n\r\n    float scaledValues \x3d scale(fLightAngle) + fScaleCameraAngle;\r\n    vec2 v2ScaledValuesDepth \x3d scaledValues * v2ScaleDepth;\r\n#else\r\n    float fCameraAngle \x3d dot(worldSpaceRay, v3Start / length(v3Start));\r\n    float angleMultiplier \x3d fCameraAngle\x3e0.0?fCameraAngle:0.0;\r\n\r\n    float fScaleCameraAngle \x3d scale(fCameraAngle);\r\n    vec2 v2CameraOffset \x3d fScaleCameraAngle*v2OpticalStartDepth * v2ScaleDepth;\r\n#endif\r\n\r\n    // Loop variables\r\n    vec3 v3FrontColor \x3d vec3(0.0, 0.0, 0.0);\r\n    vec3 v3FrontColorBlue \x3d vec3(0.0, 0.0, 0.0);\r\n    vec3 v3Attenuate\x3d vec3(0.0, 0.0, 0.0);\r\n    vec3 v3AttenuateBlue \x3d vec3(0.0, 0.0, 0.0);\r\n\r\n    // Now loop through the sample rays\r\n    for(int i\x3d0; i\x3cmaxSamples; i++) {\r\n      float fHeight \x3d length(v3SamplePoint);\r\n      float fAltitude \x3d abs(fHeight - fInnerRadius);\r\n\r\n      vec2 v2Depth \x3d exp(-fAltitude * v2ScaleOverScaleDepth);\r\n#ifdef HAZE\r\n      vec2 v2Scatter \x3d v2Depth*v2ScaledValuesDepth-v2CameraOffset;\r\n#else\r\n      float fLightAngle \x3d dot(v3LightDir, v3SamplePoint) / fHeight;\r\n      float fCameraAngle \x3d dot(worldSpaceRay, v3SamplePoint) / fHeight;\r\n      float fTempScaledValues \x3d scale(fLightAngle) - scale(fCameraAngle);\r\n      vec2 v2Scatter \x3d v2CameraOffset + fTempScaledValues*v2Depth* v2ScaleDepth;\r\n#endif\r\n      v3Attenuate \x3d exp(-v2Scatter.x * v3InvWavelengthScaled);\r\n      v3AttenuateBlue \x3d exp(-v2Scatter.y * v3InvWavelengthScaled);\r\n\r\n      v3FrontColor +\x3d v3Attenuate * v2Depth.x;\r\n      v3FrontColorBlue +\x3d v3AttenuateBlue * v2Depth.y;\r\n\r\n      v3SamplePoint +\x3d v3SampleRay;\r\n    }\r\n\r\n    // Phase computation\r\n    // clamp to avoid numerical instability at fCos \x3d\x3d -1.0 (and close values) to display fake sun\r\n    float fCos \x3d clamp(dot(v3LightDir, -worldSpaceRay ),-0.9999999,1.0);\r\n    float fOnePlusCos2 \x3d fCos*fCos + 1.0;\r\n#ifdef HAZE\r\n    // Finally, scale the Rayleigh colors and set up the varying variables for the pixel shader\r\n    vec3 colorCoefficients \x3d (fScaledLength* 0.75 * fOnePlusCos2)*(fKrESun*v3InvWavelength+fKmESun);\r\n\r\n    // Scaled Length is only applied afterwards to save multiplications\r\n    vec3 v3Color \x3d colorCoefficients *v3FrontColor;\r\n    vec3 v3ColorBlue \x3d colorCoefficients *v3FrontColorBlue;\r\n#else\r\n    vec3 v3RayleighCoefficients \x3d (fScaledLength*0.75 * fOnePlusCos2*fKrESun)*v3InvWavelength;\r\n    float fMieCoefficients \x3d fScaledLength*fKmESun * fMiePhaseCoefficients * fOnePlusCos2 / pow(1.0 + g2 - 2.0*g*fCos, 1.5);\r\n\r\n    // Calculate the attenuation factor for the ground\r\n    vec3 v3Color \x3d v3RayleighCoefficients * v3FrontColor + fMieCoefficients * v3FrontColor;\r\n    vec3 v3ColorBlue \x3d v3RayleighCoefficients * v3FrontColorBlue + fMieCoefficients * v3FrontColorBlue;\r\n#endif\r\n\r\n    // HDR to LDR conversion\r\n    vec3 ldrBlue \x3d expTM(v3ColorBlue,2.0*fExposure);\r\n    vec3 ldrRed \x3d expTM(v3Color,fExposure);\r\n\r\n    // mix reddish and blueish atmosphere\r\n    vec3 LDR \x3d mix(ldrBlue,ldrRed,0.2);\r\n#ifdef HAZE\r\n    LDR *\x3d (1.0-fCameraAngle);\r\n    vec3 hsv \x3d rgb2hsv(LDR);\r\n    hsv.y \x3d clamp(hsv.y*1.5,0.0,1.0); // boost haze saturation by 50%\r\n    LDR \x3d hsv2rgb(hsv);\r\n    vec3 finalColor \x3d LDR;\r\n    // when rendering we specify the blend functions such that\r\n    // newDestColor \x3d oldDestColor*(1.0-finalColor) + finalColor\r\n#else\r\n    // reinhard tonemapper for looking upwards\r\n    vec3 ldrReinhard \x3d reinhardTM(v3Color,fExposure);\r\n    LDR +\x3d angleMultiplier*ldrReinhard;\r\n\r\n    // height dependent parameter to smooth out reddish atmosphere\r\n    float side \x3d (rayEndT+rayStartT)*0.5;\r\n    float atmoHeight \x3d sqrt(fCameraHeight2 - side*side);\r\n    float h2 \x3d clamp(1.0-(atmoHeight-fLowerAlphaBlendBound)/(fOuterRadius-fLowerAlphaBlendBound),0.0,1.0);\r\n\r\n    vec3 finalColor \x3d LDR*h2;\r\n    vec3 hsv \x3d rgb2hsv(finalColor);\r\n    hsv.y \x3d clamp(hsv.y*1.5,0.0,1.0); // boost sky saturation by 50%\r\n    finalColor \x3d hsv2rgb(hsv);\r\n#endif\r\n\r\n#ifndef HAZE\r\n    float atmosStrength \x3d clamp((length(ldrRed)-0.05)*1.05,0.0,1.0);\r\n    gl_FragColor \x3d vec4(finalColor, atmosStrength*clamp(1.0-(atmoHeight-fInnerRadius)/(fOuterRadius-fInnerRadius),0.0,1.0));\r\n    if (fSurfaceBlend \x3e 0.0) {\r\n      gl_FragColor \x3d mix(gl_FragColor, surfaceColor, fSurfaceBlend);\r\n    }\r\n#else\r\n    gl_FragColor \x3d vec4(finalColor, 1.0) * altitudeAlpha;\r\n#endif\r\n\r\n    // Debug variable overlay\r\n    if(showTest\x3e0.0){\r\n      gl_FragColor \x3d vec4(test,1.0);\r\n    }\r\n  } else { // Outside Atmosphere\r\n    gl_FragColor \x3d vec4(0.0);\r\n  }\r\n}\r\n",
"realisticAtmosphere.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\n// Camera\r\nuniform vec2 halfSizeNearPlane;\r\nuniform vec3 v3CameraUp;\r\nuniform vec3 v3CameraRight;\r\nuniform vec3 v3CameraDir;\r\nuniform vec2 v2CameraCenterOffset;\r\n\r\n// Attributes\r\nattribute vec3 position;\r\nattribute vec2 uv0;\r\n\r\n// Varyings\r\nvarying vec3 v3WorldRay;\r\nvarying vec2 vtc;\r\n\r\n#ifdef HAZE\r\nvarying vec3 v3EyeDir;\r\n#endif\r\n\r\nvoid main(void) {\r\n  vec3 v3Pos \x3d position;\r\n  vtc \x3d uv0;\r\n  vec2 rayvtc \x3d uv0 - v2CameraCenterOffset;\r\n\r\n#ifdef HAZE\r\n  v3EyeDir \x3d vec3((2.0*halfSizeNearPlane *rayvtc)-halfSizeNearPlane,-1.0);\r\n#else\r\n  vec3 v3EyeDir \x3d vec3((2.0*halfSizeNearPlane *rayvtc)-halfSizeNearPlane,-1.0);\r\n#endif\r\n  v3WorldRay \x3d v3EyeDir.z*v3CameraDir + v3EyeDir.y*v3CameraUp + v3EyeDir.x*v3CameraRight;\r\n  gl_Position \x3d vec4(v3Pos, 1.0);\r\n}\r\n",
"simpleAtmosphere.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nuniform sampler2D tex;\r\n\r\nvarying vec2 vtc;\r\nvarying float falloff;\r\n\r\n#ifndef PANORAMIC\r\nuniform float altitudeFade;\r\nvarying float innerFactor;\r\n#endif\r\n\r\nvoid main() {\r\n  vec4 texColor \x3d texture2D(tex, vtc);\r\n\r\n#ifdef PANORAMIC\r\n  gl_FragColor \x3d texColor * falloff;\r\n#else\r\n  vec4 atmosphereColor \x3d texColor * falloff;\r\n  vec4 innerColor \x3d vec4(texColor.rgb * falloff, 1.0 - altitudeFade);\r\n  gl_FragColor \x3d mix(atmosphereColor, innerColor, smoothstep(0.0, 1.0, innerFactor));\r\n#endif\r\n}\r\n",
"simpleAtmosphere.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\n\r\n#ifndef PANORAMIC\r\nconst float TWICEPI \x3d 2.0*3.14159265;\r\nconst float ATMOSPHERE_RIM_SEGMENTS \x3d 128.0;\r\n\r\nuniform vec3 silCircleCenter;\r\nuniform vec3 silCircleV1;\r\nuniform vec3 silCircleV2;\r\nuniform vec2 texV;\r\n\r\nuniform float innerScale;  // scale for inner rim\r\nvarying float innerFactor; // 0: outer atmosphere, 1: inner atmosphere\r\n#endif\r\n\r\nuniform vec3 lightDirection;\r\n\r\nattribute vec3 position;\r\nvarying vec2 vtc;\r\nvarying float falloff;\r\n\r\nvoid main(void) {\r\n\r\n#ifdef PANORAMIC\r\n\r\n  vec3 pos \x3d position;\r\n  float ndotl \x3d lightDirection.z;\r\n  vtc \x3d vec2(0.0, position.z+0.05);\r\n\r\n#else\r\n\r\n  innerFactor \x3d clamp(-position.z, 0.0, 1.0);\r\n  float scale \x3d position.y * (1.0 + innerFactor * innerScale);\r\n  float phi \x3d position.x * (TWICEPI / ATMOSPHERE_RIM_SEGMENTS) + 1.0;\r\n  vec3 pos \x3d  (silCircleCenter + sin(phi) * silCircleV1 + cos(phi) * silCircleV2) * scale;\r\n  float ndotl \x3d dot(normalize(position.y \x3e 0.0 ? pos: silCircleCenter), lightDirection);\r\n\r\n  vtc.x \x3d position.x / ATMOSPHERE_RIM_SEGMENTS;\r\n  vtc.y \x3d texV.x * (1.0 - position.z) + texV.y * position.z;\r\n\r\n#endif\r\n\r\n  falloff \x3d max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\r\n\r\n  gl_Position \x3d proj * view * vec4(pos, 1.0);\r\n  gl_Position.z \x3d gl_Position.w; // project atmosphere onto the far plane\r\n}\r\n",
"simpleAtmosphereFade.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nvarying vec4 color;\r\n\r\nvoid main() {\r\n  gl_FragColor \x3d color;\r\n}\r\n","simpleAtmosphereFade.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nattribute vec2 position;\r\n\r\nuniform vec3 lightDirection;\r\nuniform vec3 cameraPosition;\r\n\r\nuniform float undergroundFadeAlpha;\r\n\r\nvarying vec4 color;\r\n\r\nvoid main(void) {\r\n  float ndotl \x3d dot(normalize(cameraPosition), lightDirection);\r\n  float lighting \x3d max(0.0, smoothstep(-1.0, 0.8, 2.0 * ndotl));\r\n\r\n  color \x3d vec4(vec3(lighting), undergroundFadeAlpha);\r\n\r\n  gl_Position \x3d vec4(position.xy, 1.0, 1.0); // on the far plane\r\n}\r\n",
"stars.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nvarying vec4 vcolor;\r\nvarying float vsize;\r\n\r\nvoid main() {\r\n  float cap \x3d 0.7;\r\n  float scale \x3d 1.0/cap;\r\n  float helper \x3d clamp(length(abs(gl_PointCoord-vec2(0.5))),0.0,cap);\r\n  float alpha \x3d clamp((cap-helper)*scale,0.0,1.0);\r\n  float intensity \x3d alpha*alpha*alpha;\r\n  if (vsize \x3c 3.0)\r\n    intensity *\x3d 0.5;\r\n  gl_FragColor \x3d vec4(1.0,1.0,1.0,intensity);\r\n  gl_FragColor.xyz *\x3d vcolor.xyz;\r\n}\r\n",
"stars.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n#include \x3cutil/alignPixel.glsl\x3e\r\n\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform mat4 model;\r\nuniform vec4 viewport;\r\nuniform float pixelRatio;\r\n\r\nattribute vec3 position;\r\nattribute vec4 color;\r\nattribute float size;\r\n\r\nvarying vec4 vcolor;\r\nvarying float vsize;\r\n\r\nvoid main(void) {\r\n  vec4 posProj \x3d proj * view * model*vec4(position*1.0e25,1.0);//move infinitely far away\r\n  gl_Position \x3d alignToPixelCenter(posProj, viewport.zw); //pixel align position\r\n  gl_Position.z \x3d gl_Position.w; // project atmosphere onto the far plane\r\n  vcolor \x3d color / 1.2;\r\n  vsize \x3d size * 5.0 * pixelRatio;\r\n  gl_PointSize \x3d vsize;\r\n}\r\n"},
materials:{checkerBoard:{"checkerBoard.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nuniform vec2 size;\r\nuniform vec4 color1;\r\nuniform vec4 color2;\r\n\r\nvarying vec2 vUV;\r\n\r\nvoid main() {\r\n  vec2 uvScaled \x3d vUV / (2.0 * size);\r\n\r\n  vec2 uv \x3d fract(uvScaled - 0.25);\r\n  vec2 ab \x3d clamp((abs(uv - 0.5) - 0.25) / fwidth(uvScaled), -0.5, 0.5);\r\n  float fade \x3d smoothstep(0.25, 0.5, max(fwidth(uvScaled.x), fwidth(uvScaled.y)));\r\n  float t \x3d mix(abs(ab.x + ab.y), 0.5, fade);\r\n\r\n  gl_FragColor \x3d mix(color2, color1, t);\r\n}\r\n",
"checkerBoard.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform mat4 model;\r\n\r\nattribute vec3 position;\r\nattribute vec2 uv0;\r\n\r\nvarying vec2 vUV;\r\n\r\nvoid main(void) {\r\n  vUV \x3d uv0;\r\n  gl_Position \x3d proj * view * vec4((model * vec4(position, 1.0)).xyz, 1.0);\r\n}\r\n"},color:{"color.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n\r\nuniform vec4 eColor;\r\n#ifdef VERTEX_COLORS\r\nvarying vec4 vColor;\r\n#endif\r\n\r\nvarying vec3 vpos;\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n#ifdef VERTEX_COLORS\r\n  gl_FragColor \x3d vColor * eColor;\r\n#else\r\n  gl_FragColor \x3d eColor;\r\n#endif\r\n\r\n  gl_FragColor \x3d highlightSlice(gl_FragColor, vpos);\r\n}\r\n",
"color.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform mat4 model;\r\n\r\nattribute vec3 position;\r\n#ifdef VERTEX_COLORS\r\nattribute vec4 color;\r\n\r\nvarying vec4 vColor;\r\n#endif\r\n\r\nvarying vec3 vpos;\r\n\r\nvoid main(void) {\r\n#ifdef VERTEX_COLORS\r\n  vColor \x3d color * 0.003921568627451; // \x3d 1/255;\r\n#endif\r\n  vpos \x3d (model * vec4(position, 1.0)).xyz;\r\n\r\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n}\r\n"},
defaultMaterial:{"colorMixMode.glsl":"#include \x3cutil/color.glsl\x3e\r\n\r\n/*\r\n * The color mix modes are encoded in the symbol color as follows:\r\n *  - Fully transparent symbols are represented with alpha 0 for\r\n *    all color mix modes (except ignore).\r\n *  - color mix mode ignore is encoded as multiply with white\r\n *  - the other 3 color mix modes (tint, replace, multiply) are\r\n *    equally distributed on the remaining 255 alpha values, which\r\n *    gives us 85 possible alpha values\r\n *\r\n * alpha             0 : fully transparent\r\n * alpha in [  1 -  85]: tint\r\n * alpha in [ 86 - 170]: replace\r\n * alpha in [171 - 255]: multiply\r\n */\r\nvec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {\r\n  float symbolAlpha \x3d 0.0;\r\n\r\n  const float maxTint \x3d 85.0;\r\n  const float maxReplace \x3d 170.0;\r\n  const float scaleAlpha \x3d 3.0;\r\n\r\n  if (symbolColor.a \x3d\x3d 0.0) {\r\n    colorMixMode \x3d 1; // fully transparent -\x3e multiply\r\n    symbolAlpha \x3d 0.0;\r\n  }\r\n  else if (symbolColor.a \x3c\x3d maxTint) {\r\n    colorMixMode \x3d 0; // tint\r\n    symbolAlpha \x3d scaleAlpha * symbolColor.a;\r\n  }\r\n  else if (symbolColor.a \x3c\x3d maxReplace) {\r\n    colorMixMode \x3d 3; // replace\r\n    symbolAlpha \x3d scaleAlpha * (symbolColor.a - maxTint);\r\n  }\r\n  else {\r\n    colorMixMode \x3d 1;  // multiply\r\n    symbolAlpha \x3d scaleAlpha * (symbolColor.a - maxReplace);\r\n  }\r\n\r\n  return vec4(symbolColor.rgb, symbolAlpha);\r\n}\r\n\r\nvec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {\r\n\r\n  // workaround for artifacts in OSX using Intel Iris Pro\r\n  // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\r\n  vec3 internalMixed \x3d internalColor * textureColor;\r\n  vec3 allMixed \x3d internalMixed * externalColor;\r\n\r\n  if (mode \x3d\x3d 1 /* multiply */) {\r\n    return allMixed;\r\n  }\r\n  else if (mode \x3d\x3d 2 /* ignore */ ) {\r\n    return internalMixed;\r\n  }\r\n  else if (mode \x3d\x3d 3 /* replace */ ) {\r\n    return externalColor;\r\n  }\r\n  else {\r\n    // tint (or something invalid)\r\n    vec3 hsvIn \x3d rgb2hsv(internalMixed);\r\n    vec3 hsvTint \x3d rgb2hsv(externalColor);\r\n    vec3 hsvOut \x3d vec3(hsvTint.x, hsvTint.y, hsvIn.z * hsvTint.z);\r\n    return hsv2rgb(hsvOut);\r\n  }\r\n}\r\n\r\nfloat mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {\r\n\r\n  // workaround for artifacts in OSX using Intel Iris Pro\r\n  // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\r\n  float internalMixed \x3d internalOpacity * textureOpacity;\r\n  float allMixed \x3d internalMixed * externalOpacity;\r\n\r\n  if (mode \x3d\x3d 2 /* ignore */ ) {\r\n    return internalMixed;\r\n  }\r\n  else if (mode \x3d\x3d 3 /* replace */ ) {\r\n    return externalOpacity;\r\n  }\r\n  else {\r\n    // multiply or tint (or something invalid)\r\n    return allMixed;\r\n  }\r\n}\r\n",
"colorPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n#include \x3cutil/sceneLighting.glsl\x3e\r\n\r\n#ifdef TEXTURING\r\n#include \x3cmaterials/defaultMaterial/texturingInputs.glsl\x3e\r\n#endif\r\n\r\nuniform vec3 camPos;\r\nuniform vec3 localOrigin;\r\n\r\n// material parameters\r\n//////////////////////////////////////////\r\nuniform vec3 ambient;\r\nuniform vec3 diffuse;\r\nuniform vec3 specular;\r\nuniform float opacity;\r\nuniform float layerOpacity;\r\n\r\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\r\nvarying mediump float colorMixMode; // varying int is not supported in WebGL\r\n#else\r\nuniform int colorMixMode;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOWS\r\nuniform sampler2D depthTex;\r\nuniform int shadowMapNum;\r\nuniform vec4 shadowMapDistance;\r\nuniform mat4 shadowMapMatrix[4];\r\nuniform float depthHalfPixelSz;\r\n#endif\r\n\r\n#ifdef RECEIVE_SSAO\r\nuniform sampler2D ssaoTex;\r\nuniform vec4 viewportPixelSz;\r\n#endif\r\n\r\nvarying vec3 vpos;\r\nvarying vec3 vnormal;\r\n#if defined(VERTEXCOLORS)\r\nvarying vec4 vcolor;\r\n#endif\r\nvarying vec4 vcolorExt;\r\n\r\n#ifdef RECEIVE_SHADOWS\r\nvarying float linearDepth;\r\n#include \x3cutil/shadow.glsl\x3e\r\n#endif\r\n\r\n#ifdef TREE_RENDERING\r\n  uniform mat4 view;\r\n#endif\r\n\r\n#ifdef TEXTURING\r\n#include \x3cmaterials/defaultMaterial/texturing.glsl\x3e\r\n#endif\r\n\r\n#include \x3cmaterials/defaultMaterial/colorMixMode.glsl\x3e\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n#ifdef TEXTURING\r\n  vec4 texColor \x3d textureLookup(tex, vtc);\r\n\r\n#ifdef TEXTURE_ALPHA_TEST\r\n  if (texColor.a * coverageCorrectionFactor(vtc) \x3c textureAlphaCutoff) {\r\n    discard;\r\n  }\r\n#endif\r\n#else /* TEXTURING */\r\n  vec4 texColor \x3d vec4(1.0);\r\n#endif /* TEXTURING */\r\n\r\n  vec3 viewDir \x3d vpos - camPos;\r\n\r\n  // compute normal\r\n  // TODO: this is not in sync with the normal pass\r\n#ifdef GROUND_NORMAL_SHADING\r\n#ifdef VIEWING_MODE_GLOBAL\r\n  vec3 normal \x3d normalize(vpos + localOrigin);\r\n#else\r\n  vec3 normal \x3d vec3(0.0, 0.0, 1.0);\r\n#endif\r\n#else\r\n#ifdef DOUBLESIDED\r\n  vec3 normal \x3d dot(vnormal, viewDir)\x3e0.0 ? -vnormal : vnormal;\r\n#elif defined(WINDINGORDERDOUBLESIDED)\r\n  vec3 normal \x3d gl_FrontFacing ? vnormal : -vnormal;\r\n#else\r\n  vec3 normal \x3d vnormal;\r\n#endif\r\n  normal \x3d normalize(normal);\r\n#endif\r\n\r\n  // compute ssao\r\n#ifdef RECEIVE_SSAO\r\n  float ssao \x3d texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\r\n  ssao \x3d viewportPixelSz.z \x3c 0.0 ? 1.0 : ssao;\r\n#else\r\n  float ssao \x3d 1.0;\r\n#endif\r\n\r\n  // At global scale we create some additional ambient light based on the main light to simulate global illumination\r\n  float additionalAmbientScale;\r\n  vec3 additionalLight \x3d sceneLightingAdditionalLightGlobal(vpos + localOrigin, ssao, additionalAmbientScale);\r\n\r\n  // compute shadowing\r\n  float shadow \x3d 0.0;\r\n#ifdef RECEIVE_SHADOWS\r\n  shadow \x3d evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\r\n#elif defined(VIEWING_MODE_GLOBAL)\r\n  // at global scale (and in global scenes) we fall back to this approximation\r\n  // to shadow objects on the dark side of the earth\r\n  shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\r\n#endif\r\n\r\n  vec3 matColor \x3d max(ambient, diffuse); // combine the old material parameters into a single one\r\n#if defined(VERTEXCOLORS)\r\n  // Internal colors: varying vcolor + uniform ambient/diffuse, external colors: varying vcolorExt\r\n  vec3 albedo_ \x3d mixExternalColor(vcolor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\r\n  float opacity_ \x3d layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\r\n#else\r\n  // Internal colors: uniform ambient/diffuse, external colors: varying vcolorExt\r\n  vec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\r\n  float opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\r\n#endif\r\n  albedo_+\x3d 0.25 * specular; // don't completely ignore specular for now\r\n\r\n  vec3 shadingNormal \x3d normal;\r\n\r\n  #ifdef TREE_RENDERING\r\n    // make sure we use unflipped normal\r\n    shadingNormal \x3d normalize(vnormal);\r\n\r\n    // make tree 20% brighter\r\n    albedo_ *\x3d 1.2;\r\n\r\n    // view forward vector in global coordinates\r\n    vec3 viewForward \x3d - vec3(view[0][2], view[1][2], view[2][2]);\r\n\r\n    // factor indicating how aligned the lighting direction and view axis are\r\n    float alignmentLightView \x3d clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\r\n\r\n    // we approximate the tree crown transmittance based on view direction and tree crown normal\r\n    float transmittance \x3d 1.0 - clamp(dot(-viewForward, shadingNormal), 0.0, 1.0);\r\n\r\n    float treeRadialFalloff \x3d vcolor.r;\r\n    float backLightFactor \x3d 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\r\n    additionalLight +\x3d backLightFactor * lightingMainIntensity;\r\n  #endif\r\n\r\n  vec3 shadedColor \x3d evaluateSceneLighting(shadingNormal, albedo_, shadow, 1.0 - ssao, additionalLight);\r\n  gl_FragColor \x3d highlightSlice(vec4(shadedColor, opacity_), vpos);\r\n}\r\n",
"colorPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\n#include \x3cmaterials/defaultMaterial/commonInputs.glsl\x3e\r\n\r\n#ifdef INSTANCEDCOLOR\r\nattribute vec4 instanceColor;\r\n#endif\r\nattribute vec3 position;\r\n#ifdef COMPRESSED_NORMALS\r\nattribute vec2 normalCompressed;\r\n#else\r\nattribute vec3 normal;\r\n#endif\r\nvarying vec3 vpos;\r\nvarying vec3 vnormal;\r\n\r\n#ifdef TEXTURING\r\nattribute vec2 uv0;\r\nvarying vec2 vtc;\r\n#ifdef TEXTURE_ATLAS\r\nattribute vec4 region;\r\nvarying vec4 regionV;\r\n#endif\r\n#endif\r\n\r\n#ifdef COMPONENTCOLORS\r\nuniform sampler2D uComponentColorTex;\r\nuniform vec2 uComponentColorTexInvDim;\r\n\r\nattribute float componentIndex;\r\n\r\nvec4 readComponentColor() {\r\n  float normalizedIndex \x3d (componentIndex + 0.5) * uComponentColorTexInvDim.x;\r\n  vec2 indexCoord \x3d vec2(\r\n    mod(normalizedIndex, 1.0),\r\n    (floor(normalizedIndex) + 0.5) * uComponentColorTexInvDim.y\r\n  );\r\n  return texture2D(uComponentColorTex, indexCoord);\r\n}\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOWS\r\nvarying float linearDepth;\r\n#endif\r\n\r\n#ifdef VERTEXCOLORS\r\nattribute vec4 color;\r\n#endif\r\n\r\n#ifdef SYMBOLVERTEXCOLORS\r\nattribute vec4 symbolColor;\r\n#endif\r\n\r\n#if defined(VERTEXCOLORS)\r\nvarying vec4 vcolor;\r\n#endif\r\n\r\n// Workaround for https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/13452\r\n// We pass the externalColor uniform from VS to FS through the vcolorExt varying because\r\n// there is a driver bug for Intel Integrated Graphics which led to rendering artifacts\r\n// since the introduction of https://devtopia.esri.com/WebGIS/arcgis-js-api/pull/12673\r\n// This should be further cleaned up later with through the following issue:\r\n// https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/12763\r\nuniform vec4 externalColor;\r\nvarying vec4 vcolorExt;\r\n\r\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\r\nvarying mediump float colorMixMode; // varying int is not supported in WebGL\r\n#endif\r\n\r\n#include \x3cutil/visualVariables.glsl\x3e\r\n\r\n#if defined(VV_SIZE) || defined(VV_COLOR)\r\nattribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\r\n#include \x3cmaterials/defaultMaterial/colorMixMode.glsl\x3e\r\n#include \x3cmaterials/defaultMaterial/commonFunctions.glsl\x3e\r\n#include \x3cmaterials/defaultMaterial/constants.glsl\x3e\r\n#include \x3cmaterials/defaultMaterial/localCenter.glsl\x3e\r\n#include \x3cmaterials/defaultMaterial/localNormal.glsl\x3e\r\n\r\nvoid main() {\r\n\r\n#ifdef VERTEXCOLORS\r\n  vcolor \x3d color * 0.003921568627451; // \x3d 1/255\r\n#endif\r\n\r\n  vcolorExt \x3d externalColor;\r\n\r\n#ifdef INSTANCEDCOLOR\r\n  vcolorExt *\x3d instanceColor;\r\n#endif\r\n\r\n#ifdef VV_COLOR\r\n  vcolorExt *\x3d vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);\r\n#endif\r\n\r\n#ifdef SYMBOLVERTEXCOLORS\r\n  int symbolColorMixMode;\r\n  vcolorExt *\x3d decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\r\n  colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\r\n#endif\r\n\r\n#ifdef COMPONENTCOLORS\r\n  int symbolColorMixMode;\r\n  vcolorExt *\x3d decodeSymbolColor(readComponentColor() * 255.0, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\r\n  colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\r\n#endif\r\n\r\n  if (vcolorExt.a \x3c SYMBOL_ALPHA_CUTOFF) {\r\n    // Discard this vertex\r\n    gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\r\n  }\r\n  else {\r\n    vpos \x3d calculateVPos();\r\n\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\n  vnormal \x3d normalize(modelNormal * localNormal().xyz);\r\n\r\n  vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\r\n  #ifdef IOS_SAFARI_FIX\r\n    originDelta \x3d originDelta - fract(originDelta * 1000000.0) * (1.0 / 1000000.0);\r\n  #endif\r\n  vpos -\x3d originDelta;\r\n\r\n  #ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d model * localCenter().xyz + originDelta;\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n  #endif\r\n#else /* INSTANCED_DOUBLE_PRECISION */\r\n  vnormal \x3d normalize((modelNormal * localNormal()).xyz);\r\n  #ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * localCenter()).xyz;\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n  #endif\r\n#endif /* INSTANCED_DOUBLE_PRECISION */\r\n\r\n    gl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n  }\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n  // Shadowmap's cascading index used to be based on '1.0 / gl_FragCoord.w'\r\n  // (i.e. the perspective interpolation of 'gl_Position.w'). Precision\r\n  // issues on iPad/iPhone with the 'w' component require the depth to be\r\n  // passed as varying to properly drive the cascading shadow map index.\r\n  linearDepth \x3d gl_Position.w;\r\n#endif\r\n\r\n\r\n#ifdef TEXTURING\r\n  #ifndef FLIPV\r\n    vtc \x3d uv0;\r\n  #else\r\n    vtc \x3d vec2(uv0.x, 1.0-uv0.y);\r\n  #endif\r\n  #ifdef TEXTURE_ATLAS\r\n    regionV \x3d region;\r\n  #endif\r\n#endif /* TEXTURING */\r\n\r\n}\r\n",
"commonFunctions.glsl":"#include \x3cmaterials/defaultMaterial/localPosition.glsl\x3e\r\n#include \x3cutil/doublePrecision.glsl\x3e\r\n\r\nvec3 calculateVPos() {\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\n  return model * localPosition().xyz;\r\n#else\r\n  return (model * localPosition()).xyz;\r\n#endif\r\n}\r\n\r\n#ifdef VERTICAL_OFFSET\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n#include \x3cutil/screenSizePerspective.glsl\x3e\r\n#endif\r\n\r\nvec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\r\n  float viewDistance \x3d length((view * vec4(worldPos, 1.0)).xyz);\r\n  float verticalOffsetOffsetDistance \x3d verticalOffset.x * viewDistance;\r\n\r\n#ifdef VIEWING_MODE_GLOBAL\r\n  vec3 worldNormal \x3d normalize(worldPos + localOrigin);\r\n#else\r\n  vec3 worldNormal \x3d vec3(0.0, 0.0, 1.0);\r\n#endif\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n  float cosAngle \x3d dot(worldNormal, normalize(worldPos - camPos));\r\n\r\n  float verticalOffsetScreenHeight \x3d screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);\r\n#else\r\n  float verticalOffsetScreenHeight \x3d verticalOffset.x;\r\n#endif\r\n\r\n  // Screen sized offset in world space, used for example for line callouts\r\n  float worldOffset \x3d clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\r\n\r\n  return worldNormal * worldOffset;\r\n}\r\n#endif\r\n",
"commonInputs.glsl":"uniform mat4 proj;\r\nuniform mat4 view;\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\nuniform vec3 viewOriginHi;\r\nuniform vec3 viewOriginLo;\r\n#endif\r\nuniform vec3 camPos;\r\nuniform vec3 localOrigin;\r\n\r\n#ifdef INSTANCED\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\nattribute vec3 modelOriginHi;\r\nattribute vec3 modelOriginLo;\r\nattribute mat3 model;\r\nattribute mat3 modelNormal;\r\n#else /* INSTANCED_DOUBLE_PRECISION */\r\nattribute mat4 model;\r\nattribute mat4 modelNormal;\r\n#endif /* INSTANCED_DOUBLE_PRECISION */\r\n#else /* INSTANCED */\r\nuniform mat4 model;\r\nuniform mat4 modelNormal;\r\n#endif /* INSTANCED */\r\n\r\n#ifdef VERTICAL_OFFSET\r\n// [ verticalOffsetPerDistance, minWorldLength, maxWorldLength ]\r\nuniform vec4 verticalOffset;\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\nuniform vec4 screenSizePerspectiveAlignment;\r\n#endif\r\n#endif\r\n",
"constants.glsl":"#define SYMBOL_ALPHA_CUTOFF 0.001\r\n","depthPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/encoding.glsl\x3e\r\n#include \x3cutil/depth.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n\r\nvarying float depth;\r\nvarying vec3 vpos;\r\n\r\n#ifdef TEXTURING\r\n#include \x3cmaterials/defaultMaterial/texturingInputs.glsl\x3e\r\n#include \x3cmaterials/defaultMaterial/texturing.glsl\x3e\r\n#endif\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n#if defined(TEXTURING) \x26\x26 defined(TEXTURE_ALPHA_TEST)\r\n  if (textureLookup(tex, vtc).a * coverageCorrectionFactor(vtc) \x3c textureAlphaCutoff) {\r\n    discard;\r\n  }\r\n#endif\r\n\r\n#ifndef BIAS_SHADOWMAP\r\n  gl_FragColor \x3d float2rgba(depth);\r\n#else\r\n  gl_FragColor \x3d float2rgba(calcFragDepth(depth));\r\n#endif\r\n}\r\n",
"depthPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\n#include \x3cmaterials/defaultMaterial/commonInputs.glsl\x3e\r\n\r\nuniform vec2 nearFar;\r\nattribute vec3 position;\r\n\r\nvarying float depth;\r\nvarying vec3 vpos;\r\n\r\n#ifdef TEXTURING\r\nattribute vec2 uv0;\r\nvarying vec2 vtc;\r\n#ifdef TEXTURE_ATLAS\r\nattribute vec4 region;\r\nvarying vec4 regionV;\r\n#endif\r\n#endif\r\n\r\n#include \x3cutil/visualVariables.glsl\x3e\r\n\r\n#if defined(VV_CUSTOM_MODEL_MATRIX)\r\nattribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\r\n#include \x3cmaterials/defaultMaterial/commonFunctions.glsl\x3e\r\n#include \x3cmaterials/defaultMaterial/localCenter.glsl\x3e\r\n\r\nvoid main(void) {\r\n  vpos \x3d calculateVPos();\r\n\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\n  vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\r\n#ifdef IOS_SAFARI_FIX\r\n  originDelta \x3d originDelta - fract(originDelta * 1000000.0) * (1.0 / 1000000.0);\r\n#endif\r\n  vpos -\x3d originDelta;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n  vec3 centerPos \x3d model * localCenter().xyz + originDelta;\r\n  vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#else /* INSTANCED_DOUBLE_PRECISION */\r\n#ifdef VERTICAL_OFFSET\r\n  vec3 centerPos \x3d (model * localCenter()).xyz;\r\n  vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#endif /* INSTANCED_DOUBLE_PRECISION */\r\n\r\n  vec4 eye \x3d view * vec4(vpos, 1.0);\r\n\r\n  gl_Position \x3d proj * eye;\r\n  depth \x3d (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\r\n\r\n#ifdef TEXTURING\r\n#ifndef FLIPV\r\n  vtc \x3d uv0;\r\n#else\r\n  vtc \x3d vec2(uv0.x, 1.0-uv0.y);\r\n#endif\r\n#ifdef TEXTURE_ATLAS\r\n  regionV \x3d region;\r\n#endif\r\n#endif /* TEXTURING */\r\n\r\n}\r\n",
"highlightPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n#include \x3cutil/highlight.glsl\x3e\r\n\r\nvarying vec3 vpos;\r\n\r\nuniform sampler2D depthTex;\r\nuniform vec4 highlightViewportPixelSz;\r\n\r\n#ifdef TEXTURING\r\n#include \x3cmaterials/defaultMaterial/texturingInputs.glsl\x3e\r\n#include \x3cmaterials/defaultMaterial/texturing.glsl\x3e\r\n#endif\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n#if defined(TEXTURING) \x26\x26 defined(TEXTURE_ALPHA_TEST)\r\n  if (textureLookup(tex, vtc).a * coverageCorrectionFactor(vtc) \x3c textureAlphaCutoff) {\r\n    discard;\r\n  }\r\n#endif\r\n\r\n  gl_FragColor \x3d highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\r\n}\r\n",
"highlightPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\n#include \x3cmaterials/defaultMaterial/commonInputs.glsl\x3e\r\n\r\nattribute vec3 position;\r\n\r\nvarying vec3 vpos;\r\n\r\n#ifdef TEXTURING\r\nattribute vec2 uv0;\r\nvarying vec2 vtc;\r\n#ifdef TEXTURE_ATLAS\r\nattribute vec4 region;\r\nvarying vec4 regionV;\r\n#endif\r\n#endif\r\n\r\n#include \x3cutil/visualVariables.glsl\x3e\r\n\r\n#if defined(VV_CUSTOM_MODEL_MATRIX)\r\nattribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\r\n#include \x3cmaterials/defaultMaterial/commonFunctions.glsl\x3e\r\n#include \x3cmaterials/defaultMaterial/localCenter.glsl\x3e\r\n\r\nvoid main(void) {\r\n  vpos \x3d calculateVPos();\r\n\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\n  vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\r\n#ifdef IOS_SAFARI_FIX\r\n  originDelta \x3d originDelta - fract(originDelta * 1000000.0) * (1.0 / 1000000.0);\r\n#endif\r\n  vpos -\x3d originDelta;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n  vec3 centerPos \x3d model * localCenter().xyz + originDelta;\r\n  vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#else /* INSTANCED_DOUBLE_PRECISION */\r\n#ifdef VERTICAL_OFFSET\r\n  vec3 centerPos \x3d (model * localCenter()).xyz;\r\n  vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#endif /* INSTANCED_DOUBLE_PRECISION */\r\n\r\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n\r\n#ifdef TEXTURING\r\n#ifndef FLIPV\r\n  vtc \x3d uv0;\r\n#else\r\n  vtc \x3d vec2(uv0.x, 1.0-uv0.y);\r\n#endif\r\n#ifdef TEXTURE_ATLAS\r\n  regionV \x3d region;\r\n#endif\r\n#endif /* TEXTURING */\r\n\r\n}\r\n",
"localCenter.glsl":"#ifdef VV_CUSTOM_MODEL_MATRIX\r\n# ifdef VERTICAL_OFFSET\r\nvec4 localCenter() { return vvTransformPosition(vec3(0.0), instanceFeatureAttribute); }\r\n# endif\r\n#else\r\n# ifdef VERTICAL_OFFSET\r\nvec4 localCenter() { return vec4(vec3(0.0), 1.0); }\r\n# endif\r\n#endif\r\n","localNormal.glsl":"#include \x3cutil/normalEncoding.glsl\x3e\r\n\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n# ifdef COMPRESSED_NORMALS\r\nvec4 localNormal() { return vvTransformNormal(decodeNormal(normalCompressed), instanceFeatureAttribute); }\r\n# else\r\nvec4 localNormal() { return vvTransformNormal(normal, instanceFeatureAttribute); }\r\n# endif\r\n#else\r\n# ifdef COMPRESSED_NORMALS\r\nvec4 localNormal() { return vec4(decodeNormal(normalCompressed), 1.0); }\r\n# else\r\nvec4 localNormal() { return vec4(normal, 1.0); }\r\n# endif\r\n#endif\r\n",
"localPosition.glsl":"#ifdef VV_CUSTOM_MODEL_MATRIX\r\nvec4 localPosition() { return vvTransformPosition(position, instanceFeatureAttribute); }\r\n#else\r\nvec4 localPosition() { return vec4(position, 1.0); }\r\n#endif\r\n","normalPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n\r\nvarying vec3 vnormal;\r\nvarying vec3 vpos;\r\n\r\n#ifdef TEXTURING\r\n#include \x3cmaterials/defaultMaterial/texturingInputs.glsl\x3e\r\n#include \x3cmaterials/defaultMaterial/texturing.glsl\x3e\r\n#endif\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n#if defined(TEXTURING) \x26\x26 defined(TEXTURE_ALPHA_TEST)\r\n  if (textureLookup(tex, vtc).a * coverageCorrectionFactor(vtc) \x3c textureAlphaCutoff) {\r\n    discard;\r\n  }\r\n#endif\r\n\r\n  vec3 normal \x3d normalize(vnormal);\r\n  if (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\r\n\r\n#ifndef ALPHA_ZERO\r\n  gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\r\n#else\r\n  gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\r\n#endif\r\n}\r\n",
"normalPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\n#include \x3cmaterials/defaultMaterial/commonInputs.glsl\x3e\r\n\r\nuniform mat4 viewNormal;\r\nattribute vec3 position;\r\n#ifdef COMPRESSED_NORMALS\r\nattribute vec2 normalCompressed;\r\n#else\r\nattribute vec3 normal;\r\n#endif\r\n\r\n#ifdef TEXTURING\r\nattribute vec2 uv0;\r\nvarying vec2 vtc;\r\n#ifdef TEXTURE_ATLAS\r\nattribute vec4 region;\r\nvarying vec4 regionV;\r\n#endif\r\n#endif\r\n\r\nvarying vec3 vnormal;\r\nvarying vec3 vpos;\r\n\r\n#include \x3cutil/visualVariables.glsl\x3e\r\n\r\n#if defined(VV_CUSTOM_MODEL_MATRIX)\r\nattribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\r\n#include \x3cmaterials/defaultMaterial/commonFunctions.glsl\x3e\r\n#include \x3cmaterials/defaultMaterial/localCenter.glsl\x3e\r\n#include \x3cmaterials/defaultMaterial/localNormal.glsl\x3e\r\n\r\nvoid main(void) {\r\n  vpos \x3d calculateVPos();\r\n\r\n#ifdef INSTANCED_DOUBLE_PRECISION\r\n  vnormal \x3d normalize((viewNormal * vec4(modelNormal * localNormal().xyz, 1.0)).xyz);\r\n\r\n  vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\r\n#ifdef IOS_SAFARI_FIX\r\n  originDelta \x3d originDelta - fract(originDelta * 1000000.0) * (1.0 / 1000000.0);\r\n#endif\r\n  vpos -\x3d originDelta;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n  vec3 centerPos \x3d model * localCenter().xyz + originDelta;\r\n  vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#else /* INSTANCED_DOUBLE_PRECISION */\r\n  vnormal \x3d normalize((viewNormal * modelNormal * localNormal()).xyz);\r\n\r\n#ifdef VERTICAL_OFFSET\r\n  vec3 centerPos \x3d (model * localCenter()).xyz;\r\n  vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n#endif /* INSTANCED_DOUBLE_PRECISION */\r\n\r\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n\r\n#ifdef TEXTURING\r\n#ifndef FLIPV\r\n  vtc \x3d uv0;\r\n#else\r\n  vtc \x3d vec2(uv0.x, 1.0-uv0.y);\r\n#endif\r\n#ifdef TEXTURE_ATLAS\r\n  regionV \x3d region;\r\n#endif\r\n#endif /* TEXTURING */\r\n\r\n}\r\n",
"texturing.glsl":"float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\r\n  // from:\r\n  //   - OpenGLES Common Profile Specification Version 2.0.25, Section 3.7.7 - Texture Minification\r\n  //   - https://www.opengl.org/discussion_boards/showthread.php/171485-Texture-LOD-calculation-(useful-for-atlasing)\r\n  //   - http://www.linedef.com/virtual-texture-demo.html\r\n  float deltaMaxSqr \x3d max(dot(ddx, ddx), dot(ddy, ddy));\r\n  return max(0.0, 0.5 * log2(deltaMaxSqr));\r\n}\r\n\r\n// based on https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f\r\nfloat coverageCorrectionFactor(vec2 uv) {\r\n#ifdef ALPHA_COVERAGE_CORRECTION\r\n  const float MipScale \x3d 0.25;\r\n  uv *\x3d texSize;\r\n#ifdef TEXTURE_ATLAS\r\n  uv *\x3d region.zw - region.xy;\r\n#endif\r\n  return 1.0 + max(0.0, calcMipMapLevel(dFdx(uv), dFdy(uv))) * MipScale;\r\n#else\r\n  return 1.0;\r\n#endif\r\n}\r\n\r\nvec4 textureAtlasLookup(sampler2D tex, vec2 uv, vec4 region, vec2 texSize) {\r\n  //[umin, vmin, umax, vmax]\r\n  vec2 atlasScale \x3d region.zw - region.xy;\r\n  vec2 uvAtlas \x3d fract(uv) * atlasScale + region.xy;\r\n\r\n  vec4 texColor;\r\n\r\n  // calculate derivative of continuous texture coordinate\r\n  // to avoid mipmapping artifacts caused by manual wrapping in shader\r\n  vec2 dUVdx \x3d dFdx(uv) * atlasScale;\r\n  vec2 dUVdy \x3d dFdy(uv) * atlasScale;\r\n\r\n#ifdef GL_EXT_shader_texture_lod\r\n  return texture2DGradEXT(tex, uvAtlas, dUVdx, dUVdy);\r\n#else\r\n  // use bias to compensate for difference in automatic vs desired mipmap level\r\n  vec2 dUVdxAuto \x3d dFdx(uvAtlas);\r\n  vec2 dUVdyAuto \x3d dFdy(uvAtlas);\r\n  float mipMapLevel \x3d calcMipMapLevel(dUVdx * texSize, dUVdy * texSize);\r\n  float autoMipMapLevel \x3d calcMipMapLevel(dUVdxAuto * texSize, dUVdyAuto * texSize);\r\n\r\n  return texture2D(tex, uvAtlas, mipMapLevel - autoMipMapLevel);\r\n#endif\r\n}\r\n\r\nvec4 textureLookup(sampler2D tex, vec2 uv) {\r\n#ifdef TEXTURE_ATLAS\r\n  return textureAtlasLookup(tex, uv, regionV, texSize);\r\n#else\r\n  return texture2D(tex, uv);\r\n#endif\r\n}\r\n\r\n",
"texturingInputs.glsl":"#ifdef TEXTURING\r\nuniform sampler2D tex;\r\nuniform vec2 texSize;\r\n\r\n#ifdef TEXTURE_ALPHA_TEST\r\nuniform float textureAlphaCutoff;\r\n#endif\r\n\r\nvarying vec2 vtc;\r\n\r\n#ifdef TEXTURE_ATLAS\r\nvarying vec4 regionV;\r\n#endif\r\n\r\n#endif\r\n"},hud:{"colorPass.frag":"#include \x3cmaterials/hud/hudHeader.glsl\x3e\r\n\r\nvoid main() {\r\n#include \x3cmaterials/hud/hudMain.glsl\x3e\r\n}\r\n","highlightPass.frag":"#include \x3cmaterials/hud/hudHeader.glsl\x3e\r\n#include \x3cutil/highlight.glsl\x3e\r\n\r\nuniform sampler2D depthTex;\r\nuniform vec4 highlightViewportPixelSz;\r\n\r\nvoid main() {\r\n#include \x3cmaterials/hud/hudMain.glsl\x3e\r\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\r\n  // Instead of deciding on a per-pixel basis if the highlight is occluded,\r\n  // do it for all highlight pixel based on the centroid occlusion. This\r\n  // is a temporary solution for:\r\n  // https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/9645\r\n  if (voccluded \x3d\x3d 1.0) {\r\n    gl_FragColor \x3d vec4(1.0, 1.0, 0.0, 1.0);\r\n  } else {\r\n    gl_FragColor \x3d vec4(1.0, 0.0, 1.0, 1.0);\r\n  }\r\n#else\r\n  gl_FragColor \x3d highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\r\n#endif\r\n}\r\n",
"hud.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n#include \x3cutil/alignPixel.glsl\x3e\r\n#include \x3cutil/hud.glsl\x3e\r\n#include \x3cutil/visualVariables.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n\r\nuniform vec2 screenOffset;\r\nuniform vec2 anchorPos;\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\nuniform vec4 screenSizePerspective;\r\n#endif\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\nvarying vec3 debugBorderCoords;\r\n#endif\r\n\r\nattribute vec2 uv0;\r\nattribute vec4 color;\r\nattribute vec2 size;\r\nattribute vec4 auxpos2;\r\n\r\nvarying vec4 vcolor;\r\n\r\nvarying vec2 vtc;\r\nvarying vec2 vsize;\r\n\r\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\r\nvarying float voccluded;\r\n#endif\r\n\r\nvoid main(void) {\r\n  ProjectHUDAux projectAux;\r\n  vec4 posProj \x3d projectPositionHUD(projectAux);\r\n\r\n  if (rejectBySlice(projectAux.posModel)) {\r\n    // Project outside of clip plane\r\n    gl_Position \x3d vec4(1e038, 1e038, 1e038, 1.0);\r\n    return;\r\n  }\r\n\r\n  vec2 inputSize;\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n\r\n  inputSize \x3d screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\r\n\r\n  vec2 screenOffsetScaled \x3d screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\r\n\r\n#else\r\n\r\n  inputSize \x3d size;\r\n\r\n  vec2 screenOffsetScaled \x3d screenOffset;\r\n#endif\r\n\r\n#ifdef VV_SIZE\r\n  // only use width (.xx) for proportional scaling\r\n  // (if no width was defined in vv, width\r\n  //  will be a copy of height vv)\r\n  inputSize *\x3d vvGetScale(auxpos2).xx;\r\n#endif\r\n\r\n  vec2 combinedSize \x3d inputSize * pixelRatio;\r\n  vec4 quadOffset \x3d vec4(0.0);\r\n\r\n#if defined(OCCL_TEST) || defined(BINARY_HIGHLIGHT_OCCLUSION)\r\n  bool visible \x3d testVisibilityHUD(posProj);\r\n#endif\r\n\r\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\r\nvoccluded \x3d visible ? 0.0 : 1.0;\r\n#endif\r\n\r\n#ifdef OCCL_TEST\r\n  if (visible) {\r\n#endif\r\n    // UV goes from 0 to 1.99999, where the integer part is used\r\n    // for the normalized vertex coordinates, and the fractional\r\n    // part is used for texture sampling\r\n    vec2 uv01 \x3d floor(uv0);\r\n    vec2 uv \x3d uv0 - uv01;\r\n\r\n    // Displace icon based on anchor position (normalized for size) and\r\n    // absolute screen offset. anchorPos is [-0.5, 0.5]\r\n    quadOffset.xy \x3d ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;\r\n\r\n#ifdef SIGNED_DISTANCE_FIELD\r\n\r\n    // SDF primitives might be scaled so that the SDF texture resolution does\r\n    // not match the resolution of the canvas, but we still want to render\r\n    // outline-only ('cross' and 'x') primitives cleanly. Aligning to a screen\r\n    // pixel border at the geometry center achieves this, since SDF textures\r\n    // always have power of 2 dimensions.\r\n    posProj \x3d alignToPixelOrigin(posProj, viewport.zw) + quadOffset;\r\n#else\r\n    posProj +\x3d quadOffset;\r\n\r\n    // Aligning vertex positions to the nearest (using 'floor') screen pixel\r\n    // border renders textures with pixel-perfect results. If the texture\r\n    // resolution does not match the canvas resolution then aligning is\r\n    // redundant.\r\n    if (inputSize.x \x3d\x3d size.x) {\r\n      posProj \x3d alignToPixelOrigin(posProj, viewport.zw);\r\n    }\r\n#endif\r\n\r\n    gl_Position \x3d posProj;\r\n\r\n    vtc \x3d uv;\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n    debugBorderCoords \x3d vec3(uv01, 1.0 / combinedSize);\r\n#endif\r\n\r\n    vsize \x3d inputSize;\r\n#ifdef OCCL_TEST\r\n  } else {\r\n    vtc \x3d vec2(.0);\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n    debugBorderCoords \x3d vec3(0.0);\r\n#endif\r\n\r\n  }\r\n#endif\r\n\r\n  gl_Position \x3d posProj;\r\n\r\n#ifdef VV_COLOR\r\n  vcolor \x3d vvGetColor(auxpos2, vvColorValues, vvColorColors);\r\n#else\r\n  vcolor \x3d color / 255.0;\r\n#endif\r\n}\r\n",
"hudHeader.glsl":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/encoding.glsl\x3e\r\n#include \x3cutil/color.glsl\x3e\r\n\r\nuniform sampler2D tex;\r\nuniform vec4 overrideColor;\r\nuniform vec4 outlineColor;\r\nuniform float outlineSize;\r\n\r\nvarying vec4 vcolor;\r\n\r\nvarying vec2 vtc;\r\nvarying vec2 vsize;\r\n\r\n#ifdef BINARY_HIGHLIGHT_OCCLUSION\r\nvarying float voccluded;\r\n#endif\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\nvarying vec3 debugBorderCoords;\r\n#endif\r\n",
"hudMain.glsl":"#ifdef SIGNED_DISTANCE_FIELD\r\n  vec4 color \x3d vec4(0.0, 0.0, 0.0, 0.0);\r\n  vec4 fillPixelColor \x3d overrideColor * vcolor;\r\n\r\n  // Attempt to sample texel centers to avoid that thin cross outlines\r\n  // disappear with large symbol sizes.\r\n  // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041\r\n  const float txSize \x3d 128.0;\r\n  const float texelSize \x3d 1.0 / txSize;\r\n  // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel\r\n  vec2 scaleFactor \x3d (vsize - txSize) * texelSize;\r\n  vec2 samplePos \x3d vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;\r\n\r\n  // Get distance and map it into [-0.5, 0.5]\r\n  float d \x3d rgba2float(texture2D(tex, samplePos)) - 0.5;\r\n\r\n  // Distance in output units (i.e. pixels)\r\n  float dist \x3d d * vsize.x;\r\n\r\n  // Create smooth transition from the icon into its outline\r\n  fillPixelColor.a *\x3d clamp(0.5 - dist, 0.0, 1.0);\r\n\r\n  if (outlineSize \x3e 0.25) {\r\n    vec4 outlinePixelColor \x3d outlineColor;\r\n    float clampedOutlineSize \x3d min(outlineSize, 0.5*vsize.x);\r\n\r\n    // Create smooth transition around outline\r\n    outlinePixelColor.a *\x3d clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\r\n\r\n    // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\r\n    float compositeAlpha \x3d outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n    vec3 compositeColor \x3d vec3(outlinePixelColor) * outlinePixelColor.a +\r\n      vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\r\n    gl_FragColor \x3d vec4(compositeColor, compositeAlpha);\r\n  }\r\n  else {\r\n    gl_FragColor \x3d premultiplyAlpha(fillPixelColor);\r\n  }\r\n\r\n  // visualize SDF:\r\n  // gl_FragColor \x3d vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\r\n#else\r\n\r\n  // HUDMaterial is rendered with a blending mode that assumes a pre-multiplied\r\n  // fragment color. Input textures should already be pre-multiplied and so\r\n  // don't require adjustment, but the override and vertex colors must be\r\n  // modulated by their alpha values.\r\n\r\n  gl_FragColor \x3d texture2D(tex, vtc, -0.5) * premultiplyAlpha(overrideColor * vcolor);\r\n\r\n#endif\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n   float isBorder \x3d float(any(lessThan(debugBorderCoords.xy, vec2(debugBorderCoords.z))) || any(greaterThan(debugBorderCoords.xy, vec2(1.0 - debugBorderCoords.z))));\r\n   gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder);\r\n#endif\r\n\r\n  if (gl_FragColor.a \x3c 0.1) {\r\n    discard;\r\n  }\r\n",
"occlusionTest.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nuniform vec4 color;\r\n\r\nvoid main() {\r\n  gl_FragColor \x3d color;\r\n}\r\n","occlusionTest.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n#include \x3cutil/alignPixel.glsl\x3e\r\n#include \x3cutil/hud.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n\r\nvoid main(void) {\r\n  vec4 posProjCenter;\r\n\r\n  // Check for special value of position (0, 0, 0) which is used by the Renderer when graphics\r\n  // are removed before the VBO is recompacted. If this is the case, then we just project outside\r\n  // of clip space.\r\n  if (dot(position, position) \x3e 0.0) {\r\n    // Render single point to center of the pixel to avoid subpixel filtering to affect\r\n    // the marker color\r\n    ProjectHUDAux projectAux;\r\n    vec4 posProj \x3d projectPositionHUD(projectAux);\r\n    posProjCenter \x3d alignToPixelCenter(posProj, viewport.zw);\r\n\r\n    vec3 vpos \x3d projectAux.posModel;\r\n    if (rejectBySlice(vpos)) {\r\n      // Project out of clip space\r\n      posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\r\n    }\r\n  }\r\n  else {\r\n    // Project out of clip space\r\n    posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\r\n  }\r\n\r\n  gl_Position \x3d posProjCenter;\r\n  gl_PointSize \x3d 1.0;\r\n}\r\n"},
lineCallout:{"lineCallout.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nuniform vec4 color;\r\nuniform vec4 borderColor;\r\n\r\nvarying vec4 coverageSampling;\r\nvarying vec2 lineSizes;\r\n\r\nvoid main() {\r\n  // Mix between line and border coverage offsets depending on whether we need\r\n  // a border (based on the sidedness).\r\n  vec2 coverage \x3d min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\r\n\r\n  // Mix between border and line color based on the line coverage (conceptually the line\r\n  // blends on top of the border background).\r\n  //\r\n  // Anti-alias by blending final result using the full (including optional border) coverage\r\n  // and the color alpha\r\n  float borderAlpha \x3d color.a * borderColor.a * coverage.y;\r\n  float colorAlpha \x3d color.a * coverage.x;\r\n\r\n  float finalAlpha \x3d mix(borderAlpha, 1.0, colorAlpha);\r\n\r\n#ifdef DEPTH_HUD\r\n\r\n  if (finalAlpha \x3c 0.01) {\r\n    discard;\r\n  }\r\n\r\n#else\r\n\r\n  // Compute the finalRgb, but keep it pre-multiplied (for unpre-multiplied you\r\n  // need to divide by finalAlpha). We avoid the division here by setting the\r\n  // appropriate blending function in the material.\r\n  vec3 finalRgb \x3d mix(borderColor.rgb * borderAlpha, color.rgb, colorAlpha);\r\n\r\n  gl_FragColor \x3d vec4(finalRgb, finalAlpha);\r\n\r\n#endif\r\n\r\n}\r\n",
"lineCallout.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n#include \x3cutil/alignPixel.glsl\x3e\r\n#include \x3cutil/hud.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n\r\nattribute vec2 uv0;\r\n\r\nuniform float lineSize;\r\nuniform vec2 pixelToNDC;\r\nuniform float borderSize;\r\nuniform vec2 screenOffset;\r\n\r\nvarying vec4 coverageSampling;\r\nvarying vec2 lineSizes;\r\n\r\nvoid main(void) {\r\n\r\n  ProjectHUDAux projectAux;\r\n  vec4 endPoint \x3d projectPositionHUD(projectAux);\r\n\r\n  vec3 vpos \x3d projectAux.posModel;\r\n  if (rejectBySlice(vpos)) {\r\n    gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\r\n    return;\r\n  }\r\n\r\n#ifdef OCCL_TEST\r\n  if (!testVisibilityHUD(endPoint)) {\r\n    gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\r\n    return;\r\n  }\r\n#endif\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n  vec4 perspectiveFactor \x3d screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\r\n  vec2 screenOffsetScaled \x3d applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);\r\n#else\r\n  vec2 screenOffsetScaled \x3d screenOffset;\r\n#endif\r\n\r\n  // Add view dependent polygon offset to get exact same original starting point. This is mostly\r\n  // used to get the correct depth value\r\n  vec3 posView \x3d (view * (model * vec4(position, 1.0))).xyz;\r\n  applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);\r\n\r\n  vec4 startPoint \x3d proj * vec4(posView, 1.0);\r\n\r\n  // Apply screen offset to both start and end point\r\n  vec2 screenOffsetNorm \x3d screenOffsetScaled * 2.0 / viewport.zw;\r\n\r\n  startPoint.xy +\x3d screenOffsetNorm * startPoint.w;\r\n  endPoint.xy +\x3d screenOffsetNorm * endPoint.w;\r\n\r\n  // Align start and end to pixel origin\r\n  vec4 startAligned \x3d alignToPixelOrigin(startPoint, viewport.zw);\r\n  vec4 endAligned \x3d alignToPixelOrigin(endPoint, viewport.zw);\r\n\r\n#ifdef DEPTH_HUD\r\n\r\n#ifdef DEPTH_HUD_ALIGN_START\r\n  endAligned \x3d vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);\r\n#else\r\n  startAligned \x3d vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);\r\n#endif\r\n\r\n#endif\r\n\r\n  vec4 projectedPosition \x3d mix(startAligned, endAligned, uv0.y);\r\n\r\n  // The direction of the line in screen space\r\n  vec2 screenSpaceDirection \x3d normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\r\n  vec2 perpendicularScreenSpaceDirection \x3d vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n\r\n  float lineSizeScaled \x3d applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\r\n  float borderSizeScaled \x3d applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\r\n\r\n#else\r\n\r\n  float lineSizeScaled \x3d lineSize;\r\n  float borderSizeScaled \x3d borderSize;\r\n\r\n#endif\r\n\r\n  float halfPixelSize \x3d lineSizeScaled * 0.5;\r\n  // Calculate a pixel offset from the edge of the pixel, s.t. we keep the line aligned\r\n  // to pixels if it has a full pixel size. Since pixel aligned biases to the bottom-left,\r\n  // we bias the size to the right (for odd sizes) to balance out the bias. Grow sub-pixel\r\n  // sizes towards the left or right s.t. there is a smooth transition (e.g. from 2 to 3 px).\r\n  float halfWholePixelSize \x3d floor(lineSizeScaled) * 0.5;\r\n  float halfPixelSizeInt \x3d floor(halfWholePixelSize);\r\n\r\n  // Sub-pixel offset if we need to grow sub-pixels to the left\r\n  float subpixelOffset \x3d -fract(lineSizeScaled) * float(halfWholePixelSize \x3e 0.0);\r\n\r\n  // Pixel offset aligning to whole pixels and adding subpixel offset if needed\r\n  float pixelOffset \x3d -halfPixelSizeInt + subpixelOffset;\r\n\r\n  // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\r\n  float padding \x3d 1.0 + borderSizeScaled;\r\n  vec2 ndcOffset \x3d (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;\r\n\r\n  // Offset x/y from the center of the line in screen space\r\n  projectedPosition.xy +\x3d perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\r\n\r\n  // Compute a coverage varying which we can use in the fragment shader to determine\r\n  // how much a pixel is actually covered by the line (i.e. to anti alias the line).\r\n  // This works by computing two coordinates that can be linearly interpolated and then\r\n  // subtracted to find out how far away from the line edge we are.\r\n  float edgeDirection \x3d (uv0.x * 2.0 - 1.0);\r\n\r\n  float halfBorderSize \x3d 0.5 * borderSizeScaled;\r\n  float halfPixelSizeAndBorder \x3d halfPixelSize + halfBorderSize;\r\n  float outerEdgeCoverageSampler \x3d edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\r\n\r\n  float isOneSided \x3d float(lineSizeScaled \x3c 2.0 \x26\x26 borderSize \x3c 2.0);\r\n\r\n  coverageSampling \x3d vec4(\r\n    // Edge coordinate\r\n    outerEdgeCoverageSampler,\r\n\r\n    // Border edge coordinate\r\n    outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\r\n\r\n    // Line offset\r\n    halfPixelSize - 0.5,\r\n\r\n    // Border offset\r\n    halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\r\n  );\r\n\r\n  lineSizes \x3d vec2(lineSizeScaled, borderSizeScaled);\r\n\r\n  gl_Position \x3d projectedPosition;\r\n}\r\n"},
measurementArrow:{"measurementArrow.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nuniform float outlineSize;\r\nuniform vec4 outlineColor;\r\nuniform float stripeLength;\r\nuniform vec4 stripeEvenColor;\r\nuniform vec4 stripeOddColor;\r\n\r\nvarying vec2 vtc;\r\nvarying float vlength;\r\nvarying float vradius;\r\n\r\n#define INV_SQRT2 (1.0 / sqrt(2.0))\r\n\r\nvec4 arrowColor(vec2 tc, float len) {\r\n  float d \x3d INV_SQRT2 * (tc.x - abs(tc.y));\r\n  d \x3d min(d, INV_SQRT2 * (len - tc.x - abs(tc.y)));\r\n  d \x3d min(d, 1.0 - abs(tc.y));\r\n\r\n  if (d \x3c 0.0) {\r\n    return vec4(0.0);\r\n  } else if (d \x3c outlineSize) {\r\n    return outlineColor;\r\n  } else {\r\n    return fract(0.5 / stripeLength * tc.x * vradius) \x3e\x3d 0.5 ? stripeOddColor : stripeEvenColor;\r\n  }\r\n}\r\n\r\nvoid main(void) {\r\n  vec2 ntc \x3d vec2(vtc.x / vradius, vtc.y);\r\n  vec4 color \x3d arrowColor(ntc, vlength / vradius);\r\n  if (color.a \x3d\x3d 0.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d color;\r\n}\r\n",
"measurementArrow.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform mat4 model;\r\n\r\nuniform float width;\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 uv0;\r\nattribute float auxpos1;\r\n\r\nvarying vec2 vtc;\r\nvarying float vlength;\r\nvarying float vradius;\r\n\r\nvoid main(void) {\r\n  vec3 bitangent \x3d normal;\r\n\r\n  vtc \x3d uv0;\r\n  vlength \x3d auxpos1;\r\n  vradius \x3d 0.5 * width;\r\n\r\n  vec4 pos \x3d view * vec4((model * vec4(position + vradius * bitangent * uv0.y, 1.0)).xyz, 1.0);\r\n  gl_Position \x3d proj * pos;\r\n}\r\n"},
nativeLine:{"colorPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n\r\nuniform vec4 color;\r\nvarying vec3 vpos;\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n  gl_FragColor \x3d highlightSlice(color, vpos);\r\n}\r\n","highlightPass.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n#include \x3cutil/highlight.glsl\x3e\r\n\r\nvarying vec3 vpos;\r\n\r\nuniform sampler2D depthTex;\r\nuniform vec4 highlightViewportPixelSz;\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n  gl_FragColor \x3d highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\r\n}\r\n",
"nativeLine.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform mat4 model;\r\n\r\nattribute vec3 position;\r\n\r\nvarying vec3 vpos;\r\n\r\nvoid main(void) {\r\n  vpos \x3d (model * vec4(position, 1.0)).xyz;\r\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n}\r\n"},pathMaterial:{"colorMixMode.glsl":"#include \x3cutil/color.glsl\x3e\r\n\r\n/*\r\n * The color mix modes are encoded in the symbol color as follows:\r\n *  - Fully transparent symbols are represented with alpha 0 for\r\n *    all color mix modes (except ignore).\r\n *  - color mix mode ignore is encoded as multiply with white\r\n *  - the other 3 color mix modes (tint, replace, multiply) are\r\n *    equally distributed on the remaining 255 alpha values, which\r\n *    gives us 85 possible alpha values\r\n *\r\n * alpha             0 : fully transparent\r\n * alpha in [  1 -  85]: tint\r\n * alpha in [ 86 - 170]: replace\r\n * alpha in [171 - 255]: multiply\r\n */\r\nvec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {\r\n  float symbolAlpha \x3d 0.0;\r\n\r\n  const float maxTint \x3d 85.0;\r\n  const float maxReplace \x3d 170.0;\r\n  const float scaleAlpha \x3d 3.0;\r\n\r\n  if (symbolColor.a \x3d\x3d 0.0) {\r\n    colorMixMode \x3d 1; // fully transparent -\x3e multiply\r\n    symbolAlpha \x3d 0.0;\r\n  }\r\n  else if (symbolColor.a \x3c\x3d maxTint) {\r\n    colorMixMode \x3d 0; // tint\r\n    symbolAlpha \x3d scaleAlpha * symbolColor.a;\r\n  }\r\n  else if (symbolColor.a \x3c\x3d maxReplace) {\r\n    colorMixMode \x3d 3; // replace\r\n    symbolAlpha \x3d scaleAlpha * (symbolColor.a - maxTint);\r\n  }\r\n  else {\r\n    colorMixMode \x3d 1;  // multiply\r\n    symbolAlpha \x3d scaleAlpha * (symbolColor.a - maxReplace);\r\n  }\r\n\r\n  return vec4(symbolColor.rgb, symbolAlpha);\r\n}\r\n\r\nvec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {\r\n\r\n  // workaround for artifacts in OSX using Intel Iris Pro\r\n  // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\r\n  vec3 internalMixed \x3d internalColor * textureColor;\r\n  vec3 allMixed \x3d internalMixed * externalColor;\r\n\r\n  if (mode \x3d\x3d 1 /* multiply */) {\r\n    return allMixed;\r\n  }\r\n  else if (mode \x3d\x3d 2 /* ignore */ ) {\r\n    return internalMixed;\r\n  }\r\n  else if (mode \x3d\x3d 3 /* replace */ ) {\r\n    return externalColor;\r\n  }\r\n  else {\r\n    // tint (or something invalid)\r\n    vec3 hsvIn \x3d rgb2hsv(internalMixed);\r\n    vec3 hsvTint \x3d rgb2hsv(externalColor);\r\n    vec3 hsvOut \x3d vec3(hsvTint.x, hsvTint.y, hsvIn.z * hsvTint.z);\r\n    return hsv2rgb(hsvOut);\r\n  }\r\n}\r\n\r\nfloat mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {\r\n\r\n  // workaround for artifacts in OSX using Intel Iris Pro\r\n  // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475\r\n  float internalMixed \x3d internalOpacity * textureOpacity;\r\n  float allMixed \x3d internalMixed * externalOpacity;\r\n\r\n  if (mode \x3d\x3d 2 /* ignore */ ) {\r\n    return internalMixed;\r\n  }\r\n  else if (mode \x3d\x3d 3 /* replace */ ) {\r\n    return externalOpacity;\r\n  }\r\n  else {\r\n    // multiply or tint (or something invalid)\r\n    return allMixed;\r\n  }\r\n}\r\n",
"colorPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n#include \x3cutil/sceneLighting.glsl\x3e\r\n\r\n#ifdef TEXTURING\r\nuniform sampler2D tex;\r\nuniform vec2 texSize;\r\nvarying vec2 vtc;\r\n#ifdef TEXTURE_ATLAS\r\nvarying vec4 regionV;\r\n#endif\r\n#endif\r\n\r\nuniform vec3 camPos;\r\nuniform vec3 localOrigin;\r\n\r\n// material parameters\r\n//////////////////////////////////////////\r\nuniform vec3 ambient;\r\nuniform vec3 diffuse;\r\nuniform vec3 specular;\r\nuniform float opacity;\r\nuniform float layerOpacity;\r\n\r\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\r\nvarying mediump float colorMixMode; // varying int is not supported in WebGL\r\n#else\r\nuniform int colorMixMode;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOWS\r\nuniform sampler2D depthTex;\r\nuniform int shadowMapNum;\r\nuniform vec4 shadowMapDistance;\r\nuniform mat4 shadowMapMatrix[4];\r\nuniform float depthHalfPixelSz;\r\n#endif\r\n\r\n#ifdef RECEIVE_SSAO\r\nuniform sampler2D ssaoTex;\r\nuniform vec4 viewportPixelSz;\r\n#endif\r\n\r\nvarying vec3 vpos;\r\nvarying vec3 vnormal;\r\n#if defined(VERTEXCOLORS)\r\nvarying vec4 vcolor;\r\n#endif\r\nvarying vec4 vcolorExt;\r\n\r\n#ifdef RECEIVE_SHADOWS\r\nvarying float linearDepth;\r\n#include \x3cutil/shadow.glsl\x3e\r\n#endif\r\n\r\n#ifdef TEXTURING\r\n#include \x3cmaterials/pathMaterial/texturing.glsl\x3e\r\n#endif\r\n\r\n#include \x3cmaterials/pathMaterial/colorMixMode.glsl\x3e\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n#ifdef TEXTURING\r\n  vec4 texColor \x3d textureLookup(tex, vtc);\r\n  if (texColor.a * coverageCorrectionFactor(vtc) \x3c ALPHA_THRESHOLD) {\r\n    discard;\r\n  }\r\n#else /* TEXTURING */\r\n  vec4 texColor \x3d vec4(1.0);\r\n#endif /* TEXTURING */\r\n\r\n  vec3 viewDir \x3d vpos - camPos;\r\n\r\n  // compute normal\r\n  // TODO: this is not in sync with the normal pass\r\n#ifdef GROUND_NORMAL_SHADING\r\n#ifdef VIEWING_MODE_GLOBAL\r\n  vec3 normal \x3d normalize(vpos + localOrigin);\r\n#else\r\n  vec3 normal \x3d vec3(0.0, 0.0, 1.0);\r\n#endif\r\n#else\r\n#ifdef DOUBLESIDED\r\n  vec3 normal \x3d dot(vnormal, viewDir)\x3e0.0 ? -vnormal : vnormal;\r\n#elif defined(WINDINGORDERDOUBLESIDED)\r\n  vec3 normal \x3d gl_FrontFacing ? vnormal : -vnormal;\r\n#else\r\n  vec3 normal \x3d vnormal;\r\n#endif\r\n  normal \x3d normalize(normal);\r\n#endif\r\n\r\n  // compute ssao\r\n#ifdef RECEIVE_SSAO\r\n  float ssao \x3d texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\r\n  ssao \x3d viewportPixelSz.z \x3c 0.0 ? 1.0 : ssao;\r\n#else\r\n  float ssao \x3d 1.0;\r\n#endif\r\n\r\n  // At global scale we create some additional ambient light based on the main light to simulate global illumination\r\n  float additionalAmbientScale;\r\n  vec3 additionalLight \x3d sceneLightingAdditionalLightGlobal(vpos + localOrigin, ssao, additionalAmbientScale);\r\n\r\n  // compute shadowing\r\n  float shadow \x3d 0.0;\r\n#ifdef RECEIVE_SHADOWS\r\n  shadow \x3d evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\r\n#elif defined(VIEWING_MODE_GLOBAL)\r\n  // at global scale (and in global scenes) we fall back to this approximation\r\n  // to shadow objects on the dark side of the earth\r\n  shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\r\n#endif\r\n\r\n  vec3 matColor \x3d max(ambient, diffuse); // combine the old material parameters into a single one\r\n#if defined(VERTEXCOLORS)\r\n  // Internal colors: varying vcolor + uniform ambient/diffuse, external colors: varying vcolorExt\r\n  vec3 albedo_ \x3d mixExternalColor(vcolor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\r\n  float opacity_ \x3d layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\r\n#else\r\n  // Internal colors: uniform ambient/diffuse, external colors: varying vcolorExt\r\n  vec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\r\n  float opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\r\n#endif\r\n  albedo_+\x3d 0.25 * specular; // don't completely ignore specular for now\r\n\r\n#ifdef TRANSPARENCY_DISCARD\r\n  if (opacity_ \x3c 0.001) {\r\n    discard;\r\n  }\r\n#endif\r\n\r\n#ifdef WIREFRAME\r\n  gl_FragColor \x3d vec4(matColor, opacity_);\r\n#else\r\n  vec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\r\n  gl_FragColor \x3d vec4(shadedColor, opacity_);\r\n#endif\r\n\r\n  gl_FragColor \x3d highlightSlice(gl_FragColor, vpos);\r\n}\r\n",
"colorPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\n#include \x3cmaterials/pathMaterial/commonInputs.glsl\x3e\r\n\r\nattribute vec3 position;\r\nattribute vec4 auxpos1; // direction offset\r\n#ifdef COMPRESSED_NORMALS\r\nattribute vec2 normalCompressed;\r\n#else\r\nattribute vec3 normal;\r\n#endif\r\nvarying vec3 vpos;\r\nvarying vec3 vnormal;\r\n\r\n#ifdef TEXTURING\r\nattribute vec2 uv0;\r\nvarying vec2 vtc;\r\n#ifdef TEXTURE_ATLAS\r\nattribute vec4 region;\r\nvarying vec4 regionV;\r\n#endif\r\n#endif\r\n\r\n#ifdef COMPONENTCOLORS\r\nuniform sampler2D uComponentColorTex;\r\nuniform vec2 uComponentColorTexInvDim;\r\n\r\nattribute float componentIndex;\r\n\r\nvec4 readComponentColor() {\r\n  float normalizedIndex \x3d (componentIndex + 0.5) * uComponentColorTexInvDim.x;\r\n  vec2 indexCoord \x3d vec2(\r\n    mod(normalizedIndex, 1.0),\r\n    (floor(normalizedIndex) + 0.5) * uComponentColorTexInvDim.y\r\n  );\r\n  return texture2D(uComponentColorTex, indexCoord);\r\n}\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOWS\r\nvarying float linearDepth;\r\n#endif\r\n\r\n#ifdef VERTEXCOLORS\r\nattribute vec4 color;\r\n#endif\r\n\r\n#ifdef SYMBOLVERTEXCOLORS\r\nattribute vec4 symbolColor;\r\n#endif\r\n\r\n#if defined(VERTEXCOLORS)\r\nvarying vec4 vcolor;\r\n#endif\r\n\r\n// Workaround for https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/13452\r\n// We pass the externalColor uniform from VS to FS through the vcolorExt varying because\r\n// there is a driver bug for Intel Integrated Graphics which led to rendering artifacts\r\n// since the introduction of https://devtopia.esri.com/WebGIS/arcgis-js-api/pull/12673\r\n// This should be further cleaned up later with through the following issue:\r\n// https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/12763\r\nuniform vec4 externalColor;\r\nvarying vec4 vcolorExt;\r\n\r\n#if defined(SYMBOLVERTEXCOLORS) || defined(COMPONENTCOLORS)\r\nvarying mediump float colorMixMode; // varying int is not supported in WebGL\r\n#endif\r\n\r\n#include \x3cmaterials/pathMaterial/visualVariables.glsl\x3e\r\n\r\n#if defined(VV_SIZE) || defined(VV_COLOR)\r\nattribute vec4 auxpos2;\r\n#endif\r\n\r\n#include \x3cmaterials/pathMaterial/commonFunctions.glsl\x3e\r\n#include \x3cmaterials/pathMaterial/localNormal.glsl\x3e\r\n#include \x3cmaterials/pathMaterial/colorMixMode.glsl\x3e\r\n\r\nvoid main() {\r\n  vpos \x3d calculateVPos();\r\n\r\n  vnormal \x3d normalize((modelNormal * localNormal()).xyz);\r\n\r\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n  // Shadowmap's cascading index used to be based on '1.0 / gl_FragCoord.w'\r\n  // (i.e. the perspective interpolation of 'gl_Position.w'). Precision\r\n  // issues on iPad/iPhone with the 'w' component require the depth to be\r\n  // passed as varying to properly drive the cascading shadow map index.\r\n  linearDepth \x3d gl_Position.w;\r\n#endif\r\n\r\n#ifdef VERTEXCOLORS\r\n  vcolor \x3d color * 0.003921568627451; // \x3d 1/255\r\n#endif\r\n\r\n  vcolorExt \x3d externalColor;\r\n\r\n#ifdef VV_COLOR\r\n  vcolorExt *\x3d vvGetColor(auxpos2, vvColorValues, vvColorColors);\r\n#endif\r\n\r\n#ifdef SYMBOLVERTEXCOLORS\r\n  int symbolColorMixMode;\r\n  vcolorExt *\x3d decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\r\n  colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\r\n#endif\r\n\r\n#ifdef COMPONENTCOLORS\r\n  int symbolColorMixMode;\r\n  vcolorExt *\x3d decodeSymbolColor(readComponentColor() * 255.0, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\r\n  colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\r\n#endif\r\n\r\n#ifdef TEXTURING\r\n  // the v coordinate is stored in auxpos1.w\r\n#ifndef FLIPV\r\n  vtc \x3d vec2(uv0.x, auxpos1.w);\r\n#else\r\n  vtc \x3d vec2(uv0.x, 1.0-auxpos1.w);\r\n#endif\r\n#ifdef TEXTURE_ATLAS\r\n  regionV \x3d region;\r\n#endif\r\n#endif /* TEXTURING */\r\n\r\n}\r\n",
"commonFunctions.glsl":"#include \x3cmaterials/pathMaterial/localPosition.glsl\x3e\r\n#include \x3cutil/doublePrecision.glsl\x3e\r\n\r\nvec3 calculateVPos() {\r\n  return (model * localPosition()).xyz;\r\n}","commonInputs.glsl":"uniform mat4 proj;\r\nuniform mat4 view;\r\n\r\nuniform vec3 camPos;\r\nuniform vec3 localOrigin;\r\n\r\nuniform mat4 model;\r\nuniform mat4 modelNormal;\r\n\r\nuniform float size;\r\n\r\n// ---------------------------------------------- ++","depthPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/encoding.glsl\x3e\r\n#include \x3cutil/depth.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n\r\nvarying float depth;\r\nvarying vec3 vpos;\r\n\r\n#ifdef TEXTURING\r\nuniform sampler2D tex;\r\nuniform vec2 texSize;\r\nvarying vec2 vtc;\r\n#ifdef TEXTURE_ATLAS\r\nvarying vec4 regionV;\r\n#endif\r\n#endif\r\n\r\n#ifdef TEXTURING\r\n#include \x3cmaterials/pathMaterial/texturing.glsl\x3e\r\n#endif\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n#ifdef TEXTURING\r\n  if (textureLookup(tex, vtc).a * coverageCorrectionFactor(vtc) \x3c ALPHA_THRESHOLD) {\r\n    discard;\r\n  }\r\n#endif\r\n\r\n#ifndef BIAS_SHADOWMAP\r\n  gl_FragColor \x3d float2rgba(depth);\r\n#else\r\n  gl_FragColor \x3d float2rgba(calcFragDepth(depth));\r\n#endif\r\n}\r\n",
"depthPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\n#include \x3cmaterials/pathMaterial/commonInputs.glsl\x3e\r\n\r\nuniform vec2 nearFar;\r\nattribute vec3 position;\r\nattribute vec4 auxpos1; // direction offset\r\n\r\nvarying float depth;\r\nvarying vec3 vpos;\r\n\r\n#ifdef TEXTURING\r\nattribute vec2 uv0;\r\nvarying vec2 vtc;\r\n#ifdef TEXTURE_ATLAS\r\nattribute vec4 region;\r\nvarying vec4 regionV;\r\n#endif\r\n#endif\r\n\r\n#include \x3cmaterials/pathMaterial/visualVariables.glsl\x3e\r\n\r\n#if defined(VV_SIZE)\r\nattribute vec4 auxpos2;\r\n#endif\r\n\r\n#include \x3cmaterials/pathMaterial/commonFunctions.glsl\x3e\r\n\r\nvoid main(void) {\r\n  vpos \x3d calculateVPos();\r\n\r\n  vec4 eye \x3d view * vec4(vpos, 1.0);\r\n\r\n  gl_Position \x3d proj * eye;\r\n  depth \x3d (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\r\n\r\n#ifdef TEXTURING\r\n#ifndef FLIPV\r\n  vtc \x3d uv0;\r\n#else\r\n  vtc \x3d vec2(uv0.x, 1.0-uv0.y);\r\n#endif\r\n#ifdef TEXTURE_ATLAS\r\n  regionV \x3d region;\r\n#endif\r\n#endif /* TEXTURING */\r\n\r\n}\r\n",
"highlightPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n#include \x3cutil/highlight.glsl\x3e\r\n\r\nvarying vec3 vpos;\r\n\r\n#ifdef TEXTURING\r\nuniform sampler2D tex;\r\nuniform vec2 texSize;\r\nvarying vec2 vtc;\r\n#ifdef TEXTURE_ATLAS\r\nvarying vec4 regionV;\r\n#endif\r\n#endif\r\n\r\nuniform sampler2D depthTex;\r\nuniform vec4 highlightViewportPixelSz;\r\n\r\n#ifdef TEXTURING\r\n#include \x3cmaterials/pathMaterial/texturing.glsl\x3e\r\n#endif\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n#ifdef TEXTURING\r\n  if (textureLookup(tex, vtc).a * coverageCorrectionFactor(vtc) \x3c ALPHA_THRESHOLD) {\r\n    discard;\r\n  }\r\n#endif\r\n\r\n  gl_FragColor \x3d highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\r\n}\r\n",
"highlightPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\n#include \x3cmaterials/pathMaterial/commonInputs.glsl\x3e\r\n\r\nattribute vec3 position;\r\nattribute vec4 auxpos1; // direction offset\r\n\r\nvarying vec3 vpos;\r\n\r\n#ifdef TEXTURING\r\nattribute vec2 uv0;\r\nvarying vec2 vtc;\r\n#ifdef TEXTURE_ATLAS\r\nattribute vec4 region;\r\nvarying vec4 regionV;\r\n#endif\r\n#endif\r\n\r\n#include \x3cmaterials/pathMaterial/visualVariables.glsl\x3e\r\n\r\n#if defined(VV_SIZE)\r\nattribute vec4 auxpos2;\r\n#endif\r\n\r\n#include \x3cmaterials/pathMaterial/commonFunctions.glsl\x3e\r\n\r\nvoid main(void) {\r\n  vpos \x3d calculateVPos();\r\n\r\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n\r\n#ifdef TEXTURING\r\n#ifndef FLIPV\r\n  vtc \x3d uv0;\r\n#else\r\n  vtc \x3d vec2(uv0.x, 1.0-uv0.y);\r\n#endif\r\n#ifdef TEXTURE_ATLAS\r\n  regionV \x3d region;\r\n#endif\r\n#endif /* TEXTURING */\r\n\r\n}\r\n",
"localNormal.glsl":"#include \x3cutil/normalEncoding.glsl\x3e\r\n\r\n# ifdef COMPRESSED_NORMALS\r\nvec4 localNormal() { return vec4(decodeNormal(normalCompressed), 1.0); }\r\n# else\r\nvec4 localNormal() { return vec4(normal, 1.0); }\r\n# endif\r\n","localPosition.glsl":"#ifdef VV_SIZE\r\nvec4 localPosition() {\r\n    vec3 sizeScale \x3d vvGetScale(auxpos2);\r\n    vec3 positionOffset \x3d auxpos1.xyz*sizeScale;\r\n    return vec4( position+positionOffset, 1.0 );\r\n}\r\n#else\r\nvec4 localPosition() {\r\n    vec3 sizeScale \x3d vec3(size);\r\n    vec3 positionOffset \x3d auxpos1.xyz*sizeScale;\r\n    return vec4(position+positionOffset, 1.0);\r\n}\r\n#endif\r\n",
"normalPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n\r\nvarying vec3 vnormal;\r\nvarying vec3 vpos;\r\n\r\n#ifdef TEXTURING\r\nuniform sampler2D tex;\r\nuniform vec2 texSize;\r\nvarying vec2 vtc;\r\n#ifdef TEXTURE_ATLAS\r\nvarying vec4 regionV;\r\n#endif\r\n#endif\r\n\r\n#ifdef TEXTURING\r\n#include \x3cmaterials/pathMaterial/texturing.glsl\x3e\r\n#endif\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n#ifdef TEXTURING\r\n  if (textureLookup(tex, vtc).a * coverageCorrectionFactor(vtc) \x3c ALPHA_THRESHOLD) {\r\n    discard;\r\n  }\r\n#endif\r\n\r\n  vec3 normal \x3d normalize(vnormal);\r\n  if (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\r\n\r\n#ifndef ALPHA_ZERO\r\n  gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\r\n#else\r\n  gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\r\n#endif\r\n}\r\n",
"normalPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\n#include \x3cmaterials/pathMaterial/commonInputs.glsl\x3e\r\n\r\nuniform mat4 viewNormal;\r\nattribute vec3 position;\r\nattribute vec4 auxpos1; // direction offset\r\n#ifdef COMPRESSED_NORMALS\r\nattribute vec2 normalCompressed;\r\n#else\r\nattribute vec3 normal;\r\n#endif\r\n\r\n#ifdef TEXTURING\r\nattribute vec2 uv0;\r\nvarying vec2 vtc;\r\n#ifdef TEXTURE_ATLAS\r\nattribute vec4 region;\r\nvarying vec4 regionV;\r\n#endif\r\n#endif\r\n\r\nvarying vec3 vnormal;\r\nvarying vec3 vpos;\r\n\r\n#include \x3cmaterials/pathMaterial/visualVariables.glsl\x3e\r\n\r\n#if defined(VV_SIZE)\r\nattribute vec4 auxpos2;\r\n#endif\r\n\r\n#include \x3cmaterials/pathMaterial/commonFunctions.glsl\x3e\r\n#include \x3cmaterials/pathMaterial/localNormal.glsl\x3e\r\n\r\nvoid main(void) {\r\n  vpos \x3d calculateVPos();\r\n\r\n  vnormal \x3d normalize((viewNormal * modelNormal * localNormal()).xyz);\r\n\r\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n\r\n#ifdef TEXTURING\r\n#ifndef FLIPV\r\n  vtc \x3d uv0;\r\n#else\r\n  vtc \x3d vec2(uv0.x, 1.0-uv0.y);\r\n#endif\r\n#ifdef TEXTURE_ATLAS\r\n  regionV \x3d region;\r\n#endif\r\n#endif /* TEXTURING */\r\n\r\n}\r\n",
"texturing.glsl":"float calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\r\n  // from:\r\n  //   - OpenGLES Common Profile Specification Version 2.0.25, Section 3.7.7 - Texture Minification\r\n  //   - https://www.opengl.org/discussion_boards/showthread.php/171485-Texture-LOD-calculation-(useful-for-atlasing)\r\n  //   - http://www.linedef.com/virtual-texture-demo.html\r\n  float deltaMaxSqr \x3d max(dot(ddx, ddx), dot(ddy, ddy));\r\n  return max(0.0, 0.5 * log2(deltaMaxSqr));\r\n}\r\n\r\n// based on https://medium.com/@bgolus/anti-aliased-alpha-test-the-esoteric-alpha-to-coverage-8b177335ae4f\r\nfloat coverageCorrectionFactor(vec2 uv) {\r\n#ifdef ALPHA_COVERAGE_CORRECTION\r\n  const float MipScale \x3d 0.25;\r\n  uv *\x3d texSize;\r\n#ifdef TEXTURE_ATLAS\r\n  uv *\x3d region.zw - region.xy;\r\n#endif\r\n  return 1.0 + max(0.0, calcMipMapLevel(dFdx(uv), dFdy(uv))) * MipScale;\r\n#else\r\n  return 1.0;\r\n#endif\r\n}\r\n\r\n#ifdef ALPHA_COVERAGE_CORRECTION\r\n  #define ALPHA_THRESHOLD 0.5\r\n#else\r\n  #define ALPHA_THRESHOLD 0.33\r\n#endif\r\n\r\nvec4 textureAtlasLookup(sampler2D tex, vec2 uv, vec4 region, vec2 texSize) {\r\n  //[umin, vmin, umax, vmax]\r\n  vec2 atlasScale \x3d region.zw - region.xy;\r\n  vec2 uvAtlas \x3d fract(uv) * atlasScale + region.xy;\r\n\r\n  vec4 texColor;\r\n\r\n  // calculate derivative of continuous texture coordinate\r\n  // to avoid mipmapping artifacts caused by manual wrapping in shader\r\n  vec2 dUVdx \x3d dFdx(uv) * atlasScale;\r\n  vec2 dUVdy \x3d dFdy(uv) * atlasScale;\r\n\r\n#ifdef GL_EXT_shader_texture_lod\r\n  return texture2DGradEXT(tex, uvAtlas, dUVdx, dUVdy);\r\n#else\r\n  // use bias to compensate for difference in automatic vs desired mipmap level\r\n  vec2 dUVdxAuto \x3d dFdx(uvAtlas);\r\n  vec2 dUVdyAuto \x3d dFdy(uvAtlas);\r\n  float mipMapLevel \x3d calcMipMapLevel(dUVdx * texSize, dUVdy * texSize);\r\n  float autoMipMapLevel \x3d calcMipMapLevel(dUVdxAuto * texSize, dUVdyAuto * texSize);\r\n\r\n  return texture2D(tex, uvAtlas, mipMapLevel - autoMipMapLevel);\r\n#endif\r\n}\r\n\r\nvec4 textureLookup(sampler2D tex, vec2 uv) {\r\n#ifdef TEXTURE_ATLAS\r\n  return textureAtlasLookup(tex, uv, regionV, texSize);\r\n#else\r\n  return texture2D(tex, uv);\r\n#endif\r\n}\r\n\r\n",
"visualVariables.glsl":"\r\n#if defined(VV_SIZE)\r\n  uniform vec3 vvSizeMinSize;\r\n  uniform vec3 vvSizeMaxSize;\r\n  uniform vec3 vvSizeOffset;\r\n  uniform vec3 vvSizeFactor;\r\n\r\n  vec3 vvGetScale(vec4 featureAttribute) {\r\n    return clamp(vvSizeOffset + featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);\r\n  }\r\n#endif\r\n\r\n#ifdef VV_COLOR\r\n  #define VV_COLOR_N 8\r\n  uniform float vvColorValues[VV_COLOR_N];\r\n  uniform vec4 vvColorColors[VV_COLOR_N];\r\n\r\n  vec4 vvGetColor(vec4 featureAttribute, float values[VV_COLOR_N], vec4 colors[VV_COLOR_N]) {\r\n    float value \x3d featureAttribute.y;\r\n    if (value \x3c\x3d values[0]) {\r\n      return colors[0];\r\n    }\r\n\r\n    for (int i \x3d 1; i \x3c VV_COLOR_N; ++i) {\r\n      if (values[i] \x3e\x3d value) {\r\n        float f \x3d (value - values[i-1]) / (values[i] - values[i-1]);\r\n        return mix(colors[i-1], colors[i], f);\r\n      }\r\n    }\r\n\r\n    return colors[VV_COLOR_N - 1];\r\n  }\r\n#endif\r\n\r\n\r\n\r\n"},
ribbonLine:{"colorPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n\r\nuniform vec4 eColor;\r\nvarying vec4 vColor;\r\nvarying vec2 vtc;\r\nvarying vec3 vpos;\r\n\r\n#ifdef STIPPLE\r\nuniform float stippleLengthDoubleInv;\r\n#endif\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n#ifdef STIPPLE\r\n  if (fract(vtc.x * stippleLengthDoubleInv) \x3e 0.5) {\r\n    discard;\r\n  }\r\n#endif\r\n\r\n  gl_FragColor \x3d highlightSlice(eColor * vColor, vpos);\r\n}\r\n",
"highlightPass.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n\r\nvarying vec2 vtc;\r\nvarying vec3 vpos;\r\n\r\n#ifdef STIPPLE\r\nuniform float stippleLengthDoubleInv;\r\n#endif\r\n\r\nvoid main() {\r\n  discardBySlice(vpos);\r\n\r\n#ifdef STIPPLE\r\n  if (fract(vtc.x * stippleLengthDoubleInv) \x3e 0.5) {\r\n    discard;\r\n  }\r\n#endif\r\n\r\n  gl_FragColor \x3d vec4(1.0, 1.0, 1.0, 1.0);\r\n}\r\n","ribbonLine.vert":'#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform mat4 model;\r\n\r\nuniform float extLineWidth;\r\nuniform float nearPlane;\r\n\r\nattribute vec3 position;\r\nattribute vec2 uv0;\r\nattribute vec4 color;\r\n\r\nvarying vec2 vtc;\r\nvarying vec4 vColor;\r\nvarying vec3 vpos;\r\n\r\nattribute float size;\r\n\r\n#ifndef WALL\r\nuniform float miterLimit;\r\nattribute vec3 auxpos1;\r\nattribute vec3 auxpos2;\r\n#endif\r\n\r\n#ifdef SCREENSCALE\r\nuniform vec2 screenSize;\r\n\r\nvec4 toScreenCoords(vec3 vertex) {\r\n  vec4 vClipSpace \x3d proj * view * vec4((model * vec4(vertex, 1.0)).xyz, 1.0);\r\n  vClipSpace.xy *\x3d screenSize;\r\n  return vClipSpace/abs(vClipSpace.w);\r\n}\r\n\r\n#define VECTYPE vec2\r\n#define ZEROVEC vec2(0.0, 0.0)\r\n#define PERPENDICULAR(v) vec2(v.y, -v.x);\r\n#define ISOUTSIDE (left.x * right.y - left.y * right.x)*uv0.y \x3e 0.0\r\n\r\n#else //ifdef SCREENSCALE\r\n\r\n#define VECTYPE vec3\r\n#define ZEROVEC vec3(0.0, 0.0, 0.0)\r\n// these macros are only valid for "strip" type lines:\r\n#define PERPENDICULAR(v) cross(up/*vec3(0.0, 1.0, 0.0)*/, v)\r\n#define ISOUTSIDE dot(cross(left, right), up/*vec3(0.0, 1.0, 0.0)*/)*uv0.y \x3c 0.0\r\n\r\n#endif //ifdef SCREENSCALE\r\n\r\nfloat interp(float ncp, vec4 a, vec4 b) {\r\n  return (-ncp - a.z) / (b.z - a.z);\r\n}\r\n\r\n#ifdef SCREENSCALE\r\n\r\nvoid clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next) {\r\n  float vnp \x3d nearPlane*0.99;\r\n\r\n  //We have four vertices per point on the line. Start and end vertices\r\n  //are treated differently --\x3e d \x3e 0, d \x3c 0\r\n  float d \x3d abs(uv0.y) - 1.1;\r\n\r\n  //current pos behind ncp --\x3e we need to clip\r\n  if(pos.z \x3e -nearPlane) {\r\n    if (d \x3c 0.0) {\r\n      //previous in front of ncp\r\n      if(prev.z \x3c -nearPlane) {\r\n        pos \x3d mix(prev, pos, interp(vnp, prev, pos));\r\n        next \x3d pos;\r\n      } else {\r\n        pos \x3d vec4(0.0, 0.0, 0.0, 1.0);\r\n      }\r\n    }\r\n    //next in front of ncp\r\n    if(d \x3e 0.0) {\r\n      if(next.z \x3c -nearPlane) {\r\n        pos \x3d mix(pos, next, interp(vnp, pos, next));\r\n        prev \x3d pos;\r\n      } else {\r\n        pos \x3d vec4(0.0, 0.0, 0.0, 1.0);\r\n      }\r\n    }\r\n  } else {\r\n    //current position visible\r\n    //previous behind ncp\r\n    if (prev.z \x3e -nearPlane) {\r\n      prev \x3d mix(pos, prev, interp(vnp, pos, prev));\r\n    }\r\n    //next behind ncp\r\n    if (next.z \x3e -nearPlane) {\r\n      next \x3d mix(next, pos, interp(vnp, next, pos));\r\n    }\r\n  }\r\n\r\n  pos\x3d proj * pos;\r\n  pos.xy *\x3d screenSize;\r\n  pos /\x3d pos.w;\r\n\r\n  next \x3d proj * next;\r\n  next.xy *\x3d screenSize;\r\n  next /\x3d next.w;\r\n\r\n  prev \x3d proj * prev;\r\n  prev.xy *\x3d screenSize;\r\n  prev /\x3d prev.w;\r\n}\r\n\r\n#endif // SCREENSCALE\r\n\r\nvoid main(void) {\r\n  vpos \x3d (model * vec4(position, 1.0)).xyz;\r\n\r\n#ifdef SCREENSCALE\r\n// Check for special value of uv0.y which is used by the Renderer when graphics\r\n// are removed before the VBO is recompacted. If this is the case, then we just\r\n// project outside of clip space.\r\nif (uv0.y \x3d\x3d 0.0) {\r\n  // Project out of clip space\r\n  gl_Position \x3d vec4(1e038, 1e038, 1e038, 1.0);\r\n}\r\nelse {\r\n#endif\r\n\r\nfloat lineWidth \x3d extLineWidth + size;\r\n\r\n#ifdef SCREENSCALE\r\n\r\n#if 0\r\n  vec4 pos \x3d toScreenCoords(position.xyz);\r\n  vec2 left \x3d (pos - toScreenCoords(auxpos1)).xy;\r\n  vec2 right \x3d (toScreenCoords(auxpos2) - pos).xy;\r\n#else\r\n  vec4 pos  \x3d view * vec4((model * vec4(position.xyz, 1.0)).xyz, 1.0);\r\n  vec4 prev \x3d view * vec4((model * vec4(auxpos1.xyz, 1.0)).xyz, 1.0);\r\n  vec4 next \x3d view * vec4((model * vec4(auxpos2.xyz, 1.0)).xyz, 1.0);\r\n\r\n  clipAndTransform(pos, prev, next);\r\n\r\n  vec2 left \x3d (pos - prev).xy;\r\n  vec2 right \x3d (next - pos).xy;\r\n#endif\r\n\r\n#else // ifdef SCREENSCALE\r\n  vec4 pos \x3d vec4(position, 1.0);\r\n#ifndef WALL\r\n  vec3 left \x3d position.xyz - auxpos1;\r\n  vec3 right \x3d auxpos2 - position.xyz;\r\n  vec3 up \x3d normalize(position.xyz);\r\n#endif // ifndef WALL\r\n#endif // ifdef SCREENSCALE\r\n\r\n#ifdef WALL\r\n  float displacementLen \x3d lineWidth;\r\n  vec3 displacementDir \x3d normalize(position.xyz);//vec3(0.0, 1.0, 0.0);\r\n#else // ifdef WALL\r\n\r\n  float leftLen \x3d length(left);\r\n  left \x3d (leftLen \x3e 0.001) ? left/leftLen : ZEROVEC;\r\n\r\n  float rightLen \x3d length(right);\r\n  right \x3d (rightLen \x3e 0.001) ? right/rightLen : ZEROVEC;\r\n\r\n  // determine if vertex is on the "outside or "inside" of the join\r\n  bool isOutside \x3d ISOUTSIDE;\r\n\r\n  // compute miter join position first\r\n  float displacementLen \x3d lineWidth;\r\n  VECTYPE displacementDir \x3d normalize(left + right);\r\n  displacementDir \x3d PERPENDICULAR(displacementDir);\r\n  if (leftLen \x3e 0.001 \x26\x26 rightLen \x3e 0.001) {\r\n    float nDotSeg \x3d dot(displacementDir, left);\r\n    displacementLen /\x3d length(nDotSeg*left - displacementDir);\r\n\r\n    // limit displacement of inner vertices\r\n    if (!isOutside) {\r\n      displacementLen \x3d min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));\r\n    }\r\n  }\r\n\r\n  if (isOutside \x26\x26 (displacementLen \x3e miterLimit*lineWidth)) {\r\n    // convert to bevel join if miterLimit is exceeded\r\n    if (leftLen \x3c 0.001) {\r\n      displacementDir \x3d right;\r\n    }\r\n    else if (rightLen \x3c 0.001) {\r\n      displacementDir \x3d left;\r\n    }\r\n    else {\r\n      displacementDir \x3d (abs(uv0.y) - 1.1 \x3c 0.0) ? left : right;\r\n    }\r\n    displacementDir \x3d normalize(displacementDir);\r\n    displacementDir \x3d PERPENDICULAR(displacementDir);\r\n    displacementLen \x3d lineWidth;\r\n  }\r\n\r\n#endif // ifdef WALL\r\n\r\n#ifdef SCREENSCALE\r\n  pos.xy +\x3d displacementDir * floor(uv0.y + 0.5) * displacementLen;\r\n  pos.xy /\x3d screenSize;\r\n#else\r\n  pos.xyz +\x3d displacementDir * floor(uv0.y + 0.5) * displacementLen;\r\n  pos \x3d proj * view * model * pos;\r\n#endif\r\n\r\n  vtc \x3d uv0;\r\n  vColor \x3d color * 0.003921568627451; // \x3d 1/255\r\n  gl_Position \x3d pos;\r\n\r\n#ifdef SCREENSCALE\r\n  }\r\n#endif\r\n}\r\n'},
slicePlane:{"slicePlane.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nuniform vec4 backgroundColor;\r\nuniform vec4 gridColor;\r\nuniform float ratio;\r\nuniform float gridWidth;\r\n\r\nvarying vec2 vUV;\r\n\r\nvoid main() {\r\n  const float LINE_WIDTH \x3d 1.0;\r\n\r\n  vec2 uvScaled \x3d vUV * gridWidth;\r\n  vec2 gridUV \x3d (fract(uvScaled + 0.5) - 0.5) / (LINE_WIDTH * fwidth(uvScaled));\r\n  vec2 grid \x3d (1.0 - step(0.5, gridUV)) * step(-0.5, gridUV);\r\n\r\n  // mask aliasing along edges\r\n  grid.x *\x3d step(0.5, uvScaled.x) * step(uvScaled.x, gridWidth - 0.5);\r\n  grid.y *\x3d step(0.5, uvScaled.y) * step(uvScaled.y, gridWidth - 0.5);\r\n\r\n  float gridFade \x3d max(grid.x, grid.y);\r\n\r\n  float gridAlpha \x3d gridColor.a * gridFade;\r\n\r\n  // premultiply alpha in output\r\n  gl_FragColor \x3d\r\n    vec4(backgroundColor.rgb * backgroundColor.a, backgroundColor.a) * (1.0 - gridAlpha) +\r\n    vec4(gridColor.rgb, 1.0) * gridAlpha;\r\n}\r\n",
"slicePlane.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform mat4 model;\r\n\r\nattribute vec3 position;\r\nattribute vec2 uv0;\r\n\r\nvarying vec2 vUV;\r\n\r\nvoid main(void) {\r\n  vUV \x3d uv0;\r\n  gl_Position \x3d proj * view * vec4((model * vec4(position, 1.0)).xyz, 1.0);\r\n}\r\n"}},misc:{"blendLayers.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nvarying vec2 uv;\r\n\r\nuniform sampler2D tex;\r\nuniform float opacity;\r\n\r\nvoid main() {\r\n  vec4 color \x3d texture2D(tex, uv);\r\n\r\n  // Note: output in pre-multiplied alpha for correct alpha compositing\r\n  gl_FragColor \x3d vec4(color.xyz, 1.0) * color.a * opacity;\r\n}\r\n",
"blendLayers.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nattribute vec3 position;\r\nattribute vec2 uv0;\r\n\r\nuniform float scale;\r\nuniform vec2 offset;\r\n\r\nvarying vec2 uv;\r\n\r\nvoid main(void) {\r\n  gl_Position \x3d vec4(position, 1.0);\r\n  uv \x3d uv0 * scale + offset;;\r\n}\r\n","showDepth.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/encoding.glsl\x3e\r\n\r\nuniform sampler2D depthTex;\r\nvarying vec2 vtc;\r\n\r\nvoid main() {\r\n// gl_FragColor \x3d vec4(vec3(texture2D(depthTex, vtc).a), 1.0);\r\n   gl_FragColor \x3d vec4(rgba2float(texture2D(depthTex, vtc)));\r\n// gl_FragColor \x3d texture2D(depthTex, vtc);\r\n}\r\n",
"showDepth.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nuniform mat4 proj;\r\nattribute vec2 position;\r\nattribute vec2 uv0;\r\nvarying vec2 vtc;\r\n\r\nvoid main(void) {\r\n  gl_Position \x3d proj * vec4(position.x, position.y, .0, 1.0);\r\n  vtc \x3d uv0;\r\n}\r\n","simple.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nuniform vec4 color;\r\n\r\nvoid main() {\r\n  gl_FragColor \x3d color;\r\n}\r\n","simple.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform mat4 model;\r\n\r\nattribute vec3 position;\r\n\r\nvoid main(void) {\r\n  gl_Position \x3d proj * view * vec4((model * vec4(position, 1.0)).xyz, 1.0);\r\n}\r\n",
"texOnly.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nuniform sampler2D tex;\r\nuniform vec4 color;\r\nvarying vec2 vtc;\r\n\r\nvoid main() {\r\n  vec4 texColor \x3d texture2D(tex, vtc);\r\n  gl_FragColor \x3d texColor * color;\r\n}\r\n","texOnly.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform mat4 model;\r\n\r\nattribute vec3 position;\r\nattribute vec2 uv0;\r\n\r\nvarying vec2 vtc;\r\n\r\nvoid main(void) {\r\n  gl_Position \x3d proj * view * vec4((model * vec4(position, 1.0)).xyz, 1.0);\r\n  vtc \x3d uv0;\r\n}\r\n"},
pointRenderer:{"pointRenderer.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/encoding.glsl\x3e\r\n\r\n#ifdef DEPTH_PASS\r\nvarying float depth;\r\n#else\r\nvarying vec3 vColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n  vec2 vOffset \x3d gl_PointCoord - vec2(0.5, 0.5);\r\n  float r2 \x3d dot(vOffset, vOffset);\r\n\r\n  if (r2 \x3e 0.25) {\r\n    discard;\r\n  }\r\n\r\n#ifdef DEPTH_PASS\r\n  gl_FragColor \x3d float2rgba(depth);\r\n#else\r\n  gl_FragColor \x3d vec4(vColor, 1.0);\r\n#endif\r\n}\r\n",
"pointRenderer.vert":"#include \x3cutil/slice.glsl\x3e\r\n#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nattribute vec3 aPosition;\r\nattribute vec3 aColor;\r\n\r\nuniform mat4 uModelViewMatrix;\r\nuniform mat4 uProjectionMatrix;\r\nuniform vec2 uScreenMinMaxSize;\r\nuniform vec2 uPointScale;\r\nuniform vec3 uClipMin;\r\nuniform vec3 uClipMax;\r\n\r\n#ifdef DEPTH_PASS\r\nuniform vec2 nearFar;\r\n\r\nvarying float depth;\r\n#else\r\nvarying vec3 vColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n  // Move clipped points outside of clipspace\r\n  if (aPosition.x \x3c uClipMin.x || aPosition.y \x3c uClipMin.y || aPosition.z \x3c uClipMin.z ||\r\n      aPosition.x \x3e uClipMax.x || aPosition.y \x3e uClipMax.y || aPosition.z \x3e uClipMax.z) {\r\n    gl_Position \x3d vec4(0.0,0.0,0.0,2.0);\r\n    gl_PointSize \x3d 0.0;\r\n    return;\r\n  }\r\n\r\n  if (rejectBySlice(aPosition)) {\r\n    gl_Position \x3d vec4(0.0,0.0,0.0,2.0);\r\n    gl_PointSize \x3d 0.0;\r\n    return;\r\n  }\r\n\r\n  // Position in camera space\r\n  vec4 camera \x3d uModelViewMatrix * vec4(aPosition, 1.0);\r\n\r\n  float pointSize \x3d uPointScale.x;\r\n  vec4 position \x3d uProjectionMatrix * camera;\r\n\r\n  // Calculate Size\r\n#ifdef DRAW_SCREEN_SIZE\r\n    float clampedScreenSize \x3d pointSize;\r\n#else\r\n    float pointRadius \x3d 0.5 * pointSize;\r\n    vec4 cameraOffset \x3d camera + vec4(0.0, pointRadius, 0.0, 0.0);\r\n    vec4 positionOffset \x3d uProjectionMatrix * cameraOffset;\r\n    float radius \x3d abs(positionOffset.y - position.y);\r\n\r\n    float viewHeight \x3d uPointScale.y;\r\n\r\n    // screen diameter \x3d (2 * r / w) * (h / 2)\r\n    float screenPointSize \x3d (radius / position.w) * viewHeight;\r\n    float clampedScreenSize \x3d clamp(screenPointSize, uScreenMinMaxSize.x, uScreenMinMaxSize.y);\r\n\r\n    // Shift towards camera, to move rendered point out of terrain i.e. to\r\n    // the camera-facing end of the virtual point when considering it as a\r\n    // 3D sphere.\r\n    camera.xyz -\x3d normalize(camera.xyz) * pointRadius * clampedScreenSize / screenPointSize;\r\n    position \x3d uProjectionMatrix * camera;\r\n#endif\r\n\r\n  gl_PointSize \x3d clampedScreenSize;\r\n  gl_Position \x3d position;\r\n\r\n#ifdef DEPTH_PASS\r\n  depth \x3d (-camera.z - nearFar[0]) / (nearFar[1] - nearFar[0]);\r\n#else\r\n  vColor \x3d aColor;\r\n#endif\r\n}\r\n"},
renderer:{highlight:{"apply.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\n// \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\r\n// Merging blurred outlines with source image, advanced version\r\n\r\n// Defines:\r\n// GRID_OPTIMIZATION (set or !set)\r\n// GRID_DEBUG (set or !set)\r\n// \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\r\n\r\nuniform sampler2D tex;\r\nuniform sampler2D origin;\r\n\r\nuniform vec4 color;\r\nuniform float outlineSize;\r\nuniform float blurSize;\r\nuniform vec4 opacities; // [outline, outlineOccluded, fill, fillOccluded]\r\n\r\nvarying vec2 uv;\r\n\r\nvoid main() {\r\n  #if defined(GRID_OPTIMIZATION) \x26\x26 defined(GRID_DEBUG)\r\n    gl_FragColor \x3d vec4(uv, 0.0, 1.0);\r\n  #else\r\n    // Read the highlight intensity from the blurred highlight image\r\n    vec4 blurredHighlightValue \x3d texture2D(tex, uv);\r\n    float highlightIntensity \x3d blurredHighlightValue.a;\r\n\r\n    // Discard all pixels which are not affected by highlight\r\n    if (highlightIntensity \x3d\x3d 0.0) {\r\n      discard;\r\n    }\r\n\r\n    vec4 origin_color \x3d texture2D(origin, uv);\r\n\r\n    float outlineIntensity;\r\n    float fillIntensity;\r\n\r\n    // if occluded\r\n    if (blurredHighlightValue.g \x3e blurredHighlightValue.b) {\r\n      outlineIntensity \x3d color.w * opacities[1];\r\n      fillIntensity \x3d color.w * opacities[3];\r\n    }\r\n    // if unoccluded\r\n    else {\r\n      outlineIntensity \x3d color.w * opacities[0];\r\n      fillIntensity \x3d color.w * opacities[2];\r\n    }\r\n\r\n    float inner \x3d 1.0 - outlineSize / 9.0;\r\n    float outer \x3d 1.0 - (outlineSize + blurSize) / 9.0;\r\n\r\n    float outlineFactor \x3d smoothstep(outer, inner, highlightIntensity);\r\n    //float fillFactor \x3d smoothstep(0.6, 0.72, highlightIntensity);\r\n    float fillFactor \x3d any(notEqual(origin_color, vec4(0.0, 0.0, 0.0, 0.0))) ? 1.0 : 0.0;\r\n    float intensity \x3d outlineIntensity * outlineFactor * (1.0 - fillFactor) + fillIntensity * fillFactor;\r\n\r\n    // Blending equation: gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n    // I.e., color should not be premultiplied with alpha\r\n    gl_FragColor \x3d vec4(color.xyz, intensity);\r\n  #endif\r\n}\r\n",
"apply.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nattribute vec2 position;\r\nvarying vec2 uv;\r\n\r\n#ifdef GRID_OPTIMIZATION\r\n  attribute vec2 uv0;\r\n  uniform sampler2D coverageTex;\r\n#endif\r\n\r\nvoid main() {\r\n  #ifdef GRID_OPTIMIZATION\r\n    #ifdef GRID_DEBUG\r\n      vec4 cov \x3d texture2D(coverageTex, uv0);\r\n      // if no highlight pixel set in this block,\r\n      // or all pixels set, hide block\r\n      if (cov.r \x3d\x3d 0.0 || cov.g \x3d\x3d 1.0 || cov.b \x3d\x3d 1.0) {\r\n        gl_Position \x3d vec4(0.0);\r\n        return;\r\n      }\r\n      gl_Position \x3d vec4(position, .0, 1.0);\r\n      uv \x3d uv0;\r\n      return;\r\n    #else\r\n      vec4 cov \x3d texture2D(coverageTex, uv0);\r\n      // if no highlight pixel set in this block, hide block\r\n      if (cov.r \x3d\x3d 0.0) {\r\n        gl_Position \x3d vec4(0.0);\r\n        return;\r\n      }\r\n    #endif\r\n  #endif\r\n\r\n  gl_Position \x3d vec4(position, .0, 1.0);\r\n  uv \x3d position.xy * .5 + vec2(.5);\r\n}\r\n",
"blur.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\n// \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\r\n// Gaussian blur with linear sampling. Supports different number of samples, but\r\n// only 5 samples have proper weights. Uses linear texture interpolation to reduce\r\n// the number of samples taken.\r\n\r\n// Defines:\r\n// GRID_OPTIMIZATION (set or !set)\r\n// GAUSSIAN_SAMPLES (3,5,7)\r\n\r\n// This technique requires linear filtering on source texture\r\n// http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/\r\n// \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\r\n\r\nuniform sampler2D tex;\r\n\r\n#ifdef GRID_OPTIMIZATION\r\n  uniform vec2 blurSize;\r\n  varying vec3 blurCoordinate;\r\n#else\r\n  varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\r\n#endif\r\n\r\nvoid main() {\r\n  #ifdef GRID_OPTIMIZATION\r\n    vec2 uv \x3d blurCoordinate.xy;\r\n    vec4 center \x3d texture2D(tex, uv);\r\n\r\n    // do not blur if no pixel or all pixels in neighborhood are set\r\n    if (blurCoordinate.z \x3d\x3d 1.0) {\r\n      gl_FragColor \x3d center;\r\n    }\r\n    else {\r\n      vec4 sum \x3d vec4(0.0);\r\n\r\n      #if GAUSSIAN_SAMPLES \x3d\x3d 3\r\n        // not proper gaussian weights\r\n        sum +\x3d center * 0.204164;\r\n        sum +\x3d texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\r\n        sum +\x3d texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\r\n      #elif GAUSSIAN_SAMPLES \x3d\x3d 5\r\n        sum +\x3d center * 0.204164;\r\n        sum +\x3d texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\r\n        sum +\x3d texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\r\n        sum +\x3d texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\r\n        sum +\x3d texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\r\n      #elif GAUSSIAN_SAMPLES \x3d\x3d 7\r\n        // not proper gaussian weights\r\n        sum +\x3d center * 0.204164;\r\n        sum +\x3d texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\r\n        sum +\x3d texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\r\n        sum +\x3d texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\r\n        sum +\x3d texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\r\n        sum +\x3d texture2D(tex, uv + blurSize * 5.1) * 0.03;\r\n        sum +\x3d texture2D(tex, uv - blurSize * 5.1) * 0.03;\r\n      #elif GAUSSIAN_SAMPLES \x3d\x3d 9\r\n        // not proper gaussian weights\r\n        sum +\x3d center * 0.154164;\r\n        sum +\x3d texture2D(tex, uv + blurSize * 1.5) * 0.204005;\r\n        sum +\x3d texture2D(tex, uv - blurSize * 1.5) * 0.204005;\r\n        sum +\x3d texture2D(tex, uv + blurSize * 3.5) * 0.123913;\r\n        sum +\x3d texture2D(tex, uv - blurSize * 3.5) * 0.123913;\r\n        sum +\x3d texture2D(tex, uv + blurSize * 5.5) * 0.123913;\r\n        sum +\x3d texture2D(tex, uv - blurSize * 5.5) * 0.123913;\r\n        sum +\x3d texture2D(tex, uv + blurSize * 7.5) * 0.05;\r\n        sum +\x3d texture2D(tex, uv - blurSize * 7.5) * 0.05;\r\n      #endif\r\n\r\n      gl_FragColor \x3d sum;\r\n    }\r\n  #else\r\n    vec4 sum \x3d vec4(0.0);\r\n\r\n    #if GAUSSIAN_SAMPLES \x3d\x3d 3\r\n      // not proper gaussian weights\r\n      sum +\x3d texture2D(tex, blurCoordinates[0]) * 0.204164;\r\n      sum +\x3d texture2D(tex, blurCoordinates[1]) * 0.304005;\r\n      sum +\x3d texture2D(tex, blurCoordinates[2]) * 0.304005;\r\n    #elif GAUSSIAN_SAMPLES \x3d\x3d 5\r\n      sum +\x3d texture2D(tex, blurCoordinates[0]) * 0.204164;\r\n      sum +\x3d texture2D(tex, blurCoordinates[1]) * 0.304005;\r\n      sum +\x3d texture2D(tex, blurCoordinates[2]) * 0.304005;\r\n      sum +\x3d texture2D(tex, blurCoordinates[3]) * 0.093913;\r\n      sum +\x3d texture2D(tex, blurCoordinates[4]) * 0.093913;\r\n    #elif GAUSSIAN_SAMPLES \x3d\x3d 7\r\n      // not proper gaussian weights\r\n      sum +\x3d texture2D(tex, blurCoordinates[0]) * 0.204164;\r\n      sum +\x3d texture2D(tex, blurCoordinates[1]) * 0.304005;\r\n      sum +\x3d texture2D(tex, blurCoordinates[2]) * 0.304005;\r\n      sum +\x3d texture2D(tex, blurCoordinates[3]) * 0.093913;\r\n      sum +\x3d texture2D(tex, blurCoordinates[4]) * 0.093913;\r\n      sum +\x3d texture2D(tex, blurCoordinates[5]) * 0.03;\r\n      sum +\x3d texture2D(tex, blurCoordinates[6]) * 0.03;\r\n    #elif GAUSSIAN_SAMPLES \x3d\x3d 9\r\n      // not proper gaussian weights\r\n      sum +\x3d texture2D(tex, blurCoordinates[0]) * 0.154164;\r\n      sum +\x3d texture2D(tex, blurCoordinates[1]) * 0.204005;\r\n      sum +\x3d texture2D(tex, blurCoordinates[2]) * 0.204005;\r\n      sum +\x3d texture2D(tex, blurCoordinates[3]) * 0.123913;\r\n      sum +\x3d texture2D(tex, blurCoordinates[4]) * 0.123913;\r\n      sum +\x3d texture2D(tex, blurCoordinates[5]) * 0.09;\r\n      sum +\x3d texture2D(tex, blurCoordinates[6]) * 0.09;\r\n      sum +\x3d texture2D(tex, blurCoordinates[7]) * 0.05;\r\n      sum +\x3d texture2D(tex, blurCoordinates[8]) * 0.05;\r\n    #endif\r\n\r\n    gl_FragColor \x3d sum;\r\n  #endif\r\n}\r\n",
"blur.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nattribute vec2 position;\r\nattribute vec2 uv0;\r\n\r\n#ifdef GRID_OPTIMIZATION\r\n  uniform sampler2D coverageTex;\r\n  varying vec3 blurCoordinate;\r\n#else\r\n  uniform vec2 blurSize;\r\n  varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\r\n#endif\r\n\r\nvoid main() {\r\n  gl_Position \x3d vec4(position, 0.0, 1.0);\r\n\r\n  #ifdef GRID_OPTIMIZATION\r\n    // sample the coverage texture at the block center\r\n    // and if no coverage detected, create degenerate triangle\r\n    vec4 cov \x3d texture2D(coverageTex, uv0);\r\n    if (cov.r \x3d\x3d 0.0) {\r\n      gl_Position \x3d vec4(0.0);\r\n    }\r\n\r\n    // create texture coordinate for blur center\r\n    // encode information about fully inside block in z coordinate\r\n    blurCoordinate \x3d vec3(gl_Position.xy * .5 + vec2(.5), max(cov.g, cov.b));\r\n  #else\r\n    vec2 uv \x3d position.xy * .5 + vec2(.5);\r\n\r\n    #if GAUSSIAN_SAMPLES \x3d\x3d 3\r\n      // not proper gaussian weights\r\n      blurCoordinates[0] \x3d uv;\r\n      blurCoordinates[1] \x3d uv + blurSize * 1.407333;\r\n      blurCoordinates[2] \x3d uv - blurSize * 1.407333;\r\n    #elif GAUSSIAN_SAMPLES \x3d\x3d 5\r\n      blurCoordinates[0] \x3d uv;\r\n      blurCoordinates[1] \x3d uv + blurSize * 1.407333;\r\n      blurCoordinates[2] \x3d uv - blurSize * 1.407333;\r\n      blurCoordinates[3] \x3d uv + blurSize * 3.294215;\r\n      blurCoordinates[4] \x3d uv - blurSize * 3.294215;\r\n    #elif GAUSSIAN_SAMPLES \x3d\x3d 7\r\n      // not proper gaussian weights\r\n      blurCoordinates[0] \x3d uv;\r\n      blurCoordinates[1] \x3d uv + blurSize * 1.407333;\r\n      blurCoordinates[2] \x3d uv - blurSize * 1.407333;\r\n      blurCoordinates[3] \x3d uv + blurSize * 3.294215;\r\n      blurCoordinates[4] \x3d uv - blurSize * 3.294215;\r\n      blurCoordinates[5] \x3d uv + blurSize * 5.1;\r\n      blurCoordinates[6] \x3d uv - blurSize * 5.1;\r\n    #elif GAUSSIAN_SAMPLES \x3d\x3d 9\r\n      // not proper gaussian weights\r\n      blurCoordinates[0] \x3d uv;\r\n      blurCoordinates[1] \x3d uv + blurSize * 1.407333;\r\n      blurCoordinates[2] \x3d uv - blurSize * 1.407333;\r\n      blurCoordinates[3] \x3d uv + blurSize * 3.294215;\r\n      blurCoordinates[4] \x3d uv - blurSize * 3.294215;\r\n      blurCoordinates[5] \x3d uv + blurSize * 5.1;\r\n      blurCoordinates[6] \x3d uv - blurSize * 5.1;\r\n      blurCoordinates[7] \x3d uv + blurSize * 7.1;\r\n      blurCoordinates[8] \x3d uv - blurSize * 7.1;\r\n    #endif\r\n  #endif\r\n}\r\n",
"downsample.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\n// \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\r\n// Smartly downsamples a texture, halfing its resolution. This allows for a square\r\n// screen region to check if none, any or all pixels were set.\r\n\r\n// The red channel is always ceiled after interpolating the 4 merged pixels.\r\n// This allows to evaluate:\r\n// any(pixels.red !\x3d 0.0) as red \x3d\x3d 1.0\r\n// none(pixels.red !\x3d 0.0) as red \x3d\x3d 0.0\r\n\r\n// The green and blue channels are set to floor(max(green, blue)).\r\n// This allows to evaluate:\r\n// all(pixels.green || pixels.blue) as green \x3d\x3d 1.0\r\n// \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\r\n\r\nuniform sampler2D tex;\r\nuniform vec2 invFramebufferDim;\r\n\r\nvoid main() {\r\n  vec2 coord \x3d gl_FragCoord.xy * invFramebufferDim;\r\n  vec4 value \x3d texture2D(tex, coord);\r\n  float mx \x3d floor(max(value.g, value.b));\r\n  gl_FragColor \x3d vec4(ceil(value.r), mx, mx, 1.0);\r\n}\r\n",
"downsample.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nattribute vec2 position;\r\n\r\nvoid main() {\r\n  gl_Position \x3d vec4(vec2(1.0) - position * 2.0, .0, 1.0);\r\n}\r\n"},laserLine:{"laserLine.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/encoding.glsl\x3e\r\n\r\n//--------------------------------------------------------------------------\r\n// Uniforms\r\n//--------------------------------------------------------------------------\r\n\r\nuniform sampler2D depthMap;\r\n\r\nuniform vec2 nearFar;\r\nuniform vec4 projInfo;\r\nuniform vec2 zScale;\r\nuniform float maxPixelDistance;\r\n\r\n// focus plane in camera space\r\nuniform vec4 focusPlane;\r\n\r\n// focus sphere in camera space\r\nuniform vec4 focusSphere;\r\n\r\n// segment plane in camera space\r\nuniform vec4 segmentPlane;\r\n\r\n// line segment\r\nuniform vec3 segmentStart;\r\nuniform vec3 segmentEnd;\r\n\r\n// styling\r\nuniform vec3 glowColor;\r\nuniform float glowWidth;\r\nuniform vec3 innerColor;\r\nuniform float innerWidth;\r\nuniform float globalAlpha;\r\n\r\n//--------------------------------------------------------------------------\r\n// Inputs\r\n//--------------------------------------------------------------------------\r\n\r\nvarying vec2 uv;\r\n\r\n//--------------------------------------------------------------------------\r\n// Defines\r\n//--------------------------------------------------------------------------\r\n\r\n#define INFINITY 100000.0\r\n\r\n\r\n\r\n// reconstruct depth value from linear depth map\r\nfloat linearDepth(vec2 uv) {\r\n  return -(rgba2float(texture2D(depthMap, uv)) * (nearFar[1] - nearFar[0]) + nearFar[0]);\r\n}\r\n\r\n// reconstruct position in view space\r\nvec3 reconstructPosition(vec2 fragCoord, float depth) {\r\n  return vec3((fragCoord * projInfo.xy + projInfo.zw) * (zScale.x * depth + zScale.y), depth);\r\n}\r\n\r\nfloat planeDistancePixels(vec4 plane, vec3 pos) {\r\n  // compute distance to plane\r\n  float dist \x3d dot(plane.xyz, pos) + plane.w;\r\n  // compute derivative of distance function with respect to pixels\r\n  float width \x3d fwidth(dist);\r\n  // normalize distance by the derivative to get a measurement with respect to pixels\r\n  // the clamping is used to prevent excessive artifacts along depth discontinuities\r\n  dist /\x3d min(width, maxPixelDistance);\r\n  return abs(dist);\r\n}\r\n\r\nfloat sphereDistancePixels(vec4 sphere, vec3 pos) {\r\n  // compute distance to sphere\r\n  float dist \x3d distance(sphere.xyz, pos) - sphere.w;\r\n  // compute derivative of distance function with respect to pixels\r\n  float width \x3d fwidth(dist);\r\n  // normalize distance by the derivative to get a measurement with respect to pixels\r\n  // the clamping is used to prevent excessive artifacts along depth discontinuities\r\n  dist /\x3d min(width, maxPixelDistance);\r\n  return abs(dist);\r\n}\r\n\r\nvec4 blendPremultiplied(vec4 source, vec4 dest) {\r\n  float oneMinusSourceAlpha \x3d 1.0 - source.a;\r\n\r\n  return vec4(\r\n    source.rgb + dest.rgb * oneMinusSourceAlpha,\r\n    source.a + dest.a * oneMinusSourceAlpha\r\n  );\r\n}\r\n\r\nvec4 premultipliedColor(vec3 rgb, float alpha) {\r\n  return vec4(rgb * alpha, alpha);\r\n}\r\n\r\n// computes laser line color based on distance in pixels\r\nvec4 laserLineProfile(float dist) {\r\n  if (dist \x3e glowWidth) {\r\n    return vec4(0.0);\r\n  }\r\n\r\n  float innerAlpha \x3d (1.0 - smoothstep(0.0, innerWidth, dist));\r\n  float glowAlpha \x3d pow(max(0.0, 1.0 - dist / glowWidth), 8.0);\r\n\r\n  return blendPremultiplied(\r\n    premultipliedColor(innerColor, innerAlpha),\r\n    premultipliedColor(glowColor, glowAlpha)\r\n  );\r\n}\r\n\r\nvoid main() {\r\n  // do not draw laserline on background\r\n  float depth \x3d linearDepth(uv);\r\n  if (-depth \x3d\x3d nearFar[0]) {\r\n    discard;\r\n  }\r\n\r\n  // reconstruct position in view space\r\n  vec3 pos \x3d reconstructPosition(gl_FragCoord.xy, depth);\r\n\r\n  // empirical hack to fade out laser line in problematic areas:\r\n  // the derivatives to normalize the distance function are valid inside smooth surfaces,\r\n  // but break down at depth discontinuities (e.g. edges). We fade out the laser lines in\r\n  // areas where depth valus have large variations in order to avoid this problem.\r\n  float ddepth \x3d fwidth(depth);\r\n  float depthDiscontinuityAlpha \x3d 1.0 - smoothstep(0.0, 0.01, -ddepth / depth);\r\n\r\n  // reconstruct normal using derivatives\r\n  vec3 normal \x3d normalize(cross(dFdx(pos), dFdy(pos)));\r\n\r\n  // distance to focus plane\r\n  float focusPlaneDistance \x3d planeDistancePixels(focusPlane, pos);\r\n\r\n  // distance to focus sphere\r\n  float focusSphereDistance \x3d sphereDistancePixels(focusSphere, pos);\r\n\r\n  // distance to segment plane\r\n  float segmentDistance \x3d INFINITY;\r\n  float segmentLength \x3d length(segmentEnd - segmentStart);\r\n  vec3 segmentDir \x3d (segmentEnd - segmentStart) / segmentLength;\r\n  float t \x3d dot(segmentDir, pos - segmentStart);\r\n\r\n  if (segmentLength \x3e 0.0 \x26\x26 t \x3e\x3d 0.0 \x26\x26 t \x3c\x3d segmentLength) {\r\n    segmentDistance \x3d planeDistancePixels(segmentPlane, pos);\r\n  }\r\n\r\n  // evaluate color profile for both planes and the sphere\r\n  vec4 focusPlaneColor \x3d laserLineProfile(focusPlaneDistance);\r\n  vec4 focusSphereColor \x3d laserLineProfile(focusSphereDistance);\r\n  vec4 segmentColor \x3d laserLineProfile(segmentDistance);\r\n\r\n  // empirical hack to fade out laser line when planes are nearly parallel\r\n  float focusPlaneAlpha \x3d 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, focusPlane.xyz)));\r\n  float focusSphereAlpha \x3d 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, normalize(pos - focusSphere.xyz))));\r\n  float segmentAlpha \x3d 1.0 - smoothstep(0.995, 0.999, abs(dot(normal, segmentPlane.xyz)));\r\n\r\n  // combine colors\r\n  vec4 color \x3d max(\r\n    focusPlaneColor * focusPlaneAlpha,\r\n    max(\r\n      focusSphereColor * focusSphereAlpha,\r\n      segmentColor * segmentAlpha\r\n    )\r\n  );\r\n\r\n  gl_FragColor \x3d color * globalAlpha * depthDiscontinuityAlpha;\r\n}\r\n"},
occluded:{"combine.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nuniform sampler2D occludedColorMap;\r\n\r\nvarying vec2 uv;\r\n\r\nvoid main() {\r\n  vec4 occludedColor \x3d texture2D(occludedColorMap, uv);\r\n  gl_FragColor \x3d occludedColor * vec4(1.0, 1.0, 1.0, 0.4);\r\n}\r\n"},offscreen:{"offscreen.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nuniform sampler2D tex;\r\n\r\nvarying vec2 vtc;\r\n\r\nvoid main() {\r\n  gl_FragColor \x3d texture2D(tex, vtc);\r\n}\r\n","offscreen.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nattribute vec2 position;\r\nvarying vec2 vtc;\r\n\r\nvoid main(void) {\r\n  gl_Position \x3d vec4(position.xy, 0.0, 1.0);\r\n  vtc \x3d position.xy * 0.5 + 0.5;\r\n}\r\n",
"transparentToHUDVisibility.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nuniform sampler2D tex;\r\n\r\nvarying vec2 vtc;\r\n\r\nvoid main() {\r\n  gl_FragColor \x3d vec4(1.0 - texture2D(tex, vtc).a);\r\n}\r\n"},ssao:{"blur.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3crenderer/ssao/common.glsl\x3e\r\n\r\n#ifndef RADIUS\r\n#define RADIUS 4\r\n#endif\r\n\r\nuniform sampler2D normalMap;\r\nuniform sampler2D depthMap;\r\nuniform sampler2D tex;\r\n\r\nuniform vec2 blurSize;\r\n\r\nuniform float g_BlurFalloff;\r\nuniform float projScale;\r\n\r\nuniform vec2    nearFar;\r\n//set z scaling, used to prevent division in ortho mode\r\nuniform vec2 zScale;\r\n\r\nvarying vec2 uv;\r\n\r\nfloat BlurFunction(vec2 uv, float r, float center_d, inout float w_total, float sharpness) {\r\n  float c \x3d texture2D(tex, uv).r;\r\n  float d \x3d getDepthLinear(depthMap, nearFar, uv);\r\n\r\n  float ddiff \x3d d - center_d;\r\n\r\n  float w \x3d exp(-r*r*g_BlurFalloff - ddiff*ddiff*sharpness);\r\n\r\n  w_total +\x3d w;\r\n\r\n  return w*c;\r\n}\r\n\r\nvoid main(void) {\r\n  float b \x3d 0.0;\r\n  float w_total \x3d 0.0;\r\n\r\n  float center_d \x3d  getDepthLinear(depthMap, nearFar, uv);\r\n\r\n  float sharpness \x3d -0.05*projScale/(center_d*zScale.x+zScale.y);\r\n  for (int r \x3d -RADIUS; r \x3c\x3d RADIUS; ++r) {\r\n    float rf \x3d float(r);\r\n    vec2 uvOffset \x3d uv + rf*blurSize;\r\n    b +\x3d BlurFunction(uvOffset, rf, center_d, w_total, sharpness);\r\n  }\r\n\r\n  gl_FragColor \x3d vec4(b/w_total);\r\n}\r\n",
"common.glsl":"#include \x3cutil/encoding.glsl\x3e\r\n\r\nfloat getDepthLinear(sampler2D depthMap, vec2 nearFar, vec2 ssC) {\r\n  return -(rgba2float(texture2D(depthMap, ssC))*(nearFar[1] - nearFar[0])+nearFar[0]);\r\n}\r\n","ssao.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3crenderer/ssao/common.glsl\x3e\r\n\r\n#ifndef SAMPLES\r\n#define SAMPLES 4\r\n#endif\r\n\r\nuniform mat4 projMatrixInv;\r\n\r\nuniform sampler2D normalMap;\r\nuniform sampler2D depthMap;\r\n\r\nuniform float intensity;\r\n\r\nuniform float projScale;\r\nuniform float radius;\r\nuniform vec2 nearFar;\r\nuniform vec4 projInfo;\r\nuniform vec2 screenDimensions;\r\n\r\n//noise texture lookup could be replaced with hash function if WebGL gets XOR functionality\r\nuniform vec3 pSphere[SAMPLES]; //tap position\r\nuniform vec2 rnmScale;\r\nuniform sampler2D rnm; //noise texture\r\n\r\n//set z scaling, used to prevent division in ortho mode\r\nuniform vec2 zScale;\r\n\r\nvarying vec2  uv;\r\nvarying vec4  camPos;\r\n\r\nfloat fallOffFunction(float vv, float vn, float bias) {\r\n  float radius2 \x3d radius * radius;\r\n\r\n  // A: From the HPG12 paper\r\n  // Note large epsilon to avoid overdarkening within cracks\r\n  // return float(vv \x3c radius2) * max((vn - bias) / (epsilon + vv), 0.0) * radius2 * 0.6;\r\n\r\n  // B: Smoother transition to zero (lowers contrast, smoothing out corners). [Recommended]\r\n  float f \x3d max(radius2 - vv, 0.0); return f * f * f * max(vn-bias, 0.0);\r\n\r\n  // C: Medium contrast (which looks better at high radii), no division.  Note that the\r\n  // contribution still falls off with radius^2, but we've adjusted the rate in a way that is\r\n  // more computationally efficient and happens to be aesthetically pleasing.\r\n  // return 4.0 * max(1.0 - vv * invRadius2, 0.0) * max(vn - bias, 0.0);\r\n\r\n  // D: Low contrast, no division operation\r\n  // return 2.0 * float(vv \x3c radius * radius) * max(vn - bias, 0.0);\r\n}\r\n\r\n\r\n/** Compute the occlusion due to sample point \\a Q about camera-space point \\a C with unit normal \\a n_C */\r\nfloat aoValueFromPositionsAndNormal(vec3 C, vec3 n_C, vec3 Q) {\r\n  vec3 v \x3d Q - C;\r\n  float vv \x3d dot(v, v);\r\n  float vn \x3d dot(normalize(v), n_C);\r\n  return fallOffFunction(vv, vn, 0.1);\r\n}\r\n\r\n\r\n/**\r\n * Reconstruct camera-space P.xyz from screen-space S \x3d (x, y) in\r\n * pixels and camera-space z \x3c 0.  Assumes that the upper-left pixel center\r\n * is at (0.5, 0.5) [but that need not be the location at which the sample tap\r\n * was placed!]\r\n *\r\n * Costs 3 MADD.  Error is on the order of 10^3 at the far plane, partly due to z precision.\r\n */\r\nvec3 reconstructCSPosition(vec2 S, float z) {\r\n  return vec3(( (S.xy) * projInfo.xy + projInfo.zw)*(z*zScale.x+zScale.y), z);\r\n}\r\n\r\nvoid main(void) {\r\n  //Hash function used in the HPG12 AlchemyAO paper\r\n  //Not supported in WebGL -\x3e using texture lookup as in old SSAO shader instead\r\n  //ivec2 ssC \x3d ivec2(gl_FragCoord.xy);\r\n  //float randomPatternRotationAngle \x3d float((3 * ssC.x ^ ssC.y + ssC.x * ssC.y) * 10);\r\n  vec3 fres \x3d normalize((texture2D(rnm, uv * rnmScale).xyz * 2.0) - vec3(1.0));\r\n\r\n  float currentPixelDepth \x3d getDepthLinear(depthMap, nearFar, uv);\r\n\r\n  if (-currentPixelDepth\x3enearFar.y || -currentPixelDepth\x3cnearFar.x) {\r\n    gl_FragColor \x3d vec4(0.0);\r\n    return;\r\n  }\r\n\r\n  vec3 currentPixelPos \x3d reconstructCSPosition(gl_FragCoord.xy,currentPixelDepth);\r\n\r\n  // get the normal of current fragment\r\n  vec4 norm4 \x3d texture2D(normalMap, uv);\r\n  vec3 norm \x3d vec3(-1.0) + 2.0 * norm4.xyz;\r\n  bool isTerrain \x3d norm4.w\x3c0.5;\r\n\r\n  float sum \x3d .0;\r\n\r\n  vec4 occluderFragment;\r\n  vec3 ray;\r\n\r\n  vec3 tapPixelPos;\r\n\r\n  // note: the factor 2.0 should not be necessary, but makes ssao much nicer.\r\n  // bug or deviation from CE somewhere else?\r\n  float ps \x3d projScale/(2.0*currentPixelPos.z*zScale.x+zScale.y);\r\n\r\n  for(int i \x3d 0; i \x3c SAMPLES; ++i) {\r\n    // get a vector (randomized inside of a sphere with radius 1.0) from a texture and reflect it\r\n    //float ssR;\r\n    //vec2 unitOffset \x3d tapLocation(i, randomPatternRotationAngle, ssR);\r\n    // get the depth of the occluder fragment\r\n    //vec2 offset \x3d vec2(-unitOffset*radius*ssR*ps);\r\n\r\n    vec2 unitOffset \x3d reflect(pSphere[i], fres).xy;\r\n    vec2 offset \x3d vec2(-unitOffset*radius*ps);\r\n\r\n    //don't use current or very nearby samples\r\n    if ( abs(offset.x)\x3c2.0 || abs(offset.y)\x3c2.0) continue;\r\n\r\n    vec2 tc \x3d vec2(gl_FragCoord.xy + offset);\r\n    if (tc.x \x3c 0.0 || tc.y \x3c 0.0 || tc.x \x3e screenDimensions.x || tc.y \x3e screenDimensions.y) continue;\r\n    vec2 tcTap \x3d tc/screenDimensions;\r\n    float occluderFragmentDepth \x3d getDepthLinear(depthMap, nearFar, tcTap);\r\n\r\n    if (isTerrain) {\r\n      bool isTerrainTap \x3d texture2D(normalMap, tcTap).w\x3c0.5;\r\n      if (isTerrainTap) {\r\n        continue;\r\n      }\r\n    }\r\n\r\n    tapPixelPos \x3d reconstructCSPosition(tc, occluderFragmentDepth);\r\n\r\n    sum+\x3d aoValueFromPositionsAndNormal(currentPixelPos, norm, tapPixelPos);\r\n  }\r\n\r\n  // output the result\r\n\r\n  float A \x3d max(1.0-sum*intensity/float(SAMPLES),0.0);\r\n\r\n  // Anti-tone map to reduce contrast and drag dark region farther\r\n  // (x^0.2 + 1.2 * x^4)/2.2\r\n  A \x3d (pow(A, 0.2) + 1.2 * A*A*A*A) / 2.2;\r\n\r\n  //gl_FragColor \x3d vec4(norm/2.0+0.5, 1.0);\r\n  //gl_FragColor \x3d vec4(-currentPixelDepth/1000.0);\r\n  //gl_FragColor \x3d vec4(tapPixelPos.x/100.0);\r\n  gl_FragColor \x3d vec4(A);\r\n}\r\n"}},
terrainRenderer:{"colorPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/sceneLighting.glsl\x3e\r\n#include \x3cutil/screenSizePerspective.glsl\x3e\r\n#include \x3cutil/shadow.glsl\x3e\r\n#include \x3cutil/slice.glsl\x3e\r\n#include \x3cterrainRenderer/overlay.glsl\x3e\r\n\r\nuniform vec3 lightDirection;\r\nuniform vec3 viewDirection;\r\nuniform sampler2D depthTex;\r\nuniform int shadowMapNum;\r\nuniform vec4 shadowMapDistance;\r\nuniform mat4 shadowMapMatrix[4];\r\nuniform float depthHalfPixelSz;\r\nuniform sampler2D ssaoTex;\r\nuniform vec4 viewportPixelSz;\r\nuniform sampler2D tex;\r\nuniform float opacity;\r\n\r\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\r\nstruct WireframeSettings {\r\n  float width;\r\n  float falloff;\r\n  float subdivision;\r\n  vec4 color;\r\n  float wireOpacity;\r\n  float surfaceOpacity;\r\n};\r\n\r\nuniform WireframeSettings wireframe;\r\n#endif\r\n\r\nvarying vec3 vnormal;\r\nvarying vec3 vpos;\r\nvarying vec2 vtc;\r\n\r\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\r\nvarying vec2 vuv;\r\n#endif\r\n\r\n#ifdef ATMOSPHERE\r\nvarying vec3 wpos;\r\nvarying vec3 wview;\r\nvarying vec3 wnormal;\r\nvarying vec3 wlight;\r\n#endif\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE /* debug only */\r\nuniform vec4 screenSizePerspective;\r\n\r\nvarying float screenSizeDistanceToCamera;\r\nvarying float screenSizeCosAngle;\r\n#endif\r\n\r\nconst vec3 ambient \x3d vec3(0.2,0.2,0.2);\r\nconst vec3 diffuse \x3d vec3(0.8,0.8,0.8);\r\nconst float diffuseHardness \x3d 2.5;\r\nconst float sliceOpacity \x3d 0.2;\r\n\r\n#ifdef OVERLAY\r\nuniform sampler2D overlay0Tex;\r\nuniform sampler2D overlay1Tex;\r\nuniform float overlayOpacity;\r\nvarying vec4 vtcOverlay;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOWS\r\nvarying float linearDepth;\r\n#endif\r\n\r\nfloat lum(vec3 c) {\r\n  float max \x3d max(max(c.r, c.g), c.b);\r\n  float min \x3d min(min(c.r, c.g), c.b);\r\n  return (min + max) * 0.5;\r\n}\r\n\r\n#ifdef ATMOSPHERE\r\nvec3 atmosphere(vec3 lightPos, vec3 normal, vec3 view) {\r\n  vec3 surfaceColor   \x3d vec3(0.0);\r\n  vec3 fuzzySpecColor \x3d vec3(1.0);\r\n  vec3 subColor       \x3d vec3(0.0);\r\n  float rollOff       \x3d 1.0;\r\n\r\n  vec3 Ln \x3d normalize(lightPos);\r\n  vec3 Nn \x3d normalize(normal);\r\n  vec3 Hn \x3d normalize(view + Ln);\r\n\r\n  float ldn \x3d dot(Ln, Nn);\r\n  float diffComp \x3d max(0.0, ldn);\r\n  float vdn \x3d 1.0 - dot(view, Nn);\r\n  float ndv \x3d dot(view, Ln);\r\n\r\n  vec3 diffContrib \x3d surfaceColor * diffComp;\r\n  float subLamb \x3d max(0.0, smoothstep(-rollOff, 1.0, ldn) - smoothstep(0.0, 1.0, ldn));\r\n\r\n  vec3 subContrib \x3d subLamb * subColor;\r\n  vec3 vecColor \x3d vec3(vdn);\r\n\r\n  vec3 diffuseContrib \x3d (subContrib + diffContrib);\r\n  vec3 specularContrib \x3d (vecColor * fuzzySpecColor);\r\n\r\n  return (diffContrib + specularContrib) * rollOff;\r\n}\r\n#endif\r\n\r\nvoid main() {\r\n  vec3 a \x3d ambient;\r\n\r\n  float shadow \x3d 0.0;\r\n#ifdef RECEIVE_SHADOWS\r\n  shadow \x3d evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\r\n#endif\r\n  float vndl \x3d dot(normalize(vnormal), lightDirection);\r\n  float k \x3d smoothstep(0.0, 1.0, clamp(vndl*diffuseHardness, 0.0, 1.0));\r\n  vec3 d \x3d (1.0 - shadow/1.8) * diffuse * k;\r\n\r\n  float ssao \x3d viewportPixelSz.w \x3c .0 ? 1.0 : texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\r\n\r\n  vec4 tileColor \x3d texture2D(tex, vtc) * opacity;\r\n\r\n#ifdef OVERLAY\r\n  vec4 overlayColor \x3d getOverlayColor(overlay0Tex, overlay1Tex, vtcOverlay, overlayOpacity);\r\n\r\n  // tileColor and overlayTexCols have pre-multiplied alpha\r\n  tileColor \x3d tileColor * (1.0 - overlayColor.a) + overlayColor;\r\n#endif\r\n\r\n  if (rejectBySlice(vpos)) {\r\n    tileColor *\x3d sliceOpacity;\r\n  }\r\n\r\n  vec3 atm \x3d vec3(0.0);\r\n#ifdef ATMOSPHERE\r\n  float ndotl \x3d max(0.0, min(1.0, vndl));\r\n  atm \x3d atmosphere(wlight, wnormal, -viewDirection);\r\n  atm *\x3d max(0.0, min(1.0, (1.0-lum(tileColor.rgb)*1.5))); //avoid atmosphere on bright base maps\r\n  atm *\x3d max(0.0, min(1.0, ndotl*2.0)); // avoid atmosphere on dark side of the globe\r\n  atm *\x3d tileColor.a; // premultiply with tile alpha\r\n#endif\r\n\r\n  vec3 albedo \x3d atm + tileColor.rgb;\r\n  vec3 normal \x3d normalize(vnormal);\r\n\r\n  // heuristic shading function used in the old terrain, now used to add ambient lighting\r\n  float additionalAmbientScale \x3d smoothstep(0.0, 1.0, clamp(vndl*2.5, 0.0, 1.0));\r\n  vec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\r\n\r\n  gl_FragColor \x3d vec4(evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight), tileColor.a);\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE /* debug only */\r\n  // This is only used for debug rendering the screenSize perspective\r\n\r\n  float perspectiveScale \x3d screenSizePerspectiveScaleFloat(1.0, screenSizeCosAngle, screenSizeDistanceToCamera, screenSizePerspective);\r\n\r\n  if (perspectiveScale \x3c\x3d 0.25) {\r\n    gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), perspectiveScale * 4.0);\r\n  }\r\n  else if (perspectiveScale \x3c\x3d 0.5) {\r\n    gl_FragColor \x3d mix(gl_FragColor, vec4(0.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.25) * 4.0);\r\n  }\r\n  else if (perspectiveScale \x3e\x3d 0.99) {\r\n    gl_FragColor \x3d mix(gl_FragColor, vec4(0.0, 1.0, 0.0, 1.0), 0.2);\r\n  }\r\n  else {\r\n    gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), (perspectiveScale - 0.5) * 2.0);\r\n  }\r\n\r\n#endif\r\n\r\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\r\n\r\n  vec2 vuvScaled \x3d vuv * wireframe.subdivision;\r\n  vec2 vuvMod \x3d fract(vuvScaled);\r\n\r\n  vec2 dVuv \x3d fwidth(vuvScaled);\r\n  dVuv \x3d max(vec2(0.00001), dVuv); // workaround against flickering skirts, see #10245\r\n\r\n  vec2 edgeFactors \x3d smoothstep((wireframe.width - wireframe.falloff) * dVuv,\r\n                                wireframe.width * dVuv, min(vuvMod, 1.0 - vuvMod));\r\n\r\n  float edgeFactor \x3d 1.0 - min(edgeFactors.x, edgeFactors.y);\r\n\r\n#ifdef WIREFRAME_TEXTURE\r\n  vec3 wireframeColor \x3d mix(gl_FragColor.rgb, wireframe.color.rgb, edgeFactor * wireframe.color.a);\r\n  float wireframeAlpha \x3d mix(wireframe.surfaceOpacity, wireframe.wireOpacity, edgeFactor);\r\n  gl_FragColor \x3d vec4(wireframeColor * wireframeAlpha, wireframeAlpha * gl_FragColor.a);\r\n#endif\r\n\r\n\r\n#ifdef TILE_BORDERS\r\n  dVuv \x3d fwidth(vuv);\r\n  edgeFactors \x3d smoothstep((wireframe.width - wireframe.falloff) * dVuv,\r\n                            wireframe.width * dVuv, min(vuv, 1.0 - vuv));\r\n  edgeFactor \x3d 1.0 - min(edgeFactors.x, edgeFactors.y);\r\n\r\n  gl_FragColor \x3d mix(gl_FragColor, vec4(1.0, 0.0, 0.0, 1.0), edgeFactor);\r\n#endif\r\n\r\n#endif // defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\r\n\r\n  gl_FragColor \x3d highlightSlice(gl_FragColor, vpos);\r\n}\r\n",
"colorPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n#include \x3cterrainRenderer/skirts.glsl\x3e\r\n\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform vec3 origin;\r\nuniform vec4 texOffsetAndScale;\r\nuniform mat4 viewNormal;\r\nuniform float skirtScale;\r\n\r\nattribute vec3 position;\r\nattribute vec2 uv0;\r\n\r\nvarying vec3 vnormal;\r\nvarying vec3 vpos;\r\nvarying vec2 vtc;\r\n\r\n#ifdef RECEIVE_SHADOWS\r\nvarying float linearDepth;\r\n#endif\r\n\r\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\r\nvarying vec2 vuv;\r\n#endif\r\n\r\n#ifdef ATMOSPHERE\r\nuniform vec3 lightDirection;\r\nvarying vec3 wpos;\r\nvarying vec3 wview;\r\nvarying vec3 wnormal;\r\nvarying vec3 wlight;\r\n#endif\r\n\r\n#ifdef OVERLAY\r\n// these variables combine two possible overlays into one by using a vec4:\r\n// components x/y are x/y of overlay 0, and components z/w are x/y of overlay 1\r\nuniform vec4 overlayTexOffset;\r\nuniform vec4 overlayTexScale;\r\nvarying vec4 vtcOverlay;\r\n#endif\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE /* debug only */\r\n\r\nuniform vec4 screenSizePerspective;\r\n\r\nvarying float screenSizeDistanceToCamera;\r\nvarying float screenSizeCosAngle;\r\n\r\n#endif\r\n\r\nvoid main(void) {\r\n  vpos \x3d position;\r\n\r\n#ifdef SPHERICAL\r\n  vnormal \x3d normalize(vpos + origin);\r\n#else\r\n  vnormal \x3d vec3(0.0, 0.0, 1.0); // WARNING: up-axis dependent code\r\n#endif\r\n\r\nvec2 uv \x3d uv0;\r\nvpos \x3d applySkirts(uv, vpos, vnormal, skirtScale);\r\n\r\n#ifdef ATMOSPHERE\r\n  wpos \x3d (view * vec4(vpos, 1.0)).xyz;\r\n  wnormal \x3d (viewNormal * vec4(normalize(vpos+origin), 1.0)).xyz;\r\n  wlight \x3d (view  * vec4(lightDirection, 1.0)).xyz;\r\n#endif\r\n\r\n#if defined(WIREFRAME_TEXTURE) || defined(TILE_BORDERS)\r\n  vuv \x3d uv;\r\n#endif\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE /* debug only */\r\n\r\n  vec3 viewPos \x3d (view * vec4(vpos, 1.0)).xyz;\r\n\r\n  screenSizeDistanceToCamera \x3d length(viewPos);\r\n\r\n  vec3 viewSpaceNormal \x3d (viewNormal * vec4(normalize(vpos + origin), 1.0)).xyz;\r\n  screenSizeCosAngle \x3d abs(viewSpaceNormal.z);\r\n\r\n#endif\r\n\r\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n  // Shadowmap's cascading index used to be based on '1.0 / gl_FragCoord.w'\r\n  // (i.e. the perspective interpolation of 'gl_Position.w'). Precision\r\n  // issues on iPad/iPhone with the 'w' component require the depth to be\r\n  // passed as varying to properly drive the cascading shadow map index.\r\n  linearDepth \x3d gl_Position.w;\r\n#endif\r\n\r\n  vtc \x3d uv * texOffsetAndScale.zw + texOffsetAndScale.xy;\r\n\r\n#ifdef OVERLAY\r\n  vtcOverlay \x3d vec4(uv, uv) * overlayTexScale + overlayTexOffset;\r\n#endif\r\n}\r\n",
"depthPass.frag":"#include \x3cutil/enableExtensions.glsl\x3e\r\n#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/encoding.glsl\x3e\r\n#include \x3cutil/depth.glsl\x3e\r\n\r\nvarying float depth;\r\nvarying vec3 vpos;\r\n\r\nvoid main() {\r\n#ifndef BIAS_SHADOWMAP\r\n  gl_FragColor \x3d float2rgba(depth);\r\n#else\r\n  gl_FragColor \x3d float2rgba(calcFragDepth(depth));\r\n#endif\r\n}\r\n","depthPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n#include \x3cterrainRenderer/skirts.glsl\x3e\r\n\r\nuniform vec3 origin;\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform vec2 nearFar;\r\nuniform float skirtScale;\r\n\r\nattribute vec3 position;\r\nattribute vec2 uv0;\r\n\r\nvarying float depth;\r\nvarying vec3 vpos;\r\n\r\nvoid main(void) {\r\n#ifdef SPHERICAL\r\n  vec3 normal \x3d normalize(position + origin);\r\n#else\r\n  vec3 normal \x3d vec3(0.0, 0.0, 1.0);\r\n#endif\r\n\r\n  vec2 uv \x3d uv0;\r\n  vpos \x3d applySkirts(uv, position, normal.xyz, skirtScale);\r\n\r\n  vec4 eye \x3d view * vec4(vpos, 1.0);\r\n  gl_Position \x3d proj * eye;\r\n  depth \x3d (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\r\n}\r\n",
"highlightPass.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n#include \x3cutil/highlight.glsl\x3e\r\n#include \x3cterrainRenderer/overlay.glsl\x3e\r\n\r\nuniform sampler2D overlay0Tex;\r\nuniform sampler2D overlay1Tex;\r\nuniform float overlayOpacity;\r\n\r\nuniform sampler2D depthTex;\r\nuniform vec4 highlightViewportPixelSz;\r\n\r\nvarying vec4 vtcOverlay;\r\n\r\nvoid main() {\r\n  vec4 overlayColor \x3d getOverlayColor(overlay0Tex, overlay1Tex, vtcOverlay, overlayOpacity);\r\n\r\n  if (overlayColor.a \x3d\x3d 0.0) {\r\n    // Here we have to write black, instead of discarding the fragment in order to overwrite\r\n    // the highlights which might have been written by skirts of other tiles.\r\n    // As a consequence skirts are not visible, but terrain overwrites draped highlights.\r\n    gl_FragColor \x3d vec4(0.0);\r\n    return;\r\n  }\r\n\r\n  gl_FragColor \x3d highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\r\n}\r\n",
"highlightPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n#include \x3cterrainRenderer/skirts.glsl\x3e\r\n\r\nuniform vec3 origin;\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform vec4 overlayTexScale;\r\nuniform vec4 overlayTexOffset;\r\nuniform float skirtScale;\r\n\r\nattribute vec3 position;\r\nattribute vec2 uv0;\r\n\r\nvarying vec3 vpos;\r\nvarying vec4 vtcOverlay;\r\n\r\nvoid main() {\r\n  #ifdef SPHERICAL\r\n    vec3 vnormal \x3d normalize(position + origin);\r\n  #else\r\n    vec3 vnormal \x3d vec3(0.0, 0.0, 1.0); // WARNING: up-axis dependent code\r\n  #endif\r\n\r\n  vec2 uv \x3d uv0;\r\n  vpos \x3d applySkirts(uv, position, vnormal, skirtScale);\r\n\r\n  vtcOverlay \x3d vec4(uv, uv) * overlayTexScale + overlayTexOffset;\r\n\r\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n}\r\n",
"normalPass.frag":"#include \x3cutil/fsPrecision.glsl\x3e\r\n\r\nvarying vec3 vnormal;\r\nvarying vec3 vpos;\r\n\r\nvoid main() {\r\n  vec3 normal \x3d normalize(vnormal);\r\n  if (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\r\n\r\n#ifndef ALPHA_ZERO\r\n  gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\r\n#else\r\n  gl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\r\n#endif\r\n}\r\n","normalPass.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n#include \x3cterrainRenderer/skirts.glsl\x3e\r\n\r\nuniform vec3 origin;\r\nuniform mat4 proj;\r\nuniform mat4 view;\r\nuniform mat4 viewNormal;\r\nuniform float skirtScale;\r\n\r\nattribute vec3 position;\r\nattribute vec2 uv0;\r\n\r\nvarying vec3 vnormal;\r\nvarying vec3 vpos;\r\n\r\nvoid main(void) {\r\n#ifdef SPHERICAL\r\n  vec4 normal \x3d vec4(normalize(position + origin), 1.0);\r\n#else\r\n  vec4 normal \x3d vec4(0.0, 0.0, 1.0, 1.0);\r\n#endif\r\n\r\n  vec2 uv \x3d uv0;\r\n  vpos \x3d applySkirts(uv, position, normal.xyz, skirtScale);\r\n\r\n  gl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n  vnormal \x3d normalize((viewNormal * normal).xyz);\r\n}\r\n",
"overlay.glsl":"vec4 getOverlayColor(sampler2D overlay0Tex, sampler2D overlay1Tex, vec4 texCoords, float opacity) {\r\n  vec4 color \x3d vec4(0.0);\r\n\r\n  if ((texCoords.x \x3e 0.0) \x26\x26 (texCoords.x \x3c 1.0) \x26\x26 (texCoords.y \x3e 0.0) \x26\x26 (texCoords.y \x3c 1.0)) {\r\n    // inner overlay texture coordinates are within bounds -\x3e sample from inner overlay\r\n    color \x3d texture2D(overlay0Tex, texCoords.xy);\r\n  } else if ((texCoords.z \x3e 0.0) \x26\x26 (texCoords.z \x3c 1.0) \x26\x26 (texCoords.w \x3e 0.0) \x26\x26 (texCoords.w \x3c 1.0)) {\r\n    // sample from outer overlay\r\n    color \x3d texture2D(overlay1Tex, texCoords.zw);\r\n  }\r\n\r\n  return color * opacity;\r\n}\r\n",
"skirts.glsl":'vec3 applySkirts(inout vec2 uv, vec3 vpos, vec3 vnormal, float skirtScale) {\r\n  float skirtLength \x3d 0.0;\r\n\r\n  if (uv.x \x3e\x3d 2.0) {\r\n    skirtLength \x3d uv.y * skirtScale;\r\n    // decode original uv-coordinates (see "encodeSkirtPos")\r\n    vec2 x \x3d vec2(uv.x) - vec2(3.5, 4.5);\r\n    uv \x3d clamp(vec2(1.5) - abs(x), vec2(0.0), vec2(1.0));\r\n  }\r\n\r\n  return vpos - vnormal * skirtLength;\r\n}\r\n'},util:{"alignPixel.glsl":"vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {\r\n  // From clip space to (0 : 1), bias towards right pixel edge\r\n  vec2 xy \x3d vec2(.500123) + .5 * clipCoord.xy / clipCoord.w;\r\n\r\n  // Size of a pixel in range (0 : 1)\r\n  vec2 pixelSz \x3d vec2(1.0) / widthHeight;\r\n\r\n  // Round to nearest pixel center\r\n  vec2 ij \x3d (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;\r\n\r\n  // Convert back to clip space\r\n  vec2 result \x3d (ij * 2.0 - vec2(1.0)) * clipCoord.w;\r\n\r\n  return vec4(result, clipCoord.zw);\r\n}\r\n\r\nvec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\r\n  // From clip space to (0 : 1),\r\n  vec2 xy \x3d vec2(.5) + .5 * clipCoord.xy / clipCoord.w;\r\n\r\n  // Size of a pixel in range (0 : 1)\r\n  vec2 pixelSz \x3d vec2(1.0) / widthHeight;\r\n\r\n  // Round to nearest pixel border, (0 : 1)\r\n  vec2 ij \x3d floor((xy + .5 * pixelSz) * widthHeight) * pixelSz;\r\n\r\n  // Convert back to clip space\r\n  vec2 result \x3d (ij * 2.0 - vec2(1.0)) * clipCoord.w;\r\n\r\n  return vec4(result, clipCoord.zw);\r\n}\r\n",
"color.glsl":"vec4 premultiplyAlpha(vec4 v) {\r\n  return vec4(v.rgb * v.a, v.a);\r\n}\r\n\r\nvec3 rgb2hsv(vec3 c) {\r\n  vec4 K \x3d vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\r\n  vec4 p \x3d mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\r\n  vec4 q \x3d mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\r\n\r\n  float d \x3d q.x - min(q.w, q.y);\r\n  float e \x3d 1.0e-10;\r\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\r\n}\r\n\r\nvec3 hsv2rgb(vec3 c) {\r\n  vec4 K \x3d vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n  vec3 p \x3d abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n",
"depth.glsl":"float calcFragDepth(const in float depth) {\r\n  //calc polygon offset\r\n  const float SLOPE_SCALE \x3d 2.0;\r\n  const float BIAS \x3d 2.0 * .000015259;    // 1 / (2^16 - 1)\r\n  float m \x3d max(abs(dFdx(depth)), abs(dFdy(depth)));\r\n  float result \x3d depth + SLOPE_SCALE * m + BIAS;\r\n  return clamp(result, .0, .999999);\r\n}\r\n","doublePrecision.glsl":"// based on https://www.thasler.com/blog/blog/glsl-part2-emu\r\nvec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {\r\n  vec3 t1 \x3d hiA + hiB;\r\n  vec3 e \x3d t1 - hiA;\r\n  vec3 t2 \x3d ((hiB - e) + (hiA - (t1 - e))) + loA + loB;\r\n  return t1 + t2;\r\n}\r\n",
"enableExtensions.glsl":"#define EXTENSIONS_ENABLED\r\n#extension GL_OES_standard_derivatives : enable\r\n#extension GL_EXT_shader_texture_lod : enable\r\n","encoding.glsl":"// This is the maximum float value representable as 32bit fixed point,\r\n// it is rgba2float(vec4(1)) inlined.\r\nconst float MAX_RGBA_FLOAT \x3d\r\n  255.0 / 256.0 +\r\n  255.0 / 256.0 / 256.0 +\r\n  255.0 / 256.0 / 256.0 / 256.0 +\r\n  255.0 / 256.0 / 256.0 / 256.0 / 256.0;\r\n\r\n// Factors to convert to fixed point, i.e. factors (256^0, 256^1, 256^2, 256^3)\r\nconst vec4 fixedPointFactors \x3d vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);\r\n\r\nvec4 float2rgba(const float value) {\r\n  // Make sure value is in the domain we can represent\r\n  float valueInValidDomain \x3d clamp(value, 0.0, MAX_RGBA_FLOAT);\r\n\r\n  // Decompose value in 32bit fixed point parts represented as\r\n  // uint8 rgba components. Decomposition uses the fractional part after multiplying\r\n  // by a power of 256 (this removes the bits that are represented in the previous\r\n  // component) and then converts the fractional part to 8bits.\r\n  vec4 fixedPointU8 \x3d floor(fract(valueInValidDomain * fixedPointFactors) * 256.0);\r\n\r\n  // Convert uint8 values (from 0 to 255) to floating point representation for\r\n  // the shader\r\n  const float toU8AsFloat \x3d 1.0 / 255.0;\r\n\r\n  return fixedPointU8 * toU8AsFloat;\r\n}\r\n\r\n// Factors to convert rgba back to float\r\nconst vec4 rgba2float_factors \x3d vec4(\r\n  255.0 / (256.0),\r\n  255.0 / (256.0 * 256.0),\r\n  255.0 / (256.0 * 256.0 * 256.0),\r\n  255.0 / (256.0 * 256.0 * 256.0 * 256.0)\r\n);\r\n\r\nfloat rgba2float(vec4 rgba) {\r\n  // Convert components from 0-\x3e1 back to 0-\x3e255 and then\r\n  // add the components together with their corresponding\r\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\r\n  return dot(rgba, rgba2float_factors);\r\n}\r\n",
"fsPrecision.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\nprecision highp sampler2D;\r\n#else\r\nprecision mediump float;\r\nprecision mediump sampler2D;\r\n#endif\r\n","highlight.glsl":"vec4 highlightData(vec4 fragCoord, sampler2D depthTex, vec4 viewportPixelSize) {\r\n  float sceneDepth \x3d texture2D(depthTex, (fragCoord.xy - viewportPixelSize.xy) * viewportPixelSize.zw).r;\r\n  if (fragCoord.z \x3e sceneDepth + 5e-6) {\r\n    return vec4(1.0, 1.0, 0.0, 1.0);\r\n  }\r\n  else {\r\n    return vec4(1.0, 0.0, 1.0, 1.0);\r\n  }\r\n}\r\n",
"hud.glsl":"#include \x3cutil/screenSizePerspective.glsl\x3e\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec4 auxpos1;\r\n\r\nuniform mat4 proj;\r\n\r\nuniform mat4 view;\r\nuniform mat4 viewNormal;\r\n\r\nuniform mat4 model;\r\nuniform mat4 modelNormal;\r\n\r\nuniform vec4 viewport;\r\n\r\nuniform vec3 camPos;\r\n\r\nuniform float polygonOffset;\r\nuniform float cameraGroundRelative;\r\nuniform float pixelRatio;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n\r\n// [ screenLength, distanceFactor, minWorldLength, maxWorldLength ]\r\nuniform vec4 verticalOffset;\r\n\r\n#endif\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n\r\n// [ divisor, offset, minPixelSize, paddingPixels ]\r\nuniform vec4 screenSizePerspectiveAlignment;\r\n\r\n#endif\r\n\r\nuniform sampler2D hudVisibilityTexture;\r\n\r\n\r\n// Corresponds to cos(10 deg), used to compare against dot product of two vectors\r\nconst float SMALL_OFFSET_ANGLE \x3d 0.984807753012208;\r\n\r\nstruct ProjectHUDAux {\r\n  vec3 posModel;\r\n  vec3 posView;\r\n  vec3 vnormal;\r\n\r\n  float distanceToCamera;\r\n  float absCosAngle;\r\n};\r\n\r\n\r\n/**\r\n  * Apply the simulated polygon offset for HUD objects that improves\r\n  * issues with Z-fighting.\r\n  *\r\n  * @param posView {vec3} (inout) the position in view space. Will be modified in place.\r\n  * @param pointGroundDistance {float} the distance from the point geometry to the ground surface.\r\n  * @param absCosAngle {float} the absolute cosine of the angle between the world-up at the point geometry\r\n  *   and the view direction.\r\n  *\r\n  * Dependencies:\r\n  *\r\n  *   Attributes:\r\n  *     - auxpos1: contains centerOffset and pointGroundDistance\r\n  *\r\n  *   Uniforms:\r\n  *     - cameraGroundRelative: indicates whether camera is above (1) or below (-1) ground.\r\n  *         This is used for emulated polygon offset for improved visibility of points sitting on the surface.\r\n  *     - polygonOffset: a constant polygon offset to bring the point closer to the viewer for\r\n  *         reduced flickering.\r\n  *     - viewport: the viewport [x, y, width, height]\r\n  */\r\nfloat applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\r\n  float pointGroundSign \x3d sign(pointGroundDistance);\r\n\r\n  if (pointGroundSign \x3d\x3d 0.0) {\r\n    pointGroundSign \x3d 1.0;\r\n  }\r\n\r\n  // cameraGroundRelative is -1 if camera is below ground, 1 if above ground\r\n  // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise\r\n  float groundRelative \x3d cameraGroundRelative * pointGroundSign;\r\n\r\n  // view angle dependent part of polygon offset emulation\r\n  // we take the absolute value because the sign that is dropped is\r\n  // instead introduced using the ground-relative position of the symbol and the camera\r\n  if (polygonOffset \x3e .0) {\r\n    float cosAlpha \x3d clamp(absCosAngle, 0.01, 1.0);\r\n\r\n    float tanAlpha \x3d sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\r\n    float factor \x3d (1.0 - tanAlpha / viewport[2]);\r\n\r\n    // same side of the terrain\r\n    if (groundRelative \x3e 0.0) {\r\n      posView *\x3d factor;\r\n    }\r\n    // opposite sides of the terrain\r\n    else {\r\n      posView /\x3d factor;\r\n    }\r\n  }\r\n\r\n  return groundRelative;\r\n}\r\n\r\n/**\r\n  * Project the 3d position of a HUD object from world space to clip space. In addition\r\n  * to standard model view projection, it also emulates a polygon offset to\r\n  * help with points above/below ground and icon flickering. The resulting location\r\n  * is the anchor of the HUD object, i.e. the position that is used also for testing\r\n  * visibility of the HUD object. Note that the returned projected position is not\r\n  * aligned to a pixel center or border, it is up to the caller to align if necessary.\r\n  *\r\n  * Dependencies:\r\n  *\r\n  *   Attributes:\r\n  *     - position: contains the point world position\r\n  *     - normal: contains the world normal pointing up at the point\r\n  *     - auxpos1: contains centerOffset and pointGroundDistance\r\n  *\r\n  *   Uniforms:\r\n  *     - model: the object -\x3e world transformation matrix\r\n  *     - modelNormal: the object -\x3e world normal transformation matrix (inv transp of model)\r\n  *     - view: the world -\x3e view transformation matrix\r\n  *     - viewNormal: the world -\x3e view normal transformation matrix (inv transp of view)\r\n  *     - proj: the view -\x3e clip projection matrix\r\n  *     - verticalOffset: a vec4 containing:\r\n  *         - the screen height of the vertical offset\r\n  *         - the screen height of the vertical offset as a fraction of camera distance.\r\n  *         - the minimum world size vertical offset.\r\n  *         - the maximum world size vertical offset.\r\n  *       This will do a screen sized offset of the point along its normal (used for line callouts)\r\n  *     - screenSizePerspectiveAlignment: a vec3 containing\r\n  *         - the view distance dependent divisor\r\n  *         - the view distance dependent offset\r\n  *         - the minimum pixel size\r\n  *         - the amount of padding in pixels around the region to be scaled (not used for alignment)\r\n  *     - cameraGroundRelative: indicates whether camera is above (1) or below (-1) ground.\r\n  *         This is used for emulated polygon offset for improved visibility of points sitting on the surface.\r\n  *     - polygonOffset: a constant polygon offset to bring the point closer to the viewer for\r\n  *         reduced flickering.\r\n  *     - camPos: the position of the camera in world space\r\n  *     - viewport: the viewport [x, y, width, height]\r\n  */\r\nvec4 projectPositionHUD(out ProjectHUDAux aux) {\r\n  // centerOffset is in view space and is used to implement world size offsetting\r\n  // of labels with respect to objects. It also pulls the label towards the viewer\r\n  // so that the label is visible in front of the object.\r\n  vec3 centerOffset \x3d auxpos1.xyz;\r\n\r\n  // The pointGroundDistance is the distance of the geometry to the ground and is\r\n  // negative if the point is below the ground, or positive if the point is above\r\n  // ground.\r\n  float pointGroundDistance \x3d auxpos1.w;\r\n\r\n  aux.posModel \x3d (model * vec4(position, 1.0)).xyz;\r\n  aux.posView \x3d (view * vec4(aux.posModel, 1.0)).xyz;\r\n  aux.vnormal \x3d (modelNormal * vec4(normal, 1.0)).xyz;\r\n\r\n  // Screen sized offset in world space, used for example for line callouts\r\n  // Note: keep this implementation in sync with the CPU implementation, see\r\n  //   - MaterialUtil.verticalOffsetAtDistance\r\n  //   - HUDMaterial.applyVerticalOffsetTransformation\r\n\r\n  aux.distanceToCamera \x3d length(aux.posView);\r\n\r\n  vec3 viewDirObjSpace \x3d normalize(camPos - aux.posModel);\r\n  float cosAngle \x3d dot(aux.vnormal, viewDirObjSpace);\r\n\r\n  aux.absCosAngle \x3d abs(cosAngle);\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n\r\n#if defined(VERTICAL_OFFSET) || defined(CENTER_OFFSET_UNITS_SCREEN)\r\n  vec4 perspectiveFactor \x3d screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);\r\n#endif\r\n\r\n#endif\r\n\r\n#ifdef VERTICAL_OFFSET\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n  float verticalOffsetScreenHeight \x3d applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);\r\n#else\r\n  float verticalOffsetScreenHeight \x3d verticalOffset.x;\r\n#endif\r\n\r\n  float worldOffset \x3d clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\r\n  vec3 modelOffset \x3d aux.vnormal * worldOffset;\r\n\r\n  aux.posModel +\x3d modelOffset;\r\n\r\n  vec3 viewOffset \x3d (viewNormal * vec4(modelOffset, 1.0)).xyz;\r\n  aux.posView +\x3d viewOffset;\r\n\r\n  // Since we elevate the object, we need to take that into account\r\n  // in the distance to ground\r\n  pointGroundDistance +\x3d worldOffset;\r\n\r\n#endif\r\n\r\n  float groundRelative \x3d applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\r\n\r\n#ifndef CENTER_OFFSET_UNITS_SCREEN\r\n  // Apply x/y in view space, but z in screen space (i.e. along posView direction)\r\n  aux.posView +\x3d vec3(centerOffset.x, centerOffset.y, 0.0);\r\n\r\n  // Same material all have same z !\x3d 0.0 condition so should not lead to\r\n  // branch fragmentation and will save a normalization if it's not needed\r\n  if (centerOffset.z !\x3d 0.0) {\r\n    aux.posView -\x3d normalize(aux.posView) * centerOffset.z;\r\n  }\r\n#endif\r\n\r\n  vec4 posProj \x3d proj * vec4(aux.posView, 1.0);\r\n\r\n#ifdef CENTER_OFFSET_UNITS_SCREEN\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n  float centerOffsetY \x3d applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);\r\n#else\r\n  float centerOffsetY \x3d centerOffset.y;\r\n#endif\r\n\r\n  posProj.xy +\x3d vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;\r\n\r\n#endif\r\n\r\n  // constant part of polygon offset emulation\r\n  posProj.z -\x3d groundRelative * polygonOffset * posProj.w;\r\n\r\n  return posProj;\r\n}\r\n\r\nuniform float uRenderTransparentlyOccludedHUD;\r\n\r\n/**\r\n  * Test for visibility of a HUD object.\r\n  *\r\n  * Dependencies:\r\n  *\r\n  *   Uniforms:\r\n  *     - hudVisibilityTexture: the texture that contains the visibility information\r\n  *     - markerColor: the special marker color that is used to write visibility information\r\n  *     - viewport: the viewport\r\n  */\r\nbool testVisibilityHUD(vec4 posProj) {\r\n  // For occlusion testing, use the nearest pixel center to avoid\r\n  // subpixel filtering messing up the color we use to test for\r\n  vec4 posProjCenter \x3d alignToPixelCenter(posProj, viewport.zw);\r\n\r\n  vec4 occlusionPixel \x3d texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\r\n\r\n  // the red pixel here indicates that the occlusion pixel passed the depth test against solid geometry and was written\r\n  // the green pixel stores transparency of transparent geometry (1.0 -\x3e fully transparent)\r\n  // note that we also check against green \x3d\x3d 0.0, i.e. transparent geometry that has opaque parts\r\n\r\n  // thus we render visible pixels that are occluded by semi-transparent (but not fully transparent!) geometry here\r\n  if (uRenderTransparentlyOccludedHUD \x3e 0.5) {\r\n    // multiplying by uRenderTransparentlyOccludedHUD allows us to ignore the second condition if\r\n    // uRenderTransparentlyOccludedHUD \x3d 0.75\r\n    return occlusionPixel.r * occlusionPixel.g \x3e 0.0 \x26\x26 occlusionPixel.g * uRenderTransparentlyOccludedHUD \x3c 1.0;\r\n  }\r\n  // and visible pixels that are not occluded by semi-transparent geometry here\r\n  else {\r\n    return occlusionPixel.r * occlusionPixel.g \x3e 0.0 \x26\x26 occlusionPixel.g \x3d\x3d 1.0;\r\n  }\r\n\r\n  // return texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w).r \x3e 0.0;\r\n}\r\n",
"normalEncoding.glsl":"vec3 decodeNormal(vec2 f) {\r\n    float z \x3d 1.0 - abs(f.x) - abs(f.y);\r\n    return vec3(f + sign(f) * min(z, 0.0), z);\r\n}\r\n","quad.vert":"#include \x3cutil/vsPrecision.glsl\x3e\r\n\r\nattribute vec2 position;\r\nvarying vec2 uv;\r\n\r\nvoid main(void) {\r\n  gl_Position \x3d vec4(position.x, position.y, .0, 1.0);\r\n  uv \x3d position * .5 + vec2(.5);\r\n}\r\n","sceneLighting.glsl":"// Scene Lighting Definitions:\r\n// \x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\x3d\r\n\r\n// defines:\r\n//   - SH_ORDER: 1|2|3\r\n// input:\r\n//   - normal: vec3\r\n//   - albedo: vec3\r\n//   - shadow: float\r\n//   - ssao: float\r\n// return:\r\n//   - color: vec3\r\n\r\n// main light\r\n/////////////////////////////////////////\r\nuniform vec3 lightingMainDirection;\r\nuniform vec3 lightingMainIntensity;\r\n\r\n// ambient lighting\r\n/////////////////////////////////////////\r\n#ifndef SH_ORDER\r\n  #define SH_ORDER 2\r\n#endif\r\n\r\n#if SH_ORDER \x3d\x3d 0\r\n  uniform vec3 lightingAmbientSH0;\r\n#elif SH_ORDER \x3d\x3d 1\r\n  uniform vec4 lightingAmbientSH_R;\r\n  uniform vec4 lightingAmbientSH_G;\r\n  uniform vec4 lightingAmbientSH_B;\r\n#elif SH_ORDER \x3d\x3d 2\r\n  uniform vec3 lightingAmbientSH0;\r\n  uniform vec4 lightingAmbientSH_R1;\r\n  uniform vec4 lightingAmbientSH_G1;\r\n  uniform vec4 lightingAmbientSH_B1;\r\n  uniform vec4 lightingAmbientSH_R2;\r\n  uniform vec4 lightingAmbientSH_G2;\r\n  uniform vec4 lightingAmbientSH_B2;\r\n#endif\r\n\r\n// special tweaking\r\n//////////////////////////////////////////\r\nuniform float lightingFixedFactor;\r\nuniform float lightingGlobalFactor;\r\n\r\nuniform float ambientBoostFactor;\r\n\r\n// evaluation\r\n//////////////////////////////////////////\r\n\r\nvec3 evaluateSceneLighting(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {\r\n  // evaluate the main light\r\n  #if defined(TREE_RENDERING)\r\n    // Special case for tree rendering:\r\n    // We shift the Lambert lobe to the back, allowing it to reach part of the hemisphere\r\n    // facing away from the light. The idea is to get an effect where light is transmitted\r\n    // through the tree.\r\n    float minDot \x3d -0.5;\r\n    float dotRange \x3d 1.0 - minDot;\r\n    float dotNormalization \x3d 0.66; // guessed \x26 hand tweaked value, for an exact value we could precompute an integral over the sphere\r\n\r\n    float dotVal \x3d dotNormalization * (clamp(-dot(normal, lightingMainDirection), 1.0 - dotRange, 1.0) - minDot) * (1.0 / dotRange);\r\n  #else\r\n    float dotVal \x3d clamp(-dot(normal, lightingMainDirection), 0.0, 1.0);\r\n  #endif\r\n\r\n  // move lighting towards (1.0, 1.0, 1.0) if requested\r\n  dotVal \x3d mix(dotVal, 1.0, lightingFixedFactor);\r\n\r\n  vec3 mainLight \x3d (1.0 - shadow) * lightingMainIntensity * dotVal;\r\n\r\n  // evaluate the sh ambient light\r\n  #if SH_ORDER \x3d\x3d 0\r\n    vec3 ambientLight \x3d 0.282095 * lightingAmbientSH0;\r\n  #elif SH_ORDER \x3d\x3d 1\r\n    vec4 sh0 \x3d vec4(\r\n      0.282095,\r\n      0.488603 * normal.x,\r\n      0.488603 * normal.z,\r\n      0.488603 * normal.y\r\n    );\r\n    vec3 ambientLight \x3d vec3(\r\n      dot(lightingAmbientSH_R, sh0),\r\n      dot(lightingAmbientSH_G, sh0),\r\n      dot(lightingAmbientSH_B, sh0)\r\n    );\r\n  #elif SH_ORDER \x3d\x3d 2\r\n    vec3 ambientLight \x3d 0.282095 * lightingAmbientSH0;\r\n\r\n    vec4 sh1 \x3d vec4(\r\n      0.488603 * normal.x,\r\n      0.488603 * normal.z,\r\n      0.488603 * normal.y,\r\n      1.092548 * normal.x * normal.y\r\n    );\r\n    vec4 sh2 \x3d vec4(\r\n      1.092548 * normal.y * normal.z,\r\n      0.315392 * (3.0 * normal.z * normal.z - 1.0),\r\n      1.092548 * normal.x * normal.z,\r\n      0.546274 * (normal.x * normal.x - normal.y * normal.y)\r\n    );\r\n    ambientLight +\x3d vec3(\r\n      dot(lightingAmbientSH_R1, sh1),\r\n      dot(lightingAmbientSH_G1, sh1),\r\n      dot(lightingAmbientSH_B1, sh1)\r\n    );\r\n    ambientLight +\x3d vec3(\r\n      dot(lightingAmbientSH_R2, sh2),\r\n      dot(lightingAmbientSH_G2, sh2),\r\n      dot(lightingAmbientSH_B2, sh2)\r\n    );\r\n  #endif\r\n  ambientLight *\x3d (1.0 - ssao);\r\n\r\n  // inverse gamma correction on the albedo color\r\n  float gamma \x3d 2.1;\r\n  vec3 albedoGammaC \x3d pow(albedo, vec3(gamma));\r\n\r\n  // physically correct BRDF normalizes by PI\r\n  const float PI \x3d 3.14159;\r\n  vec3 totalLight \x3d mainLight + ambientLight + additionalLight;\r\n  totalLight \x3d min(totalLight, vec3(PI, PI, PI));\r\n  vec3 outColor \x3d vec3((albedoGammaC / PI) * (totalLight));\r\n\r\n  // apply gamma correction to the computed color\r\n  outColor \x3d pow(outColor, vec3(1.0/gamma));\r\n\r\n  return outColor;\r\n}\r\n\r\nvec3 sceneLightingAdditionalLightGlobal(vec3 worldPos, float ssao, out float additionalAmbientScale) {\r\n  // heuristic lighting model originally used in the terrain shading\r\n  // now used to generated additional ambient light\r\n\r\n#ifdef VIEWING_MODE_GLOBAL\r\n    float vndl \x3d -dot(normalize(worldPos), lightingMainDirection);\r\n#else\r\n    float vndl \x3d -dot(vec3(0.0, 0.0, 1.0), lightingMainDirection);\r\n#endif\r\n\r\n  additionalAmbientScale \x3d smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));\r\n  return ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\r\n}\r\n",
"screenSizePerspective.glsl":"// Note that the implementation here should be kept in sync with the corresponding\r\n// CPU implementation (used for hitTest etc) in screenSizePerspectiveUtils.ts\r\n\r\n/**\r\n * Compute the screen size perspective lower bound from pre-computed screen\r\n * size perspective factors (or parameters, since both store the pixel lower\r\n * bound information in the same place). When computing the minimum size,\r\n * the padding (e.g. text halo) is scaled with the same factor as the\r\n * original size scales to reach the minimum size.\r\n *\r\n * {\r\n *    x: N/A\r\n *    y: N/A\r\n *    z: minPixelSize (abs),\r\n *    w: sizePaddingInPixels (abs)\r\n * }\r\n */\r\nfloat screenSizePerspectiveMinSize(float size, vec4 factor) {\r\n\r\n  // Original calculation:\r\n  //   padding \x3d 2 * factor.w\r\n  //   minSize \x3d factor.z\r\n  //\r\n  //   minSize + minSize / size * padding\r\n  //\r\n  // Incorporates padding (factor.w, e.g. text halo size) into the\r\n  // minimum bounds calculation, taking into account that padding\r\n  // would scale down proportionally to the size.\r\n  //\r\n  // Calculation below is the same, but avoids division by zero when\r\n  // size would be zero, without branching using step.\r\n  // https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10683\r\n\r\n  // nonZeroSize is 1 if size \x3e 0, and 0 otherwise\r\n  float nonZeroSize \x3d 1.0 - step(size, 0.0);\r\n\r\n  return (\r\n    factor.z * (\r\n      1.0 +\r\n      nonZeroSize *                // Multiply by nzs ensures if size is 0, then we ignore\r\n                                   // proportionally scaled padding\r\n      2.0 * factor.w / (\r\n        size + (1.0 - nonZeroSize) // Adding 1 - nzs ensures we divide either by size, or by 1\r\n      )\r\n    )\r\n  );\r\n}\r\n\r\n/**\r\n * Computes the view angle dependent screen size perspective factor. The goal\r\n * of this factor is that:\r\n *\r\n *   1. There is no perspective when looking top-down\r\n *   2. There is a smooth and quick transition to full perspective when\r\n *      tilting.\r\n */\r\nfloat screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {\r\n  return absCosAngle * absCosAngle * absCosAngle;\r\n}\r\n\r\n/**\r\n * Precomputes a set of factors that can be used to apply screen size perspective\r\n * The factors are based on the viewing angle, distance to camera and the screen size\r\n * perspective parameters:\r\n * {\r\n *    x: distanceDivisor,\r\n *    y: distanceOffset,\r\n *    z: minPixelSize (abs),\r\n *    w: sizePaddingInPixels (abs)\r\n * }\r\n *\r\n * The result is a set of factors that can be used to apply the perspective:\r\n *\r\n * {\r\n *    x: distance based relative scale factor (0 -\x3e 1)\r\n *    y: view dependent scale factor\r\n *    z: minPixelSize (abs)\r\n *    w: sizePaddingInPixels (abs)\r\n * }\r\n */\r\nvec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {\r\n  return vec4(min(params.x / (distanceToCamera - params.y), 1.0), screenSizePerspectiveViewAngleDependentFactor(absCosAngle), params.z, params.w);\r\n}\r\n\r\n/**\r\n * Applies screen size perspective factors to a single dimension size, given the viewing angle,\r\n * distance to camera and perspective parameters. The factors can be calculated from the screen size\r\n * perspective parameters using screenSizePerspectiveScaleFactorFloat.\r\n *\r\n * Note that for single scale application, the screenSizePerspectiveScaleFloat can be used, which\r\n * will call this method, providing it the factors calculated from screenSizePerspectiveScaleFactorFloat.\r\n */\r\n\r\nfloat applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {\r\n  return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));\r\n}\r\n\r\n/**\r\n * Applies screen size perspective parameters to a single dimension size, given the viewing angle,\r\n * distance to camera and perspective parameters\r\n * {\r\n *    x: distanceDivisor,\r\n *    y: distanceOffset,\r\n *    z: minPixelSize (abs),\r\n *    w: sizePaddingInPixels (abs)\r\n * }\r\n */\r\nfloat screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {\r\n  return applyScreenSizePerspectiveScaleFactorFloat(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\r\n}\r\n\r\n/**\r\n * Applies screen size perspective factors to a vec2 size (width/height), given the viewing angle,\r\n * distance to camera and perspective parameters. The factors can be calculated from the screen size\r\n * perspective parameters using screenSizePerspectiveScaleFactorVec2.\r\n *\r\n * Note that for single scale application, the screenSizePerspectiveScaleVec2 can be used, which\r\n * will call this method, providing it the factors calculated from screenSizePerspectiveScaleFactorVec2.\r\n */\r\nvec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {\r\n  return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / size.y, 1.0), size, factor.y);\r\n}\r\n\r\n/**\r\n * Applies screen size perspective parameters to a vec2 size (width/height), given the viewing angle,\r\n * distance to camera and perspective parameters\r\n * {\r\n *    x: distanceDivisor,\r\n *    y: distanceOffset,\r\n *    z: minPixelSize (abs),\r\n *    w: sizePaddingInPixels (abs)\r\n * }\r\n */\r\nvec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {\r\n  return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));\r\n}\r\n",
"shadow.glsl":'#include \x3cutil/encoding.glsl\x3e\r\n\r\n// "matrix" parameter used to have const qualifier as well, but IE11 couldn\'t deal with it at time of writing.\r\n// once IE11 is fine with it, const should probably be re-introduced\r\nfloat evalShadow(const in vec3 vpos, const in float depth, const in sampler2D depthTex, const int num, const in vec4 distance, in mat4 matrix[4], const in float halfPxSz) {\r\n  //choose correct cascade\r\n  int i \x3d depth \x3c distance[1] ? 0 : depth \x3c distance[2] ? 1 : depth \x3c distance[3] ? 2 : 3;\r\n\r\n  if (i \x3e\x3d num) { return .0; }\r\n\r\n  mat4 mat \x3d i \x3d\x3d 0 ? matrix[0] : i \x3d\x3d 1 ? matrix[1] : i \x3d\x3d 2 ? matrix[2] : matrix[3];\r\n\r\n  vec4 lv \x3d mat * vec4(vpos, 1.0);\r\n  lv.xy /\x3d lv.w;\r\n\r\n  //vertex completely outside? -\x3e no shadow\r\n  vec3 lvpos \x3d .5 * lv.xyz + vec3(.5);\r\n  if (lvpos.z \x3e\x3d 1.0) { return .0; }\r\n  if (lvpos.x \x3c .0 || lvpos.x \x3e 1.0 || lvpos.y \x3c .0 || lvpos.y \x3e 1.0) { return .0; }\r\n\r\n  //calc coord in cascade texture\r\n  vec2 uv \x3d vec2(float(i - 2 * (i / 2)) *.5, float(i / 2) * .5) + .5 * lvpos.xy;\r\n\r\n  float texSize \x3d .5 / halfPxSz;\r\n\r\n  //filter, offset by half pixels\r\n  vec2 st \x3d fract((vec2(halfPxSz) + uv) * texSize);\r\n\r\n  float s00 \x3d rgba2float(texture2D(depthTex, uv + vec2(-halfPxSz, -halfPxSz))) \x3c lvpos.z ? 1.0 : .0;\r\n  float s10 \x3d rgba2float(texture2D(depthTex, uv + vec2(halfPxSz, -halfPxSz))) \x3c lvpos.z ? 1.0 : .0;\r\n  float s11 \x3d rgba2float(texture2D(depthTex, uv + vec2(halfPxSz, halfPxSz))) \x3c lvpos.z ? 1.0 : .0;\r\n  float s01 \x3d rgba2float(texture2D(depthTex, uv + vec2(-halfPxSz, halfPxSz))) \x3c lvpos.z ? 1.0 : .0;\r\n\r\n  return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);\r\n}\r\n',
"slice.glsl":"#ifdef SLICE\r\nuniform vec3 slicePlaneOrigin;\r\nuniform vec3 slicePlaneBasis1;\r\nuniform vec3 slicePlaneBasis2;\r\n\r\nstruct SliceFactors {\r\n  float front;\r\n  float side0;\r\n  float side1;\r\n  float side2;\r\n  float side3;\r\n};\r\n\r\nSliceFactors calculateSliceFactors(vec3 pos) {\r\n  vec3 rel \x3d pos - slicePlaneOrigin;\r\n\r\n  vec3 slicePlaneNormal \x3d -cross(slicePlaneBasis1, slicePlaneBasis2);\r\n  float slicePlaneW \x3d -dot(slicePlaneNormal, slicePlaneOrigin);\r\n\r\n  float basis1Len2 \x3d dot(slicePlaneBasis1, slicePlaneBasis1);\r\n  float basis2Len2 \x3d dot(slicePlaneBasis2, slicePlaneBasis2);\r\n\r\n  float basis1Dot \x3d dot(slicePlaneBasis1, rel);\r\n  float basis2Dot \x3d dot(slicePlaneBasis2, rel);\r\n\r\n  return SliceFactors(\r\n    dot(slicePlaneNormal, pos) + slicePlaneW,\r\n    -basis1Dot - basis1Len2,\r\n    basis1Dot - basis1Len2,\r\n    -basis2Dot - basis2Len2,\r\n    basis2Dot - basis2Len2\r\n  );\r\n}\r\n\r\nbool sliceByFactors(SliceFactors factors) {\r\n  return factors.front \x3c 0.0\r\n    \x26\x26 factors.side0 \x3c 0.0\r\n    \x26\x26 factors.side1 \x3c 0.0\r\n    \x26\x26 factors.side2 \x3c 0.0\r\n    \x26\x26 factors.side3 \x3c 0.0;\r\n}\r\n\r\nbool sliceByPlane(vec3 pos) {\r\n  return sliceByFactors(calculateSliceFactors(pos));\r\n}\r\n\r\n#ifdef EXTENSIONS_ENABLED\r\n\r\nvec4 applySliceHighlight(vec4 color, vec3 pos) {\r\n  SliceFactors factors \x3d calculateSliceFactors(pos);\r\n\r\n  if (sliceByFactors(factors)) {\r\n    return color;\r\n  }\r\n\r\n  const float HIGHLIGHT_WIDTH \x3d 1.0;\r\n  const vec4 HIGHLIGHT_COLOR \x3d vec4(0.0, 0.0, 0.0, 0.3);\r\n\r\n  factors.front /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);\r\n  factors.side0 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);\r\n  factors.side1 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);\r\n  factors.side2 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);\r\n  factors.side3 /\x3d (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);\r\n\r\n  float highlightFactor \x3d (1.0 - step(0.5, factors.front))\r\n    * (1.0 - step(0.5, factors.side0))\r\n    * (1.0 - step(0.5, factors.side1))\r\n    * (1.0 - step(0.5, factors.side2))\r\n    * (1.0 - step(0.5, factors.side3));\r\n\r\n  return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);\r\n}\r\n\r\n#else // EXTENSIONS_ENABLED\r\n\r\n// GL_OES_standard_derivatives must be enabled for applySliceHighlight\r\n\r\n#endif // EXTENSIONS_ENABLED\r\n\r\n#define rejectBySlice(_pos_) sliceByPlane(_pos_)\r\n#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }\r\n#define highlightSlice(_color_, _pos_) applySliceHighlight(_color_, _pos_)\r\n\r\n#else // SLICE\r\n\r\n#define rejectBySlice(_pos_) false\r\n#define discardBySlice(_pos_) {}\r\n#define highlightSlice(_color_, _pos_) (_color_)\r\n\r\n#endif // SLICE\r\n",
"visualVariables.glsl":"#if defined(VV_SIZE)\r\n  #define VV_CUSTOM_MODEL_MATRIX\r\n#endif\r\n\r\n#if defined(VV_SIZE)\r\n  uniform vec3 vvSizeMinSize;\r\n  uniform vec3 vvSizeMaxSize;\r\n  uniform vec3 vvSizeOffset;\r\n  uniform vec3 vvSizeFactor;\r\n#elif defined(VV_CUSTOM_MODEL_MATRIX)\r\n  uniform vec3 vvSizeValue;\r\n#endif\r\n\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n  uniform mat3 vvSymbolRotation;\r\n#endif\r\n\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n  uniform vec3 vvSymbolAnchor;\r\n#endif\r\n\r\n#ifdef VV_COLOR\r\n  #define VV_COLOR_N 8\r\n  uniform float vvColorValues[VV_COLOR_N];\r\n  uniform vec4 vvColorColors[VV_COLOR_N];\r\n#endif\r\n\r\n// Evaluation of size\r\n#if defined(VV_SIZE)\r\n  vec3 vvGetScale(vec4 featureAttribute) {\r\n    return clamp(vvSizeOffset + featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);\r\n  }\r\n#elif defined(VV_CUSTOM_MODEL_MATRIX)\r\n  vec3 vvGetScale(vec4 featureAttribute) {\r\n    return vvSizeValue;\r\n  }\r\n#endif\r\n\r\n// Applying the model matrix\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n  vec4 vvTransformPosition(vec3 position, vec4 featureAttribute) {\r\n    return vec4(vvSymbolRotation * (vvGetScale(featureAttribute) * (position + vvSymbolAnchor)), 1.0);\r\n  }\r\n\r\n  vec4 vvTransformNormal(vec3 normal, vec4 featureAttribute) {\r\n    // Normal transform is the inverse transpose of model transform\r\n    return vec4(vvSymbolRotation * normal / vvGetScale(featureAttribute), 1.0);\r\n  }\r\n#endif\r\n\r\n#ifdef VV_COLOR\r\n  vec4 vvGetColor(vec4 featureAttribute, float values[VV_COLOR_N], vec4 colors[VV_COLOR_N]) {\r\n    float value \x3d featureAttribute.y;\r\n    if (value \x3c\x3d values[0]) {\r\n      return colors[0];\r\n    }\r\n\r\n    for (int i \x3d 1; i \x3c VV_COLOR_N; ++i) {\r\n      if (values[i] \x3e\x3d value) {\r\n        float f \x3d (value - values[i-1]) / (values[i] - values[i-1]);\r\n        return mix(colors[i-1], colors[i], f);\r\n      }\r\n    }\r\n\r\n    return colors[VV_COLOR_N - 1];\r\n  }\r\n#endif\r\n",
"vsPrecision.glsl":"precision highp float;\r\nprecision highp sampler2D;\r\n"}}});