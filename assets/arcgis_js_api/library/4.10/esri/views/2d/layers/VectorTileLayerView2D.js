// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.10/esri/copyright.txt for details.
//>>built
require({cache:{"esri/views/2d/tiling/TileInfoViewPOT":function(){define("require exports ../../../core/tsSupport/extendsHelper ../../../core/tsSupport/decorateHelper ../../../layers/support/TileInfo ./TileInfoView ./TileKey".split(" "),function(u,r,d,q,p,h,b){return function(f){function c(){var a=null!==f&&f.apply(this,arguments)||this;a._fullCacheLodInfos=null;a._levelByScale={};return a}d(c,f);c.prototype.getTileParentId=function(a){a=b.pool.acquire(a);var c=0===a.level?null:b.getId(a.level-1,
a.row>>1,a.col>>1,a.world);b.pool.release(a);return c};c.prototype.getTileCoverage=function(a,c,b){a=f.prototype.getTileCoverage.call(this,a,c,b);if(!a)return a;var e=1<<a.lodInfo.level;a.spans=a.spans.filter(function(a){return 0<=a.row&&a.row<e});return a};c.prototype.scaleToLevel=function(a){this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos);if(this._levelByScale[a])return this._levelByScale[a];var c=this._fullCacheLodInfos;if(a>c[0].scale)return c[0].level;for(var b=void 0,
m=void 0,b=0;b<c.length-1;b++)if(m=c[b+1],a>m.scale)return b=c[b],b.level+(b.scale-a)/(b.scale-m.scale);return c[c.length-1].level};c.prototype._initializeFullCacheLODs=function(a){a=0===a[0].level?a.map(function(a){return{level:a.level,resolution:a.resolution,scale:a.scale}}):p.create({size:this.tileInfo.size[0],spatialReference:this.tileInfo.spatialReference}).lods.map(function(a){return{level:a.level,resolution:a.resolution,scale:a.scale}});for(var c=0;c<a.length;c++)this._levelByScale[a[c].scale]=
a[c].level;this._fullCacheLodInfos=a};return c}(h)})},"esri/views/vectorTiles/TileHandler":function(){define("require exports ../../request ../../core/has ../../core/ItemCache ../../core/promiseUtils ../../core/requireUtils ../../core/workers ../2d/tiling/TileKey ./GeometryUtils ./GlyphMosaic ./GlyphSource ./SpriteMosaic ./SpriteSource ./TileIndex ./VectorTileDisplayObject module".split(" "),function(u,r,d,q,p,h,b,f,c,a,e,w,m,k,n,v,x){var g=new p(10),l=new Map;return function(){function t(a,c,b,g){this.devicePixelRatio=
c;this.allowUpdates=b;this._tileIndex=this._connection=this._glyphMosaic=this._spriteMosaic=null;this._updateQueue=new Map;this._ongoingRequests=new Map;this._vectorTileLayer=a;this._container=g}t.prototype.destroy=function(){this.stop();this._vectorTileLayer=null;this._spriteMosaic&&(this._spriteMosaic.dispose(),this._spriteMosaic=null);this._glyphMosaic&&(this._glyphMosaic.dispose(),this._glyphMosaic=null)};Object.defineProperty(t.prototype,"initialized",{get:function(){return this._broadcastPromise&&
this._broadcastPromise.isFulfilled()},enumerable:!0,configurable:!0});Object.defineProperty(t.prototype,"spriteMosaic",{get:function(){return this._spriteMosaic},enumerable:!0,configurable:!0});Object.defineProperty(t.prototype,"glyphMosaic",{get:function(){return this._glyphMosaic},enumerable:!0,configurable:!0});Object.defineProperty(t.prototype,"ongoingRequestCount",{get:function(){return this._ongoingRequests.size},enumerable:!0,configurable:!0});t.prototype.start=function(){var a=this;this.stop();
var c=this._vectorTileLayer.styleRepository,g=new k(c.sprite,this.devicePixelRatio),l=g.load().then(function(){a._spriteMosaic=new m(1024,1024,250);a._spriteMosaic.setSpriteSource(g)}),t=new w(c.glyphs);this._glyphMosaic=new e(1024,1024,t);var v=this._fetchTileMap(this._vectorTileLayer.tileIndexUrl),n=f.open(b.getAbsMid("./WorkerTileHandler",u,x),{client:this}).then(function(c){a._connection=c}),d,t=h.create(function(a){d=a},function(a){l.isFulfilled()||l.cancel();v.isFulfilled()||v.cancel();n.isFulfilled()||
n.cancel()});h.all([l,n]).then(function(){var b=a._connection.broadcast("setLayers",c.styleJSON);b.push(v);h.all(b).then(function(){d()})});return this._broadcastPromise=t};t.prototype.stop=function(){this._broadcastPromise&&!this._broadcastPromise.isFulfilled()&&this._broadcastPromise.cancel();this._updateQueue.forEach(function(a){return a.cancel()});this._ongoingRequests.forEach(function(a){return a.cancel()});this._connection&&(this._connection.close(),this._connection=null)};t.prototype.updateStyle=
function(){this._updateQueue.forEach(function(a){return a.cancel()});this._updateQueue.clear();this._ongoingRequests.forEach(function(a){return a.cancel()});this._ongoingRequests.clear();var a=this._vectorTileLayer.styleRepository,c,b=h.create(function(a){c=a});h.all(this._connection.broadcast("updateStyle",a.styleJSON)).then(function(){return c()});return this._broadcastPromise=b};t.prototype.updateTile=function(c,b){var g=this;if(!this.allowUpdates)return h.resolve(null);if(!this._broadcastPromise.isFulfilled()||
!this._connection)return h.reject(Error("no connection"));b=Math.round(a.degToByte(b.state.rotation));if(c.rotation===b)return h.resolve(null);var l,k=c.key;this._updateQueue.has(k.id)&&(l=this._updateQueue.get(k.id),l.cancel(),this._updateQueue["delete"](k.id));c.rotation=b;l=c.client.invoke("updateSymbols",{key:c.id,rotation:b}).then(function(a){g._updateQueue["delete"](k.id);c.updateSymbolData(a);return a}).catch(function(a){if("cancel"!==a.dojoType)g._updateQueue["delete"](k.id)});this._updateQueue.set(c.id,
l);return l};t.prototype.updateTileData=function(a){for(var c=a.tileId,b=this._container.children,g,l=0;l<b.length;l++)if(g=b[l],g.id===c){g.updateTileData(a.tileData);break}};t.prototype.getVectorTile=function(a,b,g,l){var k=this;void 0===l&&(l=0);var e=new c(a,b,g,0);return this.getRefKey(e).then(function(a){var c=new v(e,a,k._vectorTileLayer.tileInfo,k._vectorTileLayer.styleRepository,0);if(a)return k.getTileData(c.key,0).then(function(a){c.setData(a.tileData,a.client);return c});c.setData(null,
null);return c})};t.prototype.getTileData=function(c,b){var g=this;return this._broadcastPromise.isFulfilled()&&this._connection?this.getRefKey(c).then(function(l){if(!l)return h.resolve(null);var k=Math.round(a.degToByte(b));return g._getTileData(g._connection,c,l,k).then(function(a){return a&&a.tileData?a:h.reject(null)})}):h.reject(Error("no connection"))};t.prototype.getRefKey=function(a){return this._tileIndex?this._tileIndex.dataKey(a):h.resolve(a)};t.prototype.getSprites=function(a){return this._spriteMosaic.getSpriteItems(a)};
t.prototype.getGlyphs=function(a){return this._glyphMosaic.getGlyphItems(a.tileID,a.font,a.codePoints)};t.prototype.getStyleRepository=function(){return this._vectorTileLayer.styleRepository};t.prototype.getTileIndex=function(){return this._tileIndex};t.prototype._getTileData=function(a,c,b,g){var l=this;if(a=this._ongoingRequests.get(c.id))return a;a=this._vectorTileLayer.getTileUrl(b.level,b.row,b.col);var k=this._connection.getAvailableClient();a=k.invoke("getTile",{key:c.id,refKey:b.id,url:a,
rotation:g,cacheTile:this.allowUpdates}).then(function(a){l._ongoingRequests.delete(c.id);return{tileData:a,client:k}}).catch(function(a){l._ongoingRequests.delete(c.id);k.invoke("destructTileData",c.id);return h.reject(a)});this._ongoingRequests.set(c.id,a);return a};t.prototype._fetchTileMap=function(a){var c=this;if(this._vectorTileLayer.capabilities.operations.supportsTileMap&&this._vectorTileLayer.tilemapCache)return this._tileIndex=new n(this._vectorTileLayer.tilemapCache),h.resolve();if(!a)return h.resolve();
var b=g.get(a);if(void 0!==b)return this._tileIndex=b,h.resolve();if(l.has(a))return l.get(a).then(function(a){c._tileIndex=new n(a.data)});b=d(a,{responseType:"json"});b.then(function(b){c._tileIndex=new n(b.data);l["delete"](a);g.put(a,c._tileIndex)});l.set(a,b);return b};return t}()})},"esri/views/vectorTiles/GlyphMosaic":function(){define("require exports ../../core/has ../../core/promiseUtils ./Rect ./RectangleBinPack ../webgl/Texture".split(" "),function(u,r,d,q,p,h,b){return function(){function f(c,
a,b){this.height=this.width=0;this._dirties=[];this._glyphData=[];this._currentPage=0;this._glyphIndex={};this._textures=[];this._rangePromises=new Map;this.width=c;this.height=a;this._glyphSource=b;this._binPack=new h(c-4,a-4);this._glyphData.push(new Uint8Array(c*a));this._dirties.push(!0);this._textures.push(void 0)}f.prototype.getGlyphItems=function(c,a,b){var e=this,m=[],k=this._glyphSource;c=new Set;for(var f=1/256,v=0;v<b.length;v++)c.add(Math.floor(b[v]*f));var x=[];c.forEach(function(c){if(256>=
c){var b=a+c;e._rangePromises.has(b)?x.push(e._rangePromises.get(b)):(c=k.getRange(a,c).then(function(){e._rangePromises["delete"](b)},function(){e._rangePromises["delete"](b)}),e._rangePromises.set(b,c),x.push(c))}});return q.all(x).then(function(c){var l=e._glyphIndex[a];l||(l={},e._glyphIndex[a]=l);for(var g=0;g<b.length;g++){c=b[g];var f=l[c];if(f)m[c]={rect:f.rect,metrics:f.metrics,page:f.page};else{var v=k.getGlyph(a,c);if(v&&v.metrics){var f=v.metrics,x=void 0;if(0===f.width)x=new p(0,0,0,
0);else{var n=f.width+6,w=f.height+6,d=n%4?4-n%4:4,q=w%4?4-w%4:4;1===d&&(d=5);1===q&&(q=5);x=e._binPack.allocate(n+d,w+q);x.isEmpty&&(e._dirties[e._currentPage]||(e._glyphData[e._currentPage]=null),e._currentPage=e._glyphData.length,e._glyphData.push(new Uint8Array(e.width*e.height)),e._dirties.push(!0),e._textures.push(void 0),e._binPack=new h(e.width-4,e.height-4),x=e._binPack.allocate(n+d,w+q));var d=e._glyphData[e._currentPage],v=v.bitmap,r=q=void 0;if(v)for(var u=0;u<w;u++)for(var q=n*u,r=e.width*
(x.y+u+1)+x.x,y=0;y<n;y++)d[r+y+1]=v[q+y]}l[c]={rect:x,metrics:f,tileIDs:null,page:e._currentPage};m[c]={rect:x,metrics:f,page:e._currentPage};e._dirties[e._currentPage]=!0}}}return m})};f.prototype.removeGlyphs=function(c){for(var a in this._glyphIndex){var b=this._glyphIndex[a];if(b){var f=void 0,m;for(m in b)if(f=b[m],f.tileIDs["delete"](c),0===f.tileIDs.size){for(var k=this._glyphData[f.page],n=f.rect,v=void 0,x=void 0,g=0;g<n.height;g++)for(v=this.width*(n.y+g)+n.x,x=0;x<n.width;x++)k[v+x]=0;
delete b[m];this._dirties[f.page]=!0}}}};f.prototype.bind=function(c,a,e,f){void 0===f&&(f=0);this._textures[e]||(this._textures[e]=new b(c,{pixelFormat:6406,dataType:5121,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));var m=this._textures[e];m.setSamplingMode(a);this._dirties[e]&&m.setData(this._glyphData[e]);c.bindTexture(m,f);this._dirties[e]=!1};f.prototype.dispose=function(){this._binPack=null;for(var c=0,a=this._textures;c<a.length;c++){var b=a[c];b&&b.dispose()}this._textures.length=
0};return f}()})},"esri/views/vectorTiles/Rect":function(){define(["require","exports"],function(u,r){return function(){function d(d,p,h,b){void 0===d&&(d=0);void 0===p&&(p=0);void 0===h&&(h=0);void 0===b&&(b=0);this.x=d;this.y=p;this.width=h;this.height=b}Object.defineProperty(d.prototype,"isEmpty",{get:function(){return 0>=this.width||0>=this.height},enumerable:!0,configurable:!0});return d}()})},"esri/views/vectorTiles/RectangleBinPack":function(){define(["require","exports","./Rect"],function(u,
r,d){return function(){function q(p,h){this._height=this._width=0;this._free=[];this._width=p;this._height=h;this._free.push(new d(0,0,p,h))}Object.defineProperty(q.prototype,"width",{get:function(){return this._width},enumerable:!0,configurable:!0});Object.defineProperty(q.prototype,"height",{get:function(){return this._height},enumerable:!0,configurable:!0});q.prototype.allocate=function(p,h){if(p>this._width||h>this._height)return new d;for(var b=null,f=-1,c=0;c<this._free.length;++c){var a=this._free[c];
p<=a.width&&h<=a.height&&(null===b||a.y<=b.y&&a.x<=b.x)&&(b=a,f=c)}if(null===b)return new d;this._free.splice(f,1);b.width<b.height?(b.width>p&&this._free.push(new d(b.x+p,b.y,b.width-p,h)),b.height>h&&this._free.push(new d(b.x,b.y+h,b.width,b.height-h))):(b.width>p&&this._free.push(new d(b.x+p,b.y,b.width-p,b.height)),b.height>h&&this._free.push(new d(b.x,b.y+h,p,b.height-h)));return new d(b.x,b.y,p,h)};q.prototype.release=function(d){for(var h=0;h<this._free.length;++h){var b=this._free[h];if(b.y===
d.y&&b.height===d.height&&b.x+b.width===d.x)b.width+=d.width;else if(b.x===d.x&&b.width===d.width&&b.y+b.height===d.y)b.height+=d.height;else if(d.y===b.y&&d.height===b.height&&d.x+d.width===b.x)b.x=d.x,b.width+=d.width;else if(d.x===b.x&&d.width===b.width&&d.y+d.height===b.y)b.y=d.y,b.height+=d.height;else continue;this._free.splice(h,1);this.release(d)}this._free.push(d)};return q}()})},"esri/views/vectorTiles/GlyphSource":function(){define(["require","exports","../../request","../../core/pbf",
"../../core/promiseUtils"],function(u,r,d,q,p){var h=function(){function b(c){this._metrics=[];this._bitmaps=[];if(c)for(;c.next();)switch(c.tag()){case 1:for(var a=c.getMessage();a.next();)switch(a.tag()){case 3:for(var b=a.getMessage(),f=void 0,m=void 0,k=void 0,n=void 0,v=void 0,x=void 0,g=void 0;b.next();)switch(b.tag()){case 1:f=b.getUInt32();break;case 2:m=b.getBytes();break;case 3:k=b.getUInt32();break;case 4:n=b.getUInt32();break;case 5:v=b.getSInt32();break;case 6:x=b.getSInt32();break;case 7:g=
b.getUInt32();break;default:b.skip()}f&&(this._metrics[f]={width:k,height:n,left:v,top:x,advance:g},this._bitmaps[f]=m);break;default:a.skip()}break;default:c.skip()}}b.prototype.getMetrics=function(c){return this._metrics[c]};b.prototype.getBitmap=function(c){return this._bitmaps[c]};return b}(),b=function(){function b(){this._ranges=[]}b.prototype.getRange=function(c){return this._ranges[c]};b.prototype.addRange=function(c,a){this._ranges[c]=a};return b}();return function(){function f(c){this._glyphInfo=
{};this._baseURL=c}f.prototype.getRange=function(c,a){var b=this._getFontStack(c);if(b.getRange(a))return p.resolve();var f=256*a,m=f+255;c=this._baseURL.replace("{fontstack}",c).replace("{range}",f+"-"+m);return d(c,{responseType:"array-buffer"}).then(function(c){b.addRange(a,new h(new q(new Uint8Array(c.data),new DataView(c.data))))}).catch(function(){b.addRange(a,new h)})};f.prototype.getGlyph=function(c,a){if(c=this._getFontStack(c)){var b=Math.floor(a/256);if(!(256<b)&&(c=c.getRange(b)))return{metrics:c.getMetrics(a),
bitmap:c.getBitmap(a)}}};f.prototype._getFontStack=function(c){var a=this._glyphInfo[c];a||(a=this._glyphInfo[c]=new b);return a};return f}()})},"esri/views/vectorTiles/SpriteMosaic":function(){define("require exports ./GeometryUtils ./Rect ./RectangleBinPack ../webgl/Texture".split(" "),function(u,r,d,q,p,h){return function(){function b(b,c,a){void 0===a&&(a=0);this._size=[];this._mosaicsData=[];this._textures=[];this._dirties=[];this._pageHeight=this._pageWidth=this._currentPage=this._maxItemSize=
0;this._mosaicRects={};this.pixelRatio=1;(0>=b||0>=c)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!");this._pageWidth=b;this._pageHeight=c;0<a&&(this._maxItemSize=a);this._binPack=new p(b-4,c-4)}b.prototype.getWidth=function(b){return b>=this._size.length?-1:this._size[b][0]};b.prototype.getHeight=function(b){return b>=this._size.length?-1:this._size[b][1]};b.prototype.setSpriteSource=function(b){this.dispose();this.pixelRatio=b.devicePixelRatio;if(0===this._mosaicsData.length){this._binPack=
new p(this._pageWidth-4,this._pageHeight-4);var c=new Uint32Array(Math.floor(this._pageWidth)*Math.floor(this._pageHeight));this._mosaicsData[0]=c;this._dirties.push(!0);this._size.push([this._pageWidth,this._pageHeight]);this._textures.push(void 0)}this._sprites=b};b.prototype.getSpriteItem=function(b,c){void 0===c&&(c=!1);var a=this._mosaicRects[b];if(a)return a;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;a=this._sprites.getSpriteInfo(b);if(!a||!a.width||!a.height||0>a.width||
0>a.height)return null;var e=a.width,f=a.height,m=this._allocateImage(e,f),k=m[0],n=m[1];if(0>=k.width)return null;this._copy(k,a,n,m[2],c);a={rect:k,width:e,height:f,anchorX:0,anchorY:0,sdf:a.sdf,simplePattern:!1,pixelRatio:a.pixelRatio,page:n};return this._mosaicRects[b]=a};b.prototype.preloadSpriteItems=function(){for(var b=0,c=this._sprites.spriteNames;b<c.length;b++)this.getSpriteItem(c[b],!0)};b.prototype.getSpriteItems=function(b){for(var c={},a=0;a<b.length;a++){var e=b[a];c[e]=this.getSpriteItem(e)}return c};
b.prototype.getMosaicItemPosition=function(b,c){c=(b=this.getSpriteItem(b,c))&&b.rect;if(!c)return null;c.width=b.width;c.height=b.height;return{size:[b.width,b.height],tl:[(c.x+2)/this._size[b.page][0],(c.y+2)/this._size[b.page][1]],br:[(c.x+2+b.width)/this._size[b.page][0],(c.y+2+b.height)/this._size[b.page][1]],page:b.page}};b.prototype.bind=function(b,c,a,e){void 0===a&&(a=0);void 0===e&&(e=0);this._textures[a]||(this._textures[a]=new h(b,{pixelFormat:6408,dataType:5121,width:this._size[a][0],
height:this._size[a][1]},new Uint8Array(this._mosaicsData[a].buffer)));var f=this._textures[a];f.setSamplingMode(c);this._dirties[a]&&f.setData(new Uint8Array(this._mosaicsData[a].buffer));b.bindTexture(f,e);this._dirties[a]=!1};b._copyBits=function(b,c,a,e,d,m,k,n,v,x,g){var l=e*c+a;k=n*m+k;if(g)for(k-=m,g=-1;g<=x;g++,l=((g+x)%x+e)*c+a,k+=m)for(n=-1;n<=v;n++)d[k+n]=b[l+(n+v)%v];else for(g=0;g<x;g++){for(n=0;n<v;n++)d[k+n]=b[l+n];l+=c;k+=m}};b.prototype._copy=function(f,c,a,e,d,m){if(this._sprites&&
"loaded"===this._sprites.loadStatus&&!(a>=this._mosaicsData.length)){var k=new Uint32Array(m?m.buffer:this._sprites.image.buffer),n=this._mosaicsData[a];n&&k||console.error("Source or target images are uninitialized!");b._copyBits(k,m?c.width:this._sprites.width,c.x,c.y,n,e[0],f.x+2,f.y+2,c.width,c.height,d);this._dirties[a]=!0}};b.prototype._allocateImage=function(b,c){b+=2;c+=2;var a=Math.max(b,c);if(this._maxItemSize&&this._maxItemSize<a){var a=Math.pow(2,Math.ceil(d.log2(b))),e=Math.pow(2,Math.ceil(d.log2(c)));
b=new q(0,0,b,c);this._mosaicsData.push(new Uint32Array(a*e));this._dirties.push(!0);this._size.push([a,e]);this._textures.push(void 0);return[b,this._mosaicsData.length-1,[a,e]]}a=b%4?4-b%4:4;e=c%4?4-c%4:4;1===a&&(a=5);1===e&&(e=5);a=this._binPack.allocate(b+a,c+e);return 0>=a.width?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),
this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new p(this._pageWidth-4,this._pageHeight-4),this._allocateImage(b,c)):[a,this._currentPage,[this._pageWidth,this._pageHeight]]};b.prototype.dispose=function(){this._binPack=null;this._mosaicRects={};for(var b=0,c=this._textures;b<c.length;b++){var a=c[b];a&&a.dispose()}this._textures.length=0};return b}()})},"esri/views/vectorTiles/SpriteSource":function(){define("require exports ../../core/tsSupport/extendsHelper ../../core/tsSupport/decorateHelper ../../request ../../core/promiseUtils".split(" "),
function(u,r,d,q,p,h){return function(){function b(b,c){this.baseURL=b;this.devicePixelRatio=c;this._isRetina=!1;this._spritesData={};this.height=this.width=this.image=null;this.loadStatus="not-loaded"}Object.defineProperty(b.prototype,"spriteNames",{get:function(){var b=[],c;for(c in this._spritesData)b.push(c);b.sort();return b},enumerable:!0,configurable:!0});b.prototype.getSpriteInfo=function(b){return this._spritesData[b]};b.prototype.load=function(){var b=this;this.loadStatus="loading";return this.baseURL?
this._loadSprites().then(function(){b.loadStatus="loaded";return b}).catch(function(c){b.loadStatus="failed";return b}):h.resolve(this)};b.prototype._loadSprites=function(){var b=this;this._isRetina=1.15<this.devicePixelRatio?!0:!1;var c=this.baseURL,a=this._isRetina?"@2x":"",e=""+c+a+".png";return h.all([p(c+a+".json",{responseType:"json"}),p(e,{responseType:"image"})]).then(function(a){var c=a[0];a=a[1];var k=Object.keys(c.data);if(!k||0===k.length||1===k.length&&"_ssl"===k[0]||!a||!a.data)return b._spritesData=
b.image=null,b.width=b.height=0,h.resolve(null);b._spritesData=c.data;c=a.data;b.width=c.width;b.height=c.height;a=document.createElement("canvas");k=a.getContext("2d");a.width=c.width;a.height=c.height;k.drawImage(c,0,0,c.width,c.height);c=k.getImageData(0,0,c.width,c.height);c=new Uint8Array(c.data);for(k=0;k<c.length;k+=4)a=c[k+3]/255,c[k]*=a,c[k+1]*=a,c[k+2]*=a;b.image=c})};return b}()})},"esri/views/vectorTiles/TileIndex":function(){define(["require","exports","../../core/promiseUtils","../../layers/support/TilemapCache",
"../2d/tiling/TileKey"],function(u,r,d,q,p){return function(){function h(b){if(b instanceof q)this._tilemapCache=b;else if(b&&"index"in b)this._tilemap=b.index;else throw Error("Invalid tilemap!");}h.prototype.dataKey=function(b){if(this._tilemapCache){var d=b.level,c=b.row,a=b.col,e=new p(b);return this._tilemapCache.fetchAvailabilityUpsample(d,c,a,e).then(function(){return e}).catch(function(b){if(b&&"cancel"===b.dojoType)throw b;e.level=d;e.row=c;e.col=a;return e})}return this._getIndexedDataKey(b)};
h.prototype.forEach=function(b,d,c,a,e){this._callback=e;this._maxLevel=d+b;this._forEach(this._tilemap,d,c,a)};h.prototype._forEach=function(b,d,c,a){0!==b&&(this._callback(d,c,a),d!==this._maxLevel&&"object"===typeof b&&(this._forEach(b[0],d+1,2*c,2*a),this._forEach(b[1],d+1,2*c,2*a+1),this._forEach(b[2],d+1,2*c+1,2*a),this._forEach(b[3],d+1,2*c+1,2*a+1)))};h.prototype._getIndexedDataKey=function(b){var f=[b];if(0>b.level||0>b.row||0>b.col||0<b.row>>b.level||0<b.col>>b.level)return d.resolve(null);
for(;0!==b.level;)b=new p(b.level-1,b.row>>1,b.col>>1,b.world),f.push(b);b=this._tilemap;var c=f.pop(),a,e;if(1===b)return d.resolve(c);for(;f.length;)if(a=f.pop(),e=(a.col&1)+((a.row&1)<<1),b)if(0===b[e]){c=null;break}else if(1===b[e]){c=a;break}else c=a,b=b[e];return d.resolve(c)};return h}()})},"esri/views/vectorTiles/VectorTileDisplayObject":function(){define("require exports ../../core/tsSupport/extendsHelper ../../core/ObjectPool ../../core/libs/gl-matrix-2/gl-matrix ../../geometry/support/spatialReferenceUtils ../2d/engine/DisplayObject ../2d/tiling/TileKey ./RenderBucket ../webgl/BufferObject".split(" "),
function(u,r,d,q,p,h,b,f,c,a){var e="fillVertexBuffer fillDDVertexBuffer fillIndexBuffer outlineVertexBuffer outlineDDVertexBuffer outlineIndexBuffer lineVertexBuffer lineDDVertexBuffer lineIndexBuffer iconVertexBuffer iconDDVertexBuffer iconIndexBuffer textVertexBuffer textDDVertexBuffer textIndexBuffer circleVertexBuffer circleIndexBuffer".split(" ");return function(b){function m(){for(var a,c=[],e=0;e<arguments.length;e++)c[e]=arguments[e];e=b.call(this)||this;e._renderBuckets=[];e._vectorTileData=
null;e._symbolUpdateData=null;e.coords=[0,0];e.bounds=[0,0,0,0];e.tileTransform={transform:p.mat4f32.create(),displayCoord:p.vec2f32.create()};e.stencilData={mask:0,reference:0};0<c.length&&(a=e.acquire).call.apply(a,[e].concat(c));return e}d(m,b);m.prototype.reset=function(){f.pool.release(this.key);this.refKey=this.key=null;this.coords[0]=0;this.coords[1]=0;this.bounds[0]=0;this.bounds[1]=0;this.bounds[2]=0;this.height=this.width=this.bounds[3]=0;this.resolution=null;this.rotation=0;this.id=this.client=
this.styleLayers=this._vectorTileData=null;this.tileTransform.transform.fill(0);this.tileTransform.displayCoord.fill(0);this.stencilData.mask=0;this.stencilData.reference=0;this._renderBuckets.length=0;this.stage=this._symbolUpdateData=null};m.prototype.acquire=function(a,b,c,e,g){this.key=a;this.refKey=b;b=c.lodAt(a.level);b=null!==b?b.resolution:0;var l=c.size[0]*b,k=c.origin,v=a.col*l,m=a.row*l,x=c.spatialReference,d=0;x&&(x._isWrappable?x._isWrappable():x.isWrappable)&&(x=h.getInfo(x),d=x.valid[1]-
x.valid[0]);v=k.x+v+a.world*d;k=k.y-m;this.coords[0]=v;this.coords[1]=k;this.bounds[0]=v;this.bounds[1]=k;this.bounds[2]=v+l;this.bounds[3]=k-l;this.widthInPixels=c.size[1];this.coordRange=4096;this.resolution=b;this.rotation=g;this.styleLayers=e;this.id=a.id};m.prototype.setData=function(a,b){this._vectorTileData=a;this.client=b};m.prototype.updateSymbolData=function(a){a&&(this._symbolUpdateData=a,this.requestRender())};m.prototype.updateTileData=function(a){this._vectorTileData=a;this.stage.requestRender()};
m.prototype.dispose=function(){for(var a="fillVertexArrayObject fillDDVertexArrayObject outlineVertexArrayObject lineVertexArrayObject lineDDVertexArrayObject iconVertexArrayObject iconDDVertexArrayObject textVertexArrayObject textDDVertexArrayObject circleVertexArrayObject fillVertexBuffer fillDDVertexBuffer fillIndexBuffer outlineVertexBuffer outlineDDVertexBuffer outlineIndexBuffer lineVertexBuffer lineDDVertexBuffer lineIndexBuffer iconVertexBuffer iconDDVertexBuffer iconIndexBuffer textVertexBuffer textDDVertexBuffer textIndexBuffer circleVertexBuffer circleIndexBuffer texture".split(" "),
b=0;b<a.length;++b){var c=a[b];this[c]&&(this[c].dispose(),this[c]=null)}this._renderBuckets.length=0};m.prototype.getCpuMemoryUsage=function(){return null!=this._vectorTileData&&this._vectorTileData.bufferData?this._vectorTileData.bufferData.reduce(function(a,b){return a+b.byteLength},0)+this._vectorTileData.bufferDataInfo.byteLength+this._vectorTileData.bucketDataInfo.byteLength:0};m.prototype.getGpuMemoryUsage=function(){var a=this,b=e.reduce(function(b,c){return a[c]?b+a[c].size:b},0);this.texture&&
(b+=this.texture.descriptor.width*this.texture.descriptor.height*4);return b};m.prototype.attachWithContext=function(a){this.stage={context:a};this.attached=this.attach()};m.prototype._commitChanges=function(){this._vectorTileData&&(this.dispose(),this._createRenderBuckets(),this._createBufferObjects(),this._vectorTileData=null)};m.prototype._createRenderBuckets=function(){for(var a=new Uint32Array(this._vectorTileData.bucketDataInfo),b=a.length,e=0;e<b;){var m=a[e];switch(a[e+1]){case 0:var g=new c.BackgroundRenderBucket;
g.layerID=m;this._renderBuckets.push(g);e+=2;break;case 1:g=new c.FillRenderBucket;g.layerID=m;g.triangleElementStart=a[e+2];g.triangleElementCount=a[e+3];g.outlineElementStart=a[e+4];g.outlineElementCount=a[e+5];this._renderBuckets.push(g);e+=6;break;case 2:g=new c.LineRenderBucket;g.layerID=m;g.triangleElementStart=a[e+2];g.triangleElementCount=a[e+3];this._renderBuckets.push(g);e+=4;break;case 3:g=new c.SymbolRenderBucket;g.layerID=m;g.isSDF=0!==a[e+2];var l=e+3,m=a[l];l++;if(0<m)for(var t=void 0,
d=void 0,f=void 0,h=0;h<m;h++)t=a[l],d=a[l+1],f=a[l+2],g.markerPerPageElementsMap.set(t,[d,f]),l+=3;var w=a[l];l++;if(0<w)for(f=d=t=void 0,h=0;h<w;h++)t=a[l],d=a[l+1],f=a[l+2],g.glyphPerPageElementsMap.set(t,[d,f]),l+=3;this._renderBuckets.push(g);e+=5+3*m+3*w;break;case 4:g=new c.CircleRenderBucket;g.layerID=m;g.triangleElementStart=a[e+2];g.triangleElementCount=a[e+3];this._renderBuckets.push(g);e+=4;break;default:console.error("Bad bucket type!"),e+=2}}};m._createBufferToObject=function(){var b=
[];b[1]={create:a.createVertex,var:"fillVertexBuffer"};b[2]={create:a.createVertex,var:"fillDDVertexBuffer"};b[3]={create:a.createIndex,var:"fillIndexBuffer"};b[4]={create:a.createVertex,var:"outlineVertexBuffer"};b[5]={create:a.createVertex,var:"outlineDDVertexBuffer"};b[6]={create:a.createIndex,var:"outlineIndexBuffer"};b[7]={create:a.createVertex,var:"lineVertexBuffer"};b[8]={create:a.createVertex,var:"lineDDVertexBuffer"};b[9]={create:a.createIndex,var:"lineIndexBuffer"};b[10]={create:a.createVertex,
var:"iconVertexBuffer"};b[11]={create:a.createVertex,var:"iconDDVertexBuffer"};b[12]={create:a.createIndex,var:"iconIndexBuffer"};b[13]={create:a.createVertex,var:"textVertexBuffer"};b[14]={create:a.createVertex,var:"textDDVertexBuffer"};b[15]={create:a.createIndex,var:"textIndexBuffer"};b[16]={create:a.createVertex,var:"circleVertexBuffer"};b[17]={create:a.createIndex,var:"circleIndexBuffer"};return b};m.prototype._createBufferObjects=function(){for(var a=this.stage.context,b=new Uint32Array(this._vectorTileData.bufferDataInfo),
c=b.length,e=0,g=0;g<c;g+=2,e++){var l=b[g];if(!(0>=b[g+1]||0===this._vectorTileData.bufferData[e].byteLength)){var t=m.bufferToObject[l];t?this[t.var]?this[t.var].setData(this._vectorTileData.bufferData[e]):this[t.var]=t.create(a,35044,this._vectorTileData.bufferData[e]):console.error("Bad buffer type "+l)}}};m.prototype.detach=function(){this.isReady&&this.client.invoke("destructTileData",this.id);this.dispose();b.prototype.detach.call(this)};m.prototype.doRender=function(a){if(this.visible&&this.isReady){var b=
this.stage.context,c=a.renderer;if(b&&c){this._commitChanges();var e=a.drawphase;this._symbolUpdateData&&(this._updateSymbolData(a,this._symbolUpdateData),this._symbolUpdateData=null);b.setStencilFunction(514,this.stencilData.reference,this.stencilData.mask);var g=this.styleLayers,l,m=void 0!==a.layerOpacity?a.layerOpacity:1;if(0!==m){var d=this._renderBuckets.length;if(0===e)for(var k=d-1;0<=k;k--){var f=this._renderBuckets[k];l=g.layers[f.layerID];if(!f||!l)break;1!==f.type&&0!==f.type||!f.hasData()||
c.renderBucket(b,f,a.displayLevel,a.requiredLevel,e,this,l,m)}else for(k=0;k<d;k++){f=this._renderBuckets[k];l=g.layers[f.layerID];if(!f||!l)break;f.hasData()&&c.renderBucket(b,f,a.displayLevel,a.requiredLevel,e,this,l,m)}}}}};m.prototype._updateSymbolData=function(b,e){if(!e||!e.bucketDataInfo)return!0;b=new Uint32Array(e.bucketDataInfo);var m=b.length;if(0===m)return!0;if(!this.isReady)return this.requestRender(),!1;for(var d=this.stage.context,g=new Uint32Array(e.bufferDataInfo),l=g.length,t=0,
f=0;f<l;f+=2,t++)switch(g[f]){case 10:this.iconVertexBuffer&&(this.iconVertexBuffer.dispose(),this.iconVertexBuffer=null);this.iconVertexBuffer=a.createVertex(d,35044,e.bufferData[t]);break;case 11:this.iconDDVertexBuffer&&(this.iconDDVertexBuffer.dispose(),this.iconDDVertexBuffer=null);this.iconDDVertexBuffer=a.createVertex(d,35044,e.bufferData[t]);break;case 12:this.iconIndexBuffer&&(this.iconIndexBuffer.dispose(),this.iconIndexBuffer=null);this.iconIndexBuffer=a.createIndex(d,35044,e.bufferData[t]);
break;case 13:this.textVertexBuffer&&(this.textVertexBuffer.dispose(),this.textVertexBuffer=null);this.textVertexBuffer=a.createVertex(d,35044,e.bufferData[t]);break;case 14:this.textDDVertexBuffer&&(this.textDDVertexBuffer.dispose(),this.textDDVertexBuffer=null);this.textDDVertexBuffer=a.createVertex(d,35044,e.bufferData[t]);break;case 15:this.textIndexBuffer&&(this.textIndexBuffer.dispose(),this.textIndexBuffer=null),this.textIndexBuffer=a.createIndex(d,35044,e.bufferData[t])}e=[];for(d=0;d<this._renderBuckets.length;d++)this._renderBuckets[d]instanceof
c.SymbolRenderBucket||e.push(this._renderBuckets[d]);this._renderBuckets=e;for(d=0;d<m;){l=b[d];g=new c.SymbolRenderBucket;g.layerID=l;g.isSDF=0!==b[d+2];this.styleLayers.layers.length>g.layerID&&this.styleLayers.layers[g.layerID].type===g.type&&e.push(g);var k=d+3,l=b[k];k++;if(0<l)for(var h=f=t=void 0,n=0;n<l;n++)t=b[k],f=b[k+1],h=b[k+2],g.markerPerPageElementsMap.set(t,[f,h]),k+=3;var w=b[k];k++;if(0<w)for(h=f=t=void 0,n=0;n<w;n++)t=b[k],f=b[k+1],h=b[k+2],g.glyphPerPageElementsMap.set(t,[f,h]),
k+=3;d+=5+3*l+3*w}this.iconVertexArrayObject&&(this.iconVertexArrayObject.dispose(),this.iconVertexArrayObject=null);this.iconDDVertexArrayObject&&(this.iconDDVertexArrayObject.dispose(),this.iconDDVertexArrayObject=null);this.textVertexArrayObject&&(this.textVertexArrayObject.dispose(),this.textVertexArrayObject=null);this.textDDVertexArrayObject&&(this.textDDVertexArrayObject.dispose(),this.textDDVertexArrayObject=null);return!0};m.pool=new q(m);m.bufferToObject=m._createBufferToObject();return m}(b.DisplayObject)})},
"esri/views/vectorTiles/RenderBucket":function(){define(["require","exports","../../core/tsSupport/extendsHelper","../../core/tsSupport/decorateHelper"],function(u,r,d,q){Object.defineProperty(r,"__esModule",{value:!0});u=function(){return function(d){this.type=d}}();r.RenderBucket=u;q=function(p){function h(){var b=p.call(this,2)||this;b.triangleElementStart=0;b.triangleElementCount=0;return b}d(h,p);h.prototype.hasData=function(){return 0<this.triangleElementCount};return h}(u);r.LineRenderBucket=
q;q=function(p){function h(){var b=p.call(this,1)||this;b.triangleElementStart=0;b.triangleElementCount=0;b.outlineElementStart=0;b.outlineElementCount=0;return b}d(h,p);h.prototype.hasData=function(){return 0<this.triangleElementCount||0<this.outlineElementCount};return h}(u);r.FillRenderBucket=q;q=function(p){function h(){var b=p.call(this,3)||this;b.markerPerPageElementsMap=new Map;b.glyphPerPageElementsMap=new Map;b.isSDF=!1;return b}d(h,p);h.prototype.hasData=function(){return 0<this.markerPerPageElementsMap.size||
0<this.glyphPerPageElementsMap.size};return h}(u);r.SymbolRenderBucket=q;q=function(p){function h(){var b=p.call(this,4)||this;b.triangleElementStart=0;b.triangleElementCount=0;return b}d(h,p);h.prototype.hasData=function(){return 0<this.triangleElementCount};return h}(u);r.CircleRenderBucket=q;u=function(p){function h(){return p.call(this,0)||this}d(h,p);h.prototype.hasData=function(){return!0};return h}(u);r.BackgroundRenderBucket=u})},"esri/views/vectorTiles/VectorTileContainer":function(){define("require exports ../../core/tsSupport/extendsHelper ../../core/has ../../core/promiseUtils ../../core/libs/gl-matrix-2/gl-matrix ../2d/engine/Container ../2d/engine/webgl/enums ./GeometryUtils ./renderers/Renderer".split(" "),
function(u,r,d,q,p,h,b,f,c,a){return function(b){function e(){var c=null!==b&&b.apply(this,arguments)||this;c._renderer=new a;c._tileCoordinateScale=h.vec3f32.create();c._orientationVec=h.vec3f32.fromValues(0,0,1);c._displayScale=h.vec3f32.create();c._defaultTransform=h.mat4f32.create();c._displayWidth=0;c._displayHeight=0;c._pointToCallbacks=new Map;return c}d(e,b);e.prototype.initialize=function(a,b,c,e){this._renderer.initialize(a,b);this._tileInfoView=e;this._tileInfo=c};e.prototype.dispose=function(){this._renderer&&
this._renderer.dispose();b.prototype.dispose.call(this)};e.prototype.hitTest=function(a,b){var c=this,e=[a,b];return p.create(function(a,b){c._pointToCallbacks.set(e,{resolve:a,reject:b});c.requestRender()},function(){c._pointToCallbacks.has(e)&&c._pointToCallbacks.delete(e)})};e.prototype.renderChildren=function(a){var c=this;if(0!==this.children.length&&this._tileInfoView&&a&&a.state&&(a.drawPhase===f.WGLDrawPhase.MAP||a.drawPhase===f.WGLDrawPhase.HITTEST)){var e=a.state,d=this.stage.context,m=
this._renderer;m.initializeProgramCache(this.stage.context);m.setGlobalOpacity(d,a,this.opacity);d.setDepthWriteEnabled(!0);d.setStencilWriteMask(255);d.setClearDepth(1);d.setClearStencil(0);d.clear(d.gl.DEPTH_BUFFER_BIT|d.gl.STENCIL_BUFFER_BIT);d.setDepthWriteEnabled(!1);a.displayLevel=this._tileInfoView.scaleToLevel(e.scale);a.requiredLevel=this._tileInfoView.getSmallestInfoForScale(e.scale).level;a.renderer=this._renderer;this.sortChildren(function(a,b){return a.key.level-b.key.level});for(var e=
this.children.length,g=1;g<=e;g++){var l=this.children[g-1];l.attached&&l.visible&&(l.stencilData.reference=g,l.stencilData.mask=255)}this._updateTilesTransform(a.state,a.requiredLevel,this.children);d.setDepthWriteEnabled(!0);this._renderer.setStateParams(a.state,a.pixelRatio,a.displayLevel);this._renderer.drawClippingMasks(d,this.children);d.setStencilWriteMask(0);d.setBlendFunctionSeparate(1,771,1,771);d.setStencilOp(7680,7680,7681);d.setDepthFunction(515);d.setBlendingEnabled(!1);d.setStencilTestEnabled(!0);
d.setDepthTestEnabled(!0);d.setDepthWriteEnabled(!0);a.drawphase=0;b.prototype.renderChildren.call(this,a);d.setDepthWriteEnabled(!1);d.setBlendingEnabled(!0);a.drawphase=1;b.prototype.renderChildren.call(this,a);a.drawphase=2;b.prototype.renderChildren.call(this,a);d.setStencilTestEnabled(!1);d.setDepthTestEnabled(!1);m.applyGlobalOpacity(d,a,this.opacity);if(q("esri-vector-tiles-debug"))for(m=0,e=this.children;m<e.length;m++)g=e[m],g.attached&&g.visible&&this._renderer.renderTileInfo(d,g);0<this._pointToCallbacks.size&&
(this._pointToCallbacks.forEach(function(b,e){b.resolve(c._hitTest(a,e[0],e[1]))}),this._pointToCallbacks.clear());this._renderer.needsRedraw()&&this.requestRender()}};e.prototype.removeAllChildren=function(){for(var a=0;a<this.children.length;a++)this.children[a].dispose();b.prototype.removeAllChildren.call(this)};e.prototype._hitTest=function(a,b,c){var e=this._tileInfoView.getSmallestInfoForScale(a.state.scale).level,d=[0,0];a.state.toMap(d,[b,c]);var g=a.state.clone(),l=g.viewpoint.clone(),t=
l.targetGeometry;t.x=d[0];t.y=d[1];l.targetGeometry=t;g.viewpoint=l;g.size=[3,3];this._renderer.setStateParams(g,a.pixelRatio,a.displayLevel);return(a=this._renderer.hitTest({context:this.stage.context,drawPhase:0,pixelRatio:a.pixelRatio,stationary:a.stationary,globalOpacity:a.globalOpacity,displayLevel:a.displayLevel,requiredLevel:a.requiredLevel,renderer:a.renderer,layerOpacity:a.layerOpacity,state:g,drawphase:3},b,c,this.children,e,3,this._updateTilesTransform.bind(this)))&&0!==a.length?a[0]:null};
e.prototype._updateTilesTransform=function(a,b,c){var e=1/a.size[0],d=1/a.size[1],g=[0,0];this._calculateRelativeViewProjMat(this._tileInfo.lodAt(b).resolution,a.resolution,a.rotation,this._tileInfo.size[1],4096,a.size[0],a.size[1],this._defaultTransform);for(var l=0;l<c.length;l++){var t=c[l];a.toScreen(g,t.coords);g[1]=a.size[1]-g[1];t.tileTransform.displayCoord[0]=2*g[0]*e-1;t.tileTransform.displayCoord[1]=2*g[1]*d-1;t.key.level===b&&4096===t.coordRange?t.tileTransform.transform.set(this._defaultTransform):
this._calculateRelativeViewProjMat(this._tileInfo.lodAt(t.key.level).resolution,a.resolution,a.rotation,this._tileInfo.size[1],t.coordRange,a.size[0],a.size[1],t.tileTransform.transform)}};e.prototype._calculateRelativeViewProjMat=function(a,b,e,d,f,g,l,t){var k=.125;512!==d&&4096!==f&&(k=d/f);a=a/b*k;this._tileCoordinateScale.set([a,a,1]);if(g!==this._displayWidth||l!==this._displayHeight)this._displayScale.set([2/g,-2/l,1]),this._displayWidth=g,this._displayHeight=l;h.mat4.identity(t);h.mat4.scale(t,
t,this._tileCoordinateScale);h.mat4.rotate(t,t,-e*c.C_DEG_TO_RAD,this._orientationVec);h.mat4.scale(t,t,this._displayScale);h.mat4.transpose(t,t)};return e}(b.Container)})},"esri/views/vectorTiles/renderers/Renderer":function(){define("require exports ../../../core/libs/gl-matrix-2/gl-matrix ../../2d/engine/webgl/BitBlitRenderer ../GeometryUtils ./BackgroundRenderer ./CircleRenderer ./FadeRecorder ./FillRenderer ./LineRenderer ./SymbolRenderer ./TileInfoRenderer ./shaders/ProgramCache ../../webgl/FramebufferObject".split(" "),
function(u,r,d,q,p,h,b,f,c,a,e,w,m,k){return function(){function n(){this._extrudeMatrix=d.mat4f32.create();this._extrudeNoRotationMatrix=d.mat4f32.create();this._extrudeRotateVector=d.vec3f32.fromValues(0,0,1);this._extrudeScaleVector=d.vec3f32.fromValues(1,1,1);this._backgroundColor=d.vec4f32.fromValues(1,0,0,1);this._state={rotation:0,size:[0,0]};this._cachedRotation=this._cachedHeight=this._cachedWidth=0;this._blitRenderer=new q;this._programCache=this._boundFBO=this._globalOpacityFBO=null}n.prototype.initialize=
function(a,b,c){void 0===c&&(c=!0);this._SpriteMosaic=a;this._glyphMosaic=b;this._ignoreSpeed=!c;this._fadeRecorder=new f.FadeRecorder(300)};n.prototype.dispose=function(){this._backgroundRenderer&&(this._backgroundRenderer.dispose(),this._backgroundRenderer=null);this._lineRenderer&&(this._lineRenderer.dispose(),this._lineRenderer=null);this._fillRenderer&&(this._fillRenderer.dispose(),this._fillRenderer=null);this._symbolRenderer&&(this._symbolRenderer.dispose(),this._symbolRenderer=null);this._circleRenderer&&
(this._circleRenderer.dispose(),this._circleRenderer=null);this._tileInfoRenderer&&(this._tileInfoRenderer.dispose(),this._tileInfoRenderer=null);this._hittestFBO&&(this._hittestFBO.dispose(),this._hittestFBO=null);this._globalOpacityFBO&&(this._globalOpacityFBO.dispose(),this._globalOpacityFBO=null);this._blitRenderer&&(this._blitRenderer.dispose(),this._blitRenderer=null);this._boundFBO=null;this._programCache&&(this._programCache.dispose(),this._programCache=null);this._cachedRotation=this._cachedHeight=
this._cachedWidth=0};n.prototype.initializeProgramCache=function(d){if(null===this._programCache){var f=new m.default;f.initialize(d);this._backgroundRenderer=new h(f);this._lineRenderer=new a(f);this._fillRenderer=new c(f);this._symbolRenderer=new e(f);this._circleRenderer=new b(f);this._tileInfoRenderer=new w(f);this._programCache=f}};n.prototype.setStateParams=function(a,b,c){this._fadeRecorder.recordLevel(c);this._state=a;if(this._state.size[0]!==this._cachedWidth||this._state.size[1]!==this._cachedHeight||
this._state.rotation!==this._cachedRotation)this._extrudeScaleVector[0]=2/a.size[0],this._extrudeScaleVector[1]=-2/a.size[1],d.mat4.identity(this._extrudeMatrix),d.mat4.rotate(this._extrudeMatrix,this._extrudeMatrix,-a.rotation*p.C_DEG_TO_RAD,this._extrudeRotateVector),d.mat4.scale(this._extrudeMatrix,this._extrudeMatrix,this._extrudeScaleVector),d.mat4.transpose(this._extrudeMatrix,this._extrudeMatrix),d.mat4.identity(this._extrudeNoRotationMatrix),d.mat4.scale(this._extrudeNoRotationMatrix,this._extrudeNoRotationMatrix,
this._extrudeScaleVector),d.mat4.transpose(this._extrudeNoRotationMatrix,this._extrudeNoRotationMatrix),this._cachedWidth=this._state.size[0],this._cachedHeight=this._state.size[1],this._cachedRotation=this._state.rotation};n.prototype.drawClippingMasks=function(a,b){if(0!==b.length){a.setDepthWriteEnabled(!1);a.setDepthTestEnabled(!1);a.setStencilTestEnabled(!0);a.setBlendingEnabled(!1);a.setColorMask(!1,!1,!1,!1);a.setStencilOp(7680,7680,7681);a.setStencilWriteMask(255);a.setClearStencil(0);a.clear(a.gl.STENCIL_BUFFER_BIT);
for(var c=0;c<b.length;c++){var e=b[c];e.attached&&e.visible&&(a.setStencilFunctionSeparate(1032,519,e.stencilData.reference,e.stencilData.mask),this._backgroundRenderer.renderSolidColor(a,{u_matrix:e.tileTransform.transform,u_normalized_origin:e.tileTransform.displayCoord,u_coord_range:e.coordRange,u_depth:0,u_color:this._backgroundColor}))}a.setColorMask(!0,!0,!0,!0);a.setBlendingEnabled(!0)}};n.prototype.renderDebug=function(a,b){var c=b.key;this._backgroundColor.set([c.col%2,c.row%2,0===c.col%
2&&0===c.row%2?1:0,.5]);this._backgroundRenderer.renderSolidColor(a,{u_matrix:b.tileTransform.transform,u_normalized_origin:b.tileTransform.displayCoord,u_coord_range:b.coordRange,u_depth:0,u_color:this._backgroundColor})};n.prototype.renderBucket=function(a,b,c,e,d,f,k,h){if(k&&!(void 0!==k.minzoom&&k.minzoom>c+1E-6||f.key.level===e&&void 0!==k.maxzoom&&k.maxzoom<=c-1E-6))switch(b.type){case 0:2!==d&&this._renderBackground(a,b,c,d,f,k,h);break;case 1:2!==d&&this._renderFill(a,b,c,d,f,k,h);break;
case 2:1!==d&&3!==d||this._renderLine(a,b,c,d,f,k,h);break;case 3:2!==d&&3!==d||this._renderSymbol(a,b,c,d,e,f,k,h);break;case 4:2!==d&&3!==d||this._renderCircle(a,b,c,d,e,f,k,h)}};n.prototype.renderTileInfo=function(a,b){this._tileInfoRenderer.render(a,b)};n.prototype.setGlobalOpacity=function(a,b,c){if(1!==c){this._boundFBO=a.getBoundFramebufferObject();c=b.pixelRatio;var e=b.state.size;b=Math.round(e[0]*c);c=Math.round(e[1]*c);if(null===this._globalOpacityFBO||this._globalOpacityFBO.width!==b||
this._globalOpacityFBO.height!==c)null!==this._globalOpacityFBO&&this._globalOpacityFBO.dispose(),this._globalOpacityFBO=k.create(a,{colorTarget:0,depthStencilTarget:3,width:b,height:c});a.bindFramebuffer(this._globalOpacityFBO);a.setClearColor(0,0,0,0);a.clear(a.gl.COLOR_BUFFER_BIT)}};n.prototype.applyGlobalOpacity=function(a,b,c){if(1!==c){var e=b.pixelRatio,d=b.state.size;b=d[0];var d=d[1],g=a.getViewport();a.setViewport(0,0,e*b,e*d);a.bindFramebuffer(this._boundFBO);this._blitRenderer.render(a,
this._globalOpacityFBO.colorTexture,9728,c);a.setViewport(g.x,g.y,g.width,g.height);this._boundFBO=null}};n.prototype.needsRedraw=function(){return this._fadeRecorder.needsRedraw()};n.prototype.hitTest=function(a,b,c,e,d,f,h){var g=[0,0],l=[0,0],t=a.state;t.toMap(g,[0,0]);t.toMap(l,[f,f]);b=e.filter(function(a){return!(g[0]>a.bounds[2]||l[0]<a.bounds[0]||g[1]<a.bounds[3]||l[1]>a.bounds[1])});if(0===b.length)return[];b.sort(function(a,b){return a.key.level-b.key.level});c=b.length;for(e=1;e<=c;e++){var m=
b[e-1];m.attached&&(m.stencilData.reference=e,m.stencilData.mask=255)}h(t,d,b);d=a.context;this._hittestFBO||(this._hittestFBO=k.create(d,{colorTarget:0,depthStencilTarget:3,width:f,height:f}));h=d.getViewport();t=d.getBoundFramebufferObject();d.bindFramebuffer(this._hittestFBO);d.setViewport(0,0,f,f);e=d.gl;d.setDepthWriteEnabled(!0);d.setStencilWriteMask(255);d.setClearColor(1,1,1,1);d.setClearDepth(1);d.setClearStencil(0);d.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT|e.STENCIL_BUFFER_BIT);d.setDepthWriteEnabled(!1);
this.drawClippingMasks(d,b);d.setBlendingEnabled(!1);d.setStencilWriteMask(0);d.setStencilOp(7680,7680,7681);d.setDepthFunction(515);d.setDepthTestEnabled(!0);d.setDepthWriteEnabled(!0);d.setStencilTestEnabled(!0);for(e=0;e<c;e++)m=b[e],m.attached&&m.doRender(a);d.setStencilTestEnabled(!1);d.setDepthTestEnabled(!1);this._readbackBuffer||(this._readbackBuffer=new Uint8Array(4*f*f),this._readbackBuffer32=new Uint32Array(this._readbackBuffer.buffer));this._hittestFBO.readPixels(0,0,f,f,6408,5121,this._readbackBuffer);
a=new Set;f*=f;b=this._readbackBuffer32[Math.round(f/2)];4294967295!==b&&a.add(b);for(e=0;e<f;e++)b=this._readbackBuffer32[e],4294967295!==b&&a.add(b);d.bindFramebuffer(t);d.setViewport(h.x,h.y,h.width,h.height);var w=[];a.forEach(function(a){w.push(a)});return w};n.prototype._renderBackground=function(a,b,c,e,d,f,k){this._backgroundRenderer.render(a,b,c,e,d,f,this._SpriteMosaic,this._SpriteMosaic.pixelRatio,k)};n.prototype._renderLine=function(a,b,c,e,d,f,k){this._lineRenderer.render(a,b,c,e,this._state,
d,f,this._SpriteMosaic,this._extrudeMatrix,this._SpriteMosaic.pixelRatio,k)};n.prototype._renderFill=function(a,b,c,e,d,f,k){this._fillRenderer.render(a,b,c,this._state.rotation,e,d,f,this._SpriteMosaic,this._extrudeMatrix,this._SpriteMosaic.pixelRatio,k)};n.prototype._renderCircle=function(a,b,c,e,d,f,k,h){var g=!0;d===f.key.level&&(g=!1);a.setStencilTestEnabled(g);this._circleRenderer.render(a,b,c,e,this._state.rotation,f,k,this._extrudeMatrix,h)};n.prototype._renderSymbol=function(a,b,c,e,d,f,
k,h){var g=!0;d===f.key.level&&(g=!1);a.setStencilTestEnabled(g);this._symbolRenderer.render(a,b,c,e,this._state.rotation,this._fadeRecorder.getFadeValues(this._ignoreSpeed),f,k,this._SpriteMosaic,this._glyphMosaic,this._extrudeMatrix,this._extrudeNoRotationMatrix,this._SpriteMosaic.pixelRatio,h)};return n}()})},"esri/views/vectorTiles/renderers/BackgroundRenderer":function(){define("require exports ../../../core/libs/gl-matrix-2/gl-matrix ../MemoryBuffer ./rendererUtils ../../webgl/BufferObject ../../webgl/VertexArrayObject".split(" "),
function(u,r,d,q,p,h,b){return function(){function f(b){this._patternMatrix=d.mat3f32.create();this._color=d.vec4f32.create();this._rendererInitialized=this._solidrendererInitialized=!1;this._programOptions={id:!1,pattern:!1};this._programCache=b;this._color.set([1,0,0,1])}f.prototype.dispose=function(){this._solidVertexArrayObject&&(this._solidVertexArrayObject.dispose(),this._solidVertexArrayObject=null);this._vertexArrayObject&&(this._vertexArrayObject.dispose(),this._vertexArrayObject=null)};
f.prototype.renderSolidColor=function(b,a){this._solidrendererInitialized||this._initializeSolidRenderer(b);b.bindVAO(this._solidVertexArrayObject);var c=this._programOptions;c.id=!1;c.pattern=!1;c=this._programCache.getProgram(0,0,c);b.bindProgram(c);c.setUniformMatrix4fv("u_transformMatrix",a.u_matrix);c.setUniform2fv("u_normalized_origin",a.u_normalized_origin);c.setUniform1f("u_coord_range",a.u_coord_range||4096);c.setUniform1f("u_depth",a.u_depth||0);c.setUniform4fv("u_color",a.u_color||this._color);
b.drawArrays(5,0,4);b.bindVAO()};f.prototype.render=function(b,a,e,f,h,k,n,q,x){this._rendererInitialized||this._initialize(b);var c=k.getPaintValue("background-color",e);x*=k.getPaintValue("background-opacity",e);var l=k.getPaintValue("background-pattern",e),m=void 0!==l,w=c[3]*x,v=m||1>w;if(!v||0!==f)if(v||1!==f){f=3===f;v=this._programOptions;v.id=f;v.pattern=m;v=this._programCache.getProgram(0,(f?1:0)<<1|(m?1:0),v);b.bindVAO(this._vertexArrayObject);b.bindProgram(v);v.setUniform1f("u_coord_range",
h.coordRange);v.setUniform1f("u_depth",k.z||0);v.setUniformMatrix4fv("u_transformMatrix",h.tileTransform.transform);v.setUniform2fv("u_normalized_origin",h.tileTransform.displayCoord);if(m){k=n.getMosaicItemPosition(l,!0);if(!k)return;e=512*Math.pow(2,Math.floor(e)-h.key.level)*q;d.mat3.identity(this._patternMatrix);h=e/k.size[1];this._patternMatrix[0]=e/k.size[0];this._patternMatrix[4]=h;n.bind(b,9729,k.page,5);v.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix);v.setUniform1f("u_opacity",
x);v.setUniform2f("u_pattern_tl",k.tl[0],k.tl[1]);v.setUniform2f("u_pattern_br",k.br[0],k.br[1]);v.setUniform1i("u_texture",5)}else this._color[0]=w*c[0],this._color[1]=w*c[1],this._color[2]=w*c[2],this._color[3]=w,v.setUniform4fv("u_color",this._color);f&&(a=p.int32To4Bytes(a.layerID),v.setUniform4f("u_id",a[0],a[1],a[2],a[3]));b.drawArrays(5,0,4);b.bindVAO()}};f.prototype._initializeSolidRenderer=function(c){if(this._solidrendererInitialized)return!0;var a=new Int8Array([0,0,1,0,0,1,1,1]),a=h.createVertex(c,
35044,a);this._solidVertexArrayObject=new b(c,this._programCache.getProgramAttributes(0),{geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:2,normalized:!1,divisor:0}]},{geometry:a});return this._solidrendererInitialized=!0};f.prototype._initialize=function(c){if(this._rendererInitialized)return!0;var a=[];a.push(q.i1616to32(0,0));a.push(q.i1616to32(1,0));a.push(q.i1616to32(0,1));a.push(q.i1616to32(1,1));a=new Uint32Array(a);a=h.createVertex(c,35044,a);this._vertexArrayObject=new b(c,{a_pos:0},
{geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:4,normalized:!1,divisor:0}]},{geometry:a});return this._rendererInitialized=!0};return f}()})},"esri/views/vectorTiles/MemoryBuffer":function(){define(["require","exports"],function(u,r){return function(){function d(d){this._array=[];0>=d&&console.error("strideInBytes must be positive!");this._stride=d}Object.defineProperty(d.prototype,"array",{get:function(){return this._array},enumerable:!0,configurable:!0});Object.defineProperty(d.prototype,
"index",{get:function(){return 4*this._array.length/this._stride},enumerable:!0,configurable:!0});Object.defineProperty(d.prototype,"itemSize",{get:function(){return this._stride},enumerable:!0,configurable:!0});Object.defineProperty(d.prototype,"sizeInBytes",{get:function(){return 4*this._array.length},enumerable:!0,configurable:!0});d.prototype.reset=function(){this.array.length=0};d.prototype.toBuffer=function(){return(new Uint32Array(this._array)).buffer};d.i1616to32=function(d,p){return 65535&
d|p<<16};d.i8888to32=function(d,p,h,b){return d&255|(p&255)<<8|(h&255)<<16|b<<24};d.i8816to32=function(d,p,h){return d&255|(p&255)<<8|h<<16};return d}()})},"esri/views/vectorTiles/renderers/rendererUtils":function(){define(["require","exports"],function(u,r){Object.defineProperty(r,"__esModule",{value:!0});var d=new Uint32Array(1),q=new Uint8Array(d.buffer);r.int32To4Bytes=function(p){d[0]=p|0;return[q[0],q[1],q[2],q[3]]}})},"esri/views/vectorTiles/renderers/CircleRenderer":function(){define("require exports ../../../core/libs/gl-matrix-2/gl-matrix ../GeometryUtils ./rendererUtils ../../webgl/VertexArrayObject".split(" "),
function(u,r,d,q,p,h){return function(){function b(b){this._viewProjMat=d.mat4f32.create();this._offsetVector=d.vec3f32.create();this._color=d.vec4f32.create();this._strokeColor=d.vec4f32.create();this._initialized=!1;this._programOptions={id:!1};this._programCache=b}b.prototype.dispose=function(){};b.prototype.render=function(b,c,a,e,h,m,k,n,v){if(0!==c.triangleElementCount){this._initialized||this._initialize(b);var f=k.hasDataDrivenRadius?1:k.getPaintValue("circle-radius",a),g=k.hasDataDrivenColor?
[1,1,1,1]:k.getPaintValue("circle-color",a),l=k.hasDataDrivenOpacity?1:k.getPaintValue("circle-opacity",a),t=k.hasDataDrivenStrokeWidth?1:k.getPaintValue("circle-stroke-width",a),w=k.hasDataDrivenStrokeColor?[1,1,1,1]:k.getPaintValue("circle-stroke-color",a),r=k.hasDataDrivenStrokeOpacity?1:k.getPaintValue("circle-stroke-opacity",a),u=k.hasDataDrivenBlur?0:k.getPaintValue("circle-blur",a),l=l*g[3]*v;this._color[0]=l*g[0];this._color[1]=l*g[1];this._color[2]=l*g[2];this._color[3]=l;l=r*w[3]*v;this._strokeColor[0]=
l*w[0];this._strokeColor[1]=l*w[1];this._strokeColor[2]=l*w[2];this._strokeColor[3]=l;v=m.tileTransform.transform;g=k.getPaintValue("circle-translate",a);if(0!==g[0]||0!==g[1])d.mat4.copy(this._viewProjMat,m.tileTransform.transform),v=g[0],g=g[1],r=w=0,r=(1<<m.key.level)/Math.pow(2,a)*(m.coordRange/512),1===k.getPaintValue("circle-translate-anchor",a)?(h*=-q.C_DEG_TO_RAD,a=Math.sin(h),h=Math.cos(h),w=r*(v*h-g*a),r*=v*a+g*h):(w=r*v,r*=g),this._offsetVector[0]=w,this._offsetVector[1]=r,this._offsetVector[2]=
0,d.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),v=this._viewProjMat;if(a=this._getCircleVAO(b,m))b.bindVAO(a),e=3===e,a=this._programOptions,a.id=e,a=this._programCache.getProgram(5,e?1:0,a),b.bindProgram(a),a.setUniformMatrix4fv("u_transformMatrix",v),a.setUniformMatrix4fv("u_extrudeMatrix",n),a.setUniform2fv("u_normalized_origin",m.tileTransform.displayCoord),a.setUniform1f("u_depth",k.z),a.setUniform1f("u_radius",f),a.setUniform4fv("u_color",this._color),a.setUniform1f("u_blur",
u),a.setUniform1f("u_stroke_width",t),a.setUniform4fv("u_stroke_color",this._strokeColor),a.setUniform1f("u_antialiasingWidth",1.2),e&&(m=p.int32To4Bytes(c.layerID),a.setUniform4f("u_id",m[0],m[1],m[2],m[3])),b.drawElements(4,c.triangleElementCount,5125,12*c.triangleElementStart),b.bindVAO()}};b.prototype._initialize=function(b){if(this._initialized)return!0;this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,
offset:4,stride:16,normalized:!0,divisor:0},{name:"a_stroke_color",count:4,type:5121,offset:8,stride:16,normalized:!0,divisor:0},{name:"a_data",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]};return this._initialized=!0};b.prototype._getCircleVAO=function(b,c){if(c.circleVertexArrayObject)return c.circleVertexArrayObject;var a=c.circleVertexBuffer,e=c.circleIndexBuffer;if(!a||!e)return null;c.circleVertexArrayObject=new h(b,this._programCache.getProgramAttributes(5),this._vertexAttributes,
{geometry:a},e);return c.circleVertexArrayObject};return b}()})},"esri/views/vectorTiles/renderers/FadeRecorder":function(){define(["require","exports","../../../core/now"],function(u,r,d){Object.defineProperty(r,"__esModule",{value:!0});(function(){return function(d,p){this.level=d;this.now=p}})();u=function(){return function(d,p,h,b){this.fadeSpeed=d;this.minfadeLevel=p;this.maxfadeLevel=h;this.fadeChange=b}}();r.FadeProperties=u;u=function(){function q(d){void 0===d&&(d=300);this._levelSnapshots=
[];this._duration=d}q.prototype.recordLevel=function(p){var h=d(),b=this._levelSnapshots;0===b.length&&(b.push({level:p,now:0}),b.push({level:p,now:0}));2!==b.length&&b[0].level===p||b.push({level:p,now:h})};q.prototype.needsRedraw=function(){if(0===this._levelSnapshots.length)return!1;for(var d=this._duration,h=this._levelSnapshots,b=h.length,f=h[b-1],c=-1;b>c+1&&h[c+1].now+d<f.now;)c++;for(0>c&&(c=0);c<b;c++)if(h[c].level!==f.level)return!0;return!1};q.prototype.getFadeValues=function(p){void 0===
p&&(p=!1);for(var h=this._duration,b=d(),f=this._levelSnapshots;3<f.length&&f[1].now+h<b;)f.shift();f[1].now+h<b&&(f[0].level=f[1].level);var c=f[0].level,a=f[f.length-1],e=a.level,w=Math.min(c,e),c=Math.max(c,e),f=(a.level-f[1].level)/((a.now-f[1].now)/h);return p?{fadeSpeed:0,minfadeLevel:w,maxfadeLevel:c,fadeChange:0}:{fadeSpeed:f,minfadeLevel:w,maxfadeLevel:c,fadeChange:(b-a.now)/h*f}};return q}();r.FadeRecorder=u})},"esri/views/vectorTiles/renderers/FillRenderer":function(){define("require exports ../../../core/libs/gl-matrix-2/gl-matrix ../GeometryUtils ./rendererUtils ../../webgl/VertexArrayObject".split(" "),
function(u,r,d,q,p,h){var b=1/65536;return function(){function f(b){this._viewProjMat=d.mat4f32.create();this._offsetVector=d.vec3f32.create();this._patternMatrix=d.mat3f32.create();this._color=d.vec4f32.create();this._outlineColor=d.vec4f32.create();this._initialized=!1;this._fillProgramOptions={id:!1,dd:!1,pattern:!1};this._outlineProgramOptions={id:!1,dd:!1};this._programCache=b}f.prototype.dispose=function(){};f.prototype.render=function(c,a,e,f,h,k,n,v,x,g,l){if(0!==a.triangleElementCount){this._initialized||
this._initialize(c);var m=void 0!==n.getPaintValue("fill-pattern",e),w=n.hasDataDrivenColor?[1,1,1,1]:n.getPaintValue("fill-color",e),r=n.hasDataDrivenOpacity?1:n.getPaintValue("fill-opacity",e),u=r*w[3]*l;this._color[0]=u*w[0];this._color[1]=u*w[1];this._color[2]=u*w[2];this._color[3]=u;var w=3===h,B;w&&(B=p.int32To4Bytes(a.layerID));var u=k.tileTransform.transform,D=k.coordRange/512,z=n.getPaintValue("fill-translate",e);if(0!==z[0]||0!==z[1]){d.mat4.copy(this._viewProjMat,k.tileTransform.transform);
var u=z[0],z=z[1],E=0,A=0,D=(1<<k.key.level)/Math.pow(2,e)*D;1===n.getPaintValue("fill-translate-anchor",e)?(E=-q.C_DEG_TO_RAD*f,f=Math.sin(E),A=Math.cos(E),E=D*(u*A-z*f),A=D*(u*f+z*A)):(E=D*u,A=D*z);this._offsetVector[0]=E;this._offsetVector[1]=A;this._offsetVector[2]=0;d.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector);u=this._viewProjMat}this._drawFill(c,a,e,h,k,n,v,u,g,l,w,B);if(n.getPaintValue("fill-antialias",e)&&!m&&0<a.outlineElementCount&&(1===h||3===h)){h=n.hasDataDrivenOutline;
if(n.outlineUsesFillColor){if(1!==this._color[3])return;this._outlineColor[0]=this._color[0];this._outlineColor[1]=this._color[1];this._outlineColor[2]=this._color[2];this._outlineColor[3]=this._color[3]}else e=n.hasDataDrivenOutlineColor?[1,1,1,1]:n.getPaintValue("fill-outline-color",e),l*=r*e[3],this._outlineColor[0]=l*e[0],this._outlineColor[1]=l*e[1],this._outlineColor[2]=l*e[2],this._outlineColor[3]=l;g=.75/g;if(l=this._getOutlineVAO(c,k,h))c.bindVAO(l),l=this._outlineProgramOptions,l.id=w,l.dd=
h,l=this._programCache.getProgram(2,(w?1:0)<<1|(h?1:0),l),c.bindProgram(l),l.setUniformMatrix4fv("u_transformMatrix",u),l.setUniformMatrix4fv("u_extrudeMatrix",x),l.setUniform2fv("u_normalized_origin",k.tileTransform.displayCoord),l.setUniform1f("u_depth",n.z+b),l.setUniform1f("u_outline_width",g),l.setUniform4fv("u_color",this._outlineColor),w&&l.setUniform4f("u_id",B[0],B[1],B[2],B[3]),c.drawElements(4,a.outlineElementCount,5125,12*a.outlineElementStart),c.bindVAO()}}};f.prototype._initialize=function(b){if(this._initialized)return!0;
this._fillVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:4,normalized:!1,divisor:0}]};this._fillVertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:8,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:4,stride:8,normalized:!0,divisor:0}]};this._outlineVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:8,normalized:!1,divisor:0},{name:"a_offset",count:2,type:5120,offset:4,stride:8,normalized:!1,divisor:0},
{name:"a_xnormal",count:2,type:5120,offset:6,stride:8,normalized:!1,divisor:0}]};this._outlineVertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:12,normalized:!1,divisor:0},{name:"a_offset",count:2,type:5120,offset:4,stride:12,normalized:!1,divisor:0},{name:"a_xnormal",count:2,type:5120,offset:6,stride:12,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:8,stride:12,normalized:!0,divisor:0}]};return this._initialized=!0};f.prototype._drawFill=function(c,
a,e,f,h,k,n,p,q,g,l,t){var m=k.getPaintValue("fill-pattern",e),w=void 0!==m,v=k.hasDataDrivenOpacity?1:g*k.getPaintValue("fill-opacity",e),x=k.hasDataDrivenColor?[1,1,1,1]:k.getPaintValue("fill-color",e);g*=v*x[3];this._color[0]=g*x[0];this._color[1]=g*x[1];this._color[2]=g*x[2];this._color[3]=g;x=k.hasDataDrivenFill;g=w||1>g||x;if(!g||0!==f)if(g||1!==f)if(f=this._getFillVAO(c,h,x)){c.bindVAO(f);f=this._fillProgramOptions;f.id=l;f.dd=x;f.pattern=w;f=this._programCache.getProgram(1,(l?1:0)<<2|(x?1:
0)<<1|(w?1:0),f);c.bindProgram(f);if(w){m=n.getMosaicItemPosition(m,!0);if(!m){c.bindVAO();c.bindProgram();return}e=h.coordRange/512/Math.pow(2,Math.round(e)-h.key.level)/q;d.mat3.identity(this._patternMatrix);q=1/(m.size[1]*e);this._patternMatrix[0]=1/(m.size[0]*e);this._patternMatrix[4]=q;n.bind(c,9729,m.page,5);f.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix);f.setUniform2f("u_pattern_tl",m.tl[0],m.tl[1]);f.setUniform2f("u_pattern_br",m.br[0],m.br[1]);f.setUniform1i("u_texture",5)}f.setUniformMatrix4fv("u_transformMatrix",
p);f.setUniform2fv("u_normalized_origin",h.tileTransform.displayCoord);f.setUniform1f("u_depth",k.z+b);f.setUniform4fv("u_color",this._color);l&&f.setUniform4f("u_id",t[0],t[1],t[2],t[3]);c.drawElements(4,a.triangleElementCount,5125,12*a.triangleElementStart);c.bindVAO()}};f.prototype._getFillVAO=function(b,a,e){if(e){if(a.fillDDVertexArrayObject)return a.fillDDVertexArrayObject;e=a.fillDDVertexBuffer;var c=a.fillIndexBuffer;if(!e||!c)return null;a.fillDDVertexArrayObject=new h(b,this._programCache.getProgramAttributes(1),
this._fillVertexAttributesDD,{geometry:e},c);return a.fillDDVertexArrayObject}if(a.fillVertexArrayObject)return a.fillVertexArrayObject;e=a.fillVertexBuffer;c=a.fillIndexBuffer;if(!e||!c)return null;a.fillVertexArrayObject=new h(b,this._programCache.getProgramAttributes(1),this._fillVertexAttributes,{geometry:e},c);return a.fillVertexArrayObject};f.prototype._getOutlineVAO=function(b,a,e){if(e){if(a.outlineDDVertexArrayObject)return a.outlineDDVertexArrayObject;e=a.outlineDDVertexBuffer;var c=a.outlineIndexBuffer;
if(!e||!c)return null;a.outlineDDVertexArrayObject=new h(b,this._programCache.getProgramAttributes(2),this._outlineVertexAttributesDD,{geometry:e},c);return a.outlineDDVertexArrayObject}if(a.outlineVertexArrayObject)return a.outlineVertexArrayObject;e=a.outlineVertexBuffer;c=a.outlineIndexBuffer;if(!e||!c)return null;a.outlineVertexArrayObject=new h(b,this._programCache.getProgramAttributes(2),this._outlineVertexAttributes,{geometry:e},c);return a.outlineVertexArrayObject};return f}()})},"esri/views/vectorTiles/renderers/LineRenderer":function(){define("require exports ../../../core/libs/gl-matrix-2/gl-matrix ../GeometryUtils ./rendererUtils ../../webgl/VertexArrayObject".split(" "),
function(u,r,d,q,p,h){return function(){function b(b){this._initialized=!1;this._viewProjMat=d.mat4f32.create();this._offsetVector=d.vec3f32.create();this._color=d.vec4f32.create();this._dashArray=d.vec2f32.create();this._programOptions={id:!1,dd:!1,pattern:!1};this._programCache=b}b.prototype.dispose=function(){};b.prototype.render=function(b,c,a,e,h,m,k,n,v,x,g){if(0!==c.triangleElementCount){this._initialized||this._initialize(b);var f=m.tileTransform.transform,t=m.coordRange/512,w=k.getPaintValue("line-translate",
a);if(0!==w[0]||0!==w[1]){d.mat4.copy(this._viewProjMat,m.tileTransform.transform);var f=w[0],w=w[1],r=0,u=0,u=(1<<m.key.level)/Math.pow(2,a)*t;h=h.rotation;if(1===k.getPaintValue("line-translate-anchor",a)){r=-q.C_DEG_TO_RAD*h;h=Math.sin(r);var B=Math.cos(r),r=u*(f*B-w*h),u=u*(f*h+w*B)}else r=u*f,u*=w;this._offsetVector[0]=r;this._offsetVector[1]=u;this._offsetVector[2]=0;d.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector);f=this._viewProjMat}w=k.getPaintValue("line-pattern",
a);u=void 0!==w;x=1/x;h=k.getPaintValue("line-blur",a);var B=k.hasDataDrivenColor?[1,1,1,1]:k.getPaintValue("line-color",a),D=k.hasDataDrivenOpacity?1:k.getPaintValue("line-opacity",a),r=k.hasDataDrivenWidth?1:k.getPaintValue("line-width",a);g*=D*B[3];this._color[0]=g*B[0];this._color[1]=g*B[1];this._color[2]=g*B[2];this._color[3]=g;g=k.hasDataDrivenLine;e=3===e;var z;e&&(z=p.int32To4Bytes(c.layerID));if(B=this._getLineVAO(b,m,g)){b.bindVAO(B);B=this._programOptions;B.id=e;B.dd=g;B.pattern=u;g=this._programCache.getProgram(3,
(e?1:0)<<2|(g?1:0)<<1|(u?1:0),B);b.bindProgram(g);g.setUniformMatrix4fv("u_transformMatrix",f);g.setUniformMatrix4fv("u_extrudeMatrix",v);g.setUniform2fv("u_normalized_origin",m.tileTransform.displayCoord);g.setUniform1f("u_depth",k.z);g.setUniform1f("u_blur",h);g.setUniform1f("u_antialiasing",x);g.setUniform4fv("u_color",this._color);g.setUniform1f("u_width",r);e&&g.setUniform4f("u_id",z[0],z[1],z[2],z[3]);if(u){if(a=n.getMosaicItemPosition(w,!0))n.bind(b,9729,a.page,5),g.setUniform2f("u_pattern_tl",
a.tl[0],a.br[1]),g.setUniform2f("u_pattern_br",a.br[0],a.tl[1]),g.setUniform2f("u_spriteSize",t*a.size[0],a.size[1]),g.setUniform1i("u_texture",5)}else n=k.getPaintValue("line-dasharray",a),2>n.length&&(n=[1,-1]),this._dashArray[0]=t*n[0],this._dashArray[1]=t*n[1],g.setUniform2fv("u_dasharray",this._dashArray);b.drawElements(4,c.triangleElementCount,5125,12*c.triangleElementStart);b.bindVAO()}}};b.prototype._initialize=function(b){if(this._initialized)return!0;this._vertexAttributes={geometry:[{name:"a_pos",
count:2,type:5122,offset:0,stride:12,normalized:!1,divisor:0},{name:"a_offsetAndNormal",count:4,type:5120,offset:4,stride:12,normalized:!1,divisor:0},{name:"a_accumulatedDistance",count:2,type:5123,offset:8,stride:12,normalized:!1,divisor:0}]};this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:20,normalized:!1,divisor:0},{name:"a_offsetAndNormal",count:4,type:5120,offset:4,stride:20,normalized:!1,divisor:0},{name:"a_accumulatedDistance",count:2,type:5122,offset:8,
stride:20,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:12,stride:20,normalized:!0,divisor:0},{name:"a_width",count:1,type:5126,offset:16,stride:20,normalized:!1,divisor:0}]};return this._initialized=!0};b.prototype._getLineVAO=function(b,c,a){if(a){if(c.lineDDVertexArrayObject)return c.lineDDVertexArrayObject;a=c.lineDDVertexBuffer;var e=c.lineIndexBuffer;if(!a||!e)return null;c.lineDDVertexArrayObject=new h(b,this._programCache.getProgramAttributes(3),this._vertexAttributesDD,
{geometry:a},e);return c.lineDDVertexArrayObject}if(c.lineVertexArrayObject)return c.lineVertexArrayObject;a=c.lineVertexBuffer;e=c.lineIndexBuffer;if(!a||!e)return null;c.lineVertexArrayObject=new h(b,this._programCache.getProgramAttributes(3),this._vertexAttributes,{geometry:a},e);return c.lineVertexArrayObject};return b}()})},"esri/views/vectorTiles/renderers/SymbolRenderer":function(){define(["require","exports","./IconRenderer","./SDFRenderer"],function(u,r,d,q){return function(){function p(h){this._iconRenderer=
new d(h);this._sdfRenderer=new q(h)}p.prototype.dispose=function(){this._iconRenderer&&(this._iconRenderer.dispose(),this._iconRenderer=null);this._sdfRenderer&&(this._sdfRenderer.dispose(),this._sdfRenderer=null)};p.prototype.render=function(d,b,f,c,a,e,w,m,k,n,p,q,g,l){b.hasData()&&(0<b.markerPerPageElementsMap.size&&this._iconRenderer.render(d,b,f,c,a,e,w,m,k,p,q,l),0<b.glyphPerPageElementsMap.size&&this._sdfRenderer.render(d,b,f,c,a,e,w,m,n,p,q,g,l))};return p}()})},"esri/views/vectorTiles/renderers/IconRenderer":function(){define("require exports ../../../core/libs/gl-matrix-2/gl-matrix ../GeometryUtils ./rendererUtils ../../webgl/VertexArrayObject".split(" "),
function(u,r,d,q,p,h){return function(){function b(b){this._viewProjMat=d.mat4f32.create();this._offsetVector=d.vec3f32.create();this._spritesTextureSize=d.vec2f32.create();this._color=d.vec4f32.create();this._initialized=!1;this._programOptions={id:!1,dd:!1,sdf:!1};this._programCache=b}b.prototype.dispose=function(){};b.prototype.render=function(b,c,a,e,h,m,k,n,v,x,g,l){var f=this;this._initialized||this._initialize(b);var w=n.hasDataDrivenIconSize?1:n.getLayoutValue("icon-size",a),r=n.hasDataDrivenIconColor?
[1,1,1,1]:n.getPaintValue("icon-color",a),u=n.hasDataDrivenIconOpacity?1:n.getPaintValue("icon-opacity",a);l*=r[3]*u;this._color[0]=l*r[0];this._color[1]=l*r[1];this._color[2]=l*r[2];this._color[3]=l;r=n.getLayoutValue("icon-rotation-alignment",a);2===r&&(r=1===n.getLayoutValue("symbol-placement",a)?0:1);var B=0===r;l=c.isSDF;u=n.hasDataDrivenIcon;e=3===e;var r=q.degToByte(h),D=k.tileTransform.transform,z=n.getPaintValue("icon-translate",a);if(0!==z[0]||0!==z[1]){d.mat4.copy(this._viewProjMat,k.tileTransform.transform);
var D=z[0],z=z[1],E=0,A=0,A=(1<<k.key.level)/Math.pow(2,a)*(k.coordRange/512);if(1===n.getPaintValue("icon-translate-anchor",a)){E=-q.C_DEG_TO_RAD*h;h=Math.sin(E);var H=Math.cos(E),E=A*(D*H-z*h),A=A*(D*h+z*H)}else E=A*D,A*=z;this._offsetVector[0]=E;this._offsetVector[1]=A;this._offsetVector[2]=0;d.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector);D=this._viewProjMat}x=B?x:g;if(g=this._getIconVAO(b,k,u)){b.bindVAO(g);g=this._programOptions;g.id=e;g.dd=u;g.sdf=l;var y=this._programCache.getProgram(4,
(e?1:0)<<2|(u?1:0)<<1|(l?1:0),g);b.bindProgram(y);l&&(g=n.getPaintValue("icon-halo-color",a),l=n.getPaintValue("icon-halo-width",a),y.setUniform4f("u_outlineColor",g[0],g[1],g[2],g[3]),y.setUniform1f("u_outlineSize",l));y.setUniformMatrix4fv("u_transformMatrix",D);y.setUniformMatrix4fv("u_extrudeMatrix",x);y.setUniform2fv("u_normalized_origin",k.tileTransform.displayCoord);y.setUniform1f("u_depth",n.z);y.setUniform1f("u_mapRotation",r);y.setUniform1f("u_keepUpright",0);y.setUniform1f("u_level",10*
a);y.setUniform1f("u_fadeSpeed",10*m.fadeSpeed);y.setUniform1f("u_minfadeLevel",10*m.minfadeLevel);y.setUniform1f("u_maxfadeLevel",10*m.maxfadeLevel);y.setUniform1f("u_fadeChange",10*(a+m.fadeChange));y.setUniform1i("u_texture",5);y.setUniform1f("u_size",w);y.setUniform4fv("u_color",this._color);e&&(a=p.int32To4Bytes(c.layerID),y.setUniform4f("u_id",a[0],a[1],a[2],a[3]));c.markerPerPageElementsMap.forEach(function(a,c){f._spritesTextureSize[0]=v.getWidth(c)/4;f._spritesTextureSize[1]=v.getHeight(c)/
4;y.setUniform2fv("u_mosaicSize",f._spritesTextureSize);v.bind(b,9729,c,5);b.drawElements(4,a[1],5125,12*a[0])});b.bindVAO()}};b.prototype._initialize=function(b){if(this._initialized)return!0;this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:16,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:16,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,
offset:12,stride:16,normalized:!1,divisor:0}]};this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:24,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:24,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:24,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:24,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:16,stride:24,normalized:!0,divisor:0},{name:"a_size",count:1,
type:5126,offset:20,stride:24,normalized:!1,divisor:0}]};return this._initialized=!0};b.prototype._getIconVAO=function(b,c,a){if(a){if(c.iconDDVertexArrayObject)return c.iconDDVertexArrayObject;a=c.iconDDVertexBuffer;var e=c.iconIndexBuffer;if(!a||!e)return null;c.iconDDVertexArrayObject=new h(b,this._programCache.getProgramAttributes(4),this._vertexAttributesDD,{geometry:a},e);return c.iconDDVertexArrayObject}if(c.iconVertexArrayObject)return c.iconVertexArrayObject;a=c.iconVertexBuffer;e=c.iconIndexBuffer;
if(!a||!e)return null;c.iconVertexArrayObject=new h(b,this._programCache.getProgramAttributes(4),this._vertexAttributes,{geometry:a},e);return c.iconVertexArrayObject};return b}()})},"esri/views/vectorTiles/renderers/SDFRenderer":function(){define("require exports ../../../core/has ../../../core/libs/gl-matrix-2/gl-matrix ../GeometryUtils ./rendererUtils ../../webgl/VertexArrayObject".split(" "),function(u,r,d,q,p,h,b){var f=1/65536;return function(){function c(a){this._viewProjMat=q.mat4f32.create();
this._offsetVector=q.vec3f32.create();this._extrudeMat=q.mat4f32.create();this._scaleVec=q.vec3f32.create();this._haloColor=q.vec4f32.create();this._sdfColor=q.vec4f32.create();this._initialized=!1;this._programOptions={id:!1,dd:!1};this._programCache=a}c.prototype.dispose=function(){};c.prototype.render=function(a,b,c,m,k,n,v,r,g,l,t,u,I){var e=this;if(!d("esri-vector-tiles-avoid-text")){this._initialized||this._initialize(a);var w=p.degToByte(k),x=r.getLayoutValue("text-rotation-alignment",c);2===
x&&(x=1===r.getLayoutValue("symbol-placement",c)?0:1);var z=0===x,x=r.getLayoutValue("text-keep-upright",c)&&z;m=3===m;u=.8*3/u;var K=r.hasDataDrivenTextSize?1:r.getLayoutValue("text-size",c),A=r.hasDataDrivenTextColor?[1,1,1,1]:r.getPaintValue("text-color",c),H=r.hasDataDrivenTextOpacity?1:r.getPaintValue("text-opacity",c),y=A[3]*H*I;this._sdfColor[0]=y*A[0];this._sdfColor[1]=y*A[1];this._sdfColor[2]=y*A[2];this._sdfColor[3]=y;this._glyphTextureSize||(this._glyphTextureSize=q.vec2f32.fromValues(g.width/
4,g.height/4));A=v.tileTransform.transform;y=r.getPaintValue("text-translate",c);if(0!==y[0]||0!==y[1]){q.mat4.copy(this._viewProjMat,v.tileTransform.transform);var A=y[0],y=y[1],G=0,F=0,F=(1<<v.key.level)/Math.pow(2,c)*(v.coordRange/512);if(1===r.getPaintValue("text-translate-anchor",c)){G=-p.C_DEG_TO_RAD*k;k=Math.sin(G);var J=Math.cos(G),G=F*(A*J-y*k),F=F*(A*k+y*J)}else G=F*A,F*=y;this._offsetVector[0]=G;this._offsetVector[1]=F;this._offsetVector[2]=0;q.mat4.translate(this._viewProjMat,this._viewProjMat,
this._offsetVector);A=this._viewProjMat}z?q.mat4.copy(this._extrudeMat,l):q.mat4.copy(this._extrudeMat,t);this._scaleVec[0]=1/24;this._scaleVec[1]=1/24;this._scaleVec[2]=1;q.mat4.scale(this._extrudeMat,this._extrudeMat,this._scaleVec);l=r.hasDataDrivenText;if(t=this._getSDFVAO(a,v,l)){a.bindVAO(t);t=this._programOptions;t.id=m;t.dd=l;var C=this._programCache.getProgram(6,(m?1:0)<<1|(l?1:0),t);a.bindProgram(C);C.setUniformMatrix4fv("u_transformMatrix",A);C.setUniformMatrix4fv("u_extrudeMatrix",this._extrudeMat);
C.setUniform2fv("u_normalized_origin",v.tileTransform.displayCoord);C.setUniform1f("u_depth",r.z+f);C.setUniform2fv("u_mosaicSize",this._glyphTextureSize);C.setUniform1f("u_mapRotation",w);C.setUniform1f("u_keepUpright",x?1:0);C.setUniform1f("u_level",10*c);C.setUniform1f("u_fadeSpeed",10*n.fadeSpeed);C.setUniform1f("u_minfadeLevel",10*n.minfadeLevel);C.setUniform1f("u_maxfadeLevel",10*n.maxfadeLevel);C.setUniform1f("u_fadeChange",10*(c+n.fadeChange));C.setUniform1i("u_texture",6);C.setUniform1f("u_size",
K);C.setUniform1f("u_antialiasingWidth",u);m&&(n=h.int32To4Bytes(b.layerID),C.setUniform4f("u_id",n[0],n[1],n[2],n[3]));b.glyphPerPageElementsMap.forEach(function(b,d){e._renderGlyphRange(a,b,d,r,g,C,c,H*I,3)});a.bindVAO()}}};c.prototype._renderGlyphRange=function(a,b,c,d,f,h,p,q,g){f.bind(a,9729,c,6);f=d.getPaintValue("text-halo-color",p);c=d.getPaintValue("text-halo-width",p);0<f[3]&&0<c&&(q*=f[3],this._haloColor[0]=q*f[0],this._haloColor[1]=q*f[1],this._haloColor[2]=q*f[2],this._haloColor[3]=q,
d=d.getPaintValue("text-halo-blur",p)*g,g*=c,h.setUniform4fv("u_color",this._haloColor),h.setUniform1f("u_halo",1),h.setUniform1f("u_edgeDistance",g),h.setUniform1f("u_edgeBlur",d),a.drawElements(4,b[1],5125,12*b[0]));0<this._sdfColor[3]&&(h.setUniform4fv("u_color",this._sdfColor),h.setUniform1f("u_halo",0),h.setUniform1f("u_edgeDistance",0),h.setUniform1f("u_edgeBlur",0),a.drawElements(4,b[1],5125,12*b[0]))};c.prototype._initialize=function(a){if(this._initialized)return!0;this._vertexAttributes=
{geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:16,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:16,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]};this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:24,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:24,
normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:24,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:24,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:16,stride:24,normalized:!0,divisor:0},{name:"a_size",count:1,type:5126,offset:20,stride:24,normalized:!1,divisor:0}]};return this._initialized=!0};c.prototype._getSDFVAO=function(a,c,d){if(d){if(c.textDDVertexArrayObject)return c.textDDVertexArrayObject;d=c.textDDVertexBuffer;
var e=c.textIndexBuffer;if(!d||!e)return null;c.textDDVertexArrayObject=new b(a,this._programCache.getProgramAttributes(6),this._vertexAttributesDD,{geometry:d},e);return c.textDDVertexArrayObject}if(c.textVertexArrayObject)return c.textVertexArrayObject;d=c.textVertexBuffer;e=c.textIndexBuffer;if(!d||!e)return null;c.textVertexArrayObject=new b(a,this._programCache.getProgramAttributes(6),this._vertexAttributes,{geometry:d},e);return c.textVertexArrayObject};return c}()})},"esri/views/vectorTiles/renderers/TileInfoRenderer":function(){define("require exports ../../../core/libs/gl-matrix-2/gl-matrix ../GeometryUtils ../../webgl/BufferObject ../../webgl/Texture ../../webgl/VertexArrayObject".split(" "),
function(u,r,d,q,p,h,b){return function(){function f(b){this._initialized=!1;this._color=d.vec4f32.fromValues(1,0,0,1);this._maxWidth=0;this._programOptions={id:!1,pattern:!1};this._programCache=b}f.prototype.dispose=function(){this._outlineVertexArrayObject&&(this._outlineVertexArrayObject.dispose(),this._outlineVertexArrayObject=null);this._tileInfoVertexArrayObject&&(this._tileInfoVertexArrayObject.dispose(),this._tileInfoVertexArrayObject=null)};f.prototype.render=function(b,a){this._initialized||
this._initialize(b);var c=this._programCache.getProgram(0,0,this._programOptions);if(c&&(b.bindVAO(this._outlineVertexArrayObject),b.bindProgram(c),c.setUniformMatrix4fv("u_transformMatrix",a.tileTransform.transform),c.setUniform2fv("u_normalized_origin",a.tileTransform.displayCoord),c.setUniform1f("u_coord_range",a.coordRange),c.setUniform1f("u_depth",0),c.setUniform4fv("u_color",this._color),b.setLineWidth(2),b.drawArrays(3,0,4),b.bindVAO(),c=this._getTexture(b,a))){var d=this._programCache.getProgram(7,
0,null);d&&(b.bindVAO(this._tileInfoVertexArrayObject),b.bindProgram(d),b.bindTexture(c,0),d.setUniformMatrix4fv("u_transformMatrix",a.tileTransform.transform),d.setUniform2fv("u_normalized_origin",a.tileTransform.displayCoord),d.setUniform1f("u_depth",0),d.setUniform1f("u_coord_ratio",a.coordRange/512),d.setUniform2f("u_delta",8,8),d.setUniform2f("u_dimensions",c.descriptor.width,c.descriptor.height),b.drawArrays(5,0,4),b.bindVAO())}};f.prototype._initialize=function(c){if(this._initialized)return!0;
var a={geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:2,normalized:!1,divisor:0}]},d=new Int8Array([0,0,1,0,1,1,0,1]),d=p.createVertex(c,35044,d),d=new b(c,this._programCache.getProgramAttributes(0),a,{geometry:d}),f=new Int8Array([0,0,1,0,0,1,1,1]),f=p.createVertex(c,35044,f);c=new b(c,this._programCache.getProgramAttributes(7),a,{geometry:f});this._outlineVertexArrayObject=d;this._tileInfoVertexArrayObject=c;return this._initialized=!0};f.prototype._getTexture=function(b,a){if(a.texture)return a.texture;
this._canvas||(this._canvas=document.createElement("canvas"),this._canvas.setAttribute("id","canvas2d"),this._canvas.setAttribute("width","256"),this._canvas.setAttribute("height","32"),this._canvas.setAttribute("style","display:none"));var c=a.key.id,d=this._canvas.getContext("2d");d.font="24px sans-serif";d.textAlign="left";d.textBaseline="middle";var f=d.measureText(c),f=Math.pow(2,Math.ceil(q.log2(f.width+2)));f>this._maxWidth&&(this._maxWidth=f);d.clearRect(0,0,this._maxWidth,32);d.fillStyle=
a.key.level>a.refKey.level?"red":"blue";d.fillText(c,0,16);a.texture=new h(b,{target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728},this._canvas);return a.texture};return f}()})},"esri/views/vectorTiles/renderers/shaders/ProgramCache":function(){define(["require","exports","./Programs","../../../webgl/programUtils"],function(u,r,d,q){Object.defineProperty(r,"__esModule",{value:!0});u=function(){function p(){this._cache=Array(8);for(var d=0;8>d;d++)this._cache[d]={}}p.prototype.dispose=function(){this._programRepo&&
(this._programRepo.dispose(),this._programRepo=null)};p.prototype.getProgram=function(d,b,f){var c=this._cache[d];c[b]||(d=this._programRepo.getProgram(this._getProgramTemplate(d),f),c[b]=d);return c[b]};p.prototype.getProgramAttributes=function(h){switch(h){case 0:return d.background.attributes;case 5:return d.circle.attributes;case 1:return d.fill.attributes;case 4:return d.icon.attributes;case 3:return d.line.attributes;case 2:return d.outline.attributes;case 6:return d.text.attributes;case 7:return d.tileInfo.attributes}};
p.prototype.initialize=function(d){this._programRepo||(this._programRepo=new q.ProgramCache(d))};p.prototype._getProgramTemplate=function(h){switch(h){case 0:return d.background;case 5:return d.circle;case 1:return d.fill;case 4:return d.icon;case 3:return d.line;case 2:return d.outline;case 6:return d.text;case 7:return d.tileInfo}};return p}();r.default=u})},"esri/views/vectorTiles/renderers/shaders/Programs":function(){define(["require","exports","./sources/resolver","../../../webgl/programUtils"],
function(u,r,d,q){Object.defineProperty(r,"__esModule",{value:!0});r.background={name:"background",shaders:function(b){return{vertexShader:q.glslifyDefineMap({ID:b.id,PATTERN:b.pattern})+d.resolveIncludes("background/background.vert"),fragmentShader:q.glslifyDefineMap({ID:b.id,PATTERN:b.pattern})+d.resolveIncludes("background/background.frag")}},attributes:{a_pos:0}};r.circle={name:"circle",shaders:function(b){return{vertexShader:q.glslifyDefineMap({ID:b.id})+d.resolveIncludes("circle/circle.vert"),
fragmentShader:q.glslifyDefineMap({ID:b.id})+d.resolveIncludes("circle/circle.frag")}},attributes:{a_pos:0,a_color:1,a_stroke_color:2,a_data:3}};var p=function(b){return q.glslifyDefineMap({ID:b.id,DD:b.dd,PATTERN:b.pattern})};r.fill={name:"fill",shaders:function(b){return{vertexShader:p(b)+d.resolveIncludes("fill/fill.vert"),fragmentShader:p(b)+d.resolveIncludes("fill/fill.frag")}},attributes:{a_pos:0,a_color:1}};r.outline={name:"outline",shaders:function(b){return{vertexShader:q.glslifyDefineMap({ID:b.id,
DD:b.dd})+d.resolveIncludes("outline/outline.vert"),fragmentShader:q.glslifyDefineMap({ID:b.id,DD:b.dd})+d.resolveIncludes("outline/outline.frag")}},attributes:{a_pos:0,a_offset:1,a_xnormal:2,a_color:3}};r.icon={name:"icon",shaders:function(b){return{vertexShader:q.glslifyDefineMap({ID:b.id,DD:b.dd,SDF:b.sdf})+d.resolveIncludes("icon/icon.vert"),fragmentShader:q.glslifyDefineMap({ID:b.id,DD:b.dd,SDF:b.sdf})+d.resolveIncludes("icon/icon.frag")}},attributes:{a_pos:0,a_vertexOffset:1,a_tex:2,a_levelInfo:3,
a_color:4,a_size:5}};var h=function(b){return q.glslifyDefineMap({ID:b.id,DD:b.dd,PATTERN:b.pattern})};r.line={name:"line",shaders:function(b){return{vertexShader:h(b)+d.resolveIncludes("line/line.vert"),fragmentShader:h(b)+d.resolveIncludes("line/line.frag")}},attributes:{a_pos:0,a_offsetAndNormal:1,a_accumulatedDistance:2,a_color:3,a_width:4}};r.text={name:"text",shaders:function(b){return{vertexShader:q.glslifyDefineMap({ID:b.id,DD:b.dd})+d.resolveIncludes("text/text.vert"),fragmentShader:q.glslifyDefineMap({ID:b.id,
DD:b.dd})+d.resolveIncludes("text/text.frag")}},attributes:{a_pos:0,a_vertexOffset:1,a_tex:2,a_levelInfo:3,a_color:4,a_size:5}};r.tileInfo={name:"tileInfo",shaders:{vertexShader:d.resolveIncludes("tileInfo/tileInfo.vert"),fragmentShader:d.resolveIncludes("tileInfo/tileInfo.frag")},attributes:{a_pos:0}}})},"esri/views/vectorTiles/renderers/shaders/sources/resolver":function(){define(["require","exports","./shaderRepository","../../../../webgl/ShaderCompiler"],function(u,r,d,q){Object.defineProperty(r,
"__esModule",{value:!0});var p=new q(function(h){var b=d;h.split("/").forEach(function(d){b&&(b=b[d])});return b});r.resolveIncludes=function(d){return p.resolveIncludes(d)}})},"esri/views/vectorTiles/renderers/shaders/sources/shaderRepository":function(){define(["require","exports"],function(u,r){return{background:{"background.frag":"#ifdef PATTERN\r\nuniform lowp float u_opacity;\r\nuniform mediump vec2 u_pattern_tl;\r\nuniform mediump vec2 u_pattern_br;\r\nuniform sampler2D u_texture;\r\n\r\nvarying mediump vec2 v_tileTextureCoord;\r\n#else\r\nuniform lowp vec4 u_color;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvoid main() {\r\n#ifdef PATTERN\r\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\r\n  mediump vec2 normalizedTextureCoord \x3d mod(v_tileTextureCoord, 1.0);\r\n\r\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\r\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\r\n  // we need to only sample from area that has our sprite in the mosaic.\r\n  mediump vec2 samplePos \x3d mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\r\n\r\n  // sample the sprite mosaic\r\n  lowp vec4 color \x3d texture2D(u_texture, samplePos);\r\n  gl_FragColor \x3d u_opacity * color;\r\n#else\r\n  gl_FragColor \x3d u_color;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"background.vert":"precision mediump float;\r\n\r\nattribute vec2 a_pos;\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform mediump vec2 u_normalized_origin;\r\nuniform mediump float u_coord_range;\r\nuniform mediump float u_depth;\r\n\r\n#ifdef PATTERN\r\nuniform mediump mat3 u_pattern_matrix; // can we use medium precision?\r\nvarying mediump vec2 v_tileTextureCoord;\r\n#endif // PATTERN\r\n\r\nvoid main() {\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(u_coord_range * a_pos, 0.0, 1.0);\r\n\r\n#ifdef PATTERN\r\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\r\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\r\n  v_tileTextureCoord \x3d (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\n  v_id \x3d u_id / 255.0;\r\n#endif // ID\r\n}\r\n"},
circle:{"circle.frag":"precision lowp float;\r\n\r\nvarying lowp vec4 v_color;\r\nvarying lowp vec4 v_stroke_color;\r\nvarying mediump float v_blur;\r\nvarying mediump float v_stroke_width;\r\nvarying mediump float v_radius;\r\nvarying mediump vec2 v_offset;\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvoid main()\r\n{\r\n  mediump float dist \x3d length(v_offset);\r\n\r\n  mediump float alpha \x3d smoothstep(0.0, -v_blur, dist - 1.0);\r\n\r\n  lowp float color_mix_ratio \x3d v_stroke_width \x3c 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\r\n\r\n  gl_FragColor \x3d alpha * mix(v_color, v_stroke_color, color_mix_ratio);\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"circle.vert":"precision mediump float;\r\n\r\nattribute vec2 a_pos;\r\nattribute vec4 a_color;\r\nattribute vec4 a_stroke_color;\r\nattribute vec4 a_data;\r\n\r\nconst float sizePrecision \x3d 0.25; // 1/4\r\nconst float blurPrecision \x3d 0.03125; // 1/32\r\n\r\nvarying lowp vec4 v_color;\r\nvarying lowp vec4 v_stroke_color;\r\nvarying mediump float v_blur;\r\nvarying mediump float v_stroke_width;\r\nvarying mediump float v_radius;\r\nvarying mediump vec2 v_offset;\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\r\n// relative to the tile's upper left corner\r\n// the extrusion vector.\r\nuniform highp mat4 u_transformMatrix;\r\n\r\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\r\nuniform highp mat4 u_extrudeMatrix;\r\n\r\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\r\nuniform highp vec2 u_normalized_origin;\r\n\r\n// the z of the layer. Given by the order of the layers in the style\r\nuniform mediump float u_depth;\r\n\r\n// the opacity of the layer given by the painter\r\nuniform mediump float u_radius;\r\nuniform lowp vec4 u_color;\r\nuniform mediump float u_blur;\r\nuniform mediump float u_stroke_width;\r\nuniform lowp vec4 u_stroke_color;\r\n\r\nuniform mediump float u_antialiasingWidth; // antialiasing (factors in the pixel_ratio for high res devices)\r\n\r\nvoid main()\r\n{\r\n  v_color \x3d a_color * u_color;\r\n  v_stroke_color \x3d a_stroke_color * u_stroke_color;\r\n  v_stroke_width \x3d a_data[1] * sizePrecision * u_stroke_width;\r\n  v_radius \x3d a_data[2] * u_radius;\r\n  v_blur \x3d max(a_data[0] * blurPrecision + u_blur, u_antialiasingWidth / (v_radius + v_stroke_width));\r\n\r\n  mediump vec2 offset \x3d vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\r\n  v_offset \x3d offset;\r\n\r\n#ifdef ID\r\n  v_id \x3d u_id / 255.0;\r\n#endif // ID\r\n\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos * 0.5, 0.0, 1.0) + u_extrudeMatrix * (v_radius + v_stroke_width) * vec4(offset, 0.0, 0.0);\r\n}\r\n"},
fill:{"fill.frag":"precision lowp float;\r\n\r\n#ifdef PATTERN\r\nuniform mediump vec2 u_pattern_tl;\r\nuniform mediump vec2 u_pattern_br;\r\nuniform lowp sampler2D u_texture;\r\nvarying mediump vec2 v_tileTextureCoord;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvarying lowp vec4 v_color;\r\n\r\nvec4 mixColors(vec4 color1, vec4 color2) {\r\n  // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending)\r\n  // we use pre-multiplied colors hence the need for this kind of mixing. At lease we save ourselves an extra division...\r\n  float compositeAlpha \x3d color2.a + color1.a * (1.0 - color2.a);\r\n  vec3 compositeColor \x3d color2.rgb + color1.rgb * (1.0 - color2.a);\r\n\r\n  return vec4(compositeColor, compositeAlpha);\r\n}\r\n\r\nvoid main()\r\n{\r\n#ifdef PATTERN\r\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\r\n  mediump vec2 normalizedTextureCoord \x3d mod(v_tileTextureCoord, 1.0);\r\n\r\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\r\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\r\n  // we need to only sample from area that has our sprite in the mosaic.\r\n  mediump vec2 samplePos \x3d mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\r\n\r\n  // sample the sprite mosaic\r\n  lowp vec4 color \x3d texture2D(u_texture, samplePos);\r\n  gl_FragColor \x3d v_color[3] * color;\r\n#else\r\n  gl_FragColor \x3d v_color;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"fill.vert":"precision mediump float;\r\n\r\nattribute vec2 a_pos;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\n\r\n#ifdef PATTERN\r\nuniform mediump mat3 u_pattern_matrix;\r\nvarying mediump vec2 v_tileTextureCoord;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\n#ifdef DD\r\nattribute vec4 a_color;\r\n#endif // DD\r\nuniform lowp vec4 u_color;\r\nvarying lowp vec4 v_color;\r\n\r\nvoid main()\r\n{\r\n#ifdef DD\r\n  v_color \x3d a_color * u_color;\r\n#else\r\n  v_color \x3d u_color;\r\n#endif // DD\r\n\r\n#ifdef ID\r\n  v_id \x3d u_id / 255.0;\r\n#endif // ID\r\n\r\n#ifdef PATTERN\r\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\r\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\r\n  // (-4k to 8k -1) to texture coordinates.\r\n  v_tileTextureCoord \x3d (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\r\n#endif // PATTERN\r\n\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0, 1.0);\r\n}\r\n"},
icon:{"icon.frag":"precision mediump float;\r\n\r\nuniform lowp sampler2D u_texture; // SDF texture\r\n#ifdef SDF\r\nuniform lowp vec4 u_color; // a color to override the one of the vertex\r\nuniform lowp vec4 u_outlineColor;\r\nuniform mediump float u_outlineSize;\r\n#endif // SDF\r\n\r\nvarying mediump vec2 v_tex;\r\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\r\n// opacity of the layer given by the painter\r\nvarying lowp float v_transparency;\r\n\r\nvarying mediump vec2 v_size;\r\n\r\nvarying lowp vec4 v_color;\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\n// we need the conversion function from RGBA to float\r\n#include \x3cutil/encoding.glsl\x3e\r\n\r\nvec4 mixColors(vec4 color1, vec4 color2) {\r\n  // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending)\r\n  // we use pre-multiplied colors hence the need for this kind of mixing. At lease we save ourselves an extra division...\r\n  float compositeAlpha \x3d color2.a + color1.a * (1.0 - color2.a);\r\n  vec3 compositeColor \x3d color2.rgb + color1.rgb * (1.0 - color2.a);\r\n\r\n  return vec4(compositeColor, compositeAlpha);\r\n}\r\n\r\nvoid main()\r\n{\r\n#ifdef SDF\r\n  lowp vec4 fillPixelColor \x3d v_color;\r\n\r\n  // calculate the distance from the edge [-0.5, 0.5]\r\n  float d \x3d rgba2float(texture2D(u_texture, v_tex)) - 0.5;\r\n\r\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\r\n  // 1 / 86 represents a single pixel given the size of the SDF is 128 and we add 4 pixels margins to deal with\r\n  // other non SDF types.\r\n  // The rasterized geometry takes only 86 pixels because of the extra 16 pixels margin for the outline.\r\n  const float sofetEdgeRatio \x3d 0.248062016; // \x3d\x3d\x3e (32.0 / 86.0) / 1.5;\r\n  float size \x3d max(v_size.x, v_size.y);\r\n  float dist \x3d d * sofetEdgeRatio * size;\r\n\r\n  // set the fragment's transparency according to the distance from the edge\r\n  fillPixelColor *\x3d clamp(0.5 - dist, 0.0, 1.0);\r\n\r\n  // count for the outline\r\n  // therefore tint the entire icon area.\r\n  if (u_outlineSize \x3e 0.25) {\r\n    lowp vec4 outlinePixelColor \x3d u_outlineColor;\r\n    // the outline limit ratio is derived from the 16 pixels allocated for the outline and the fact that 1/86 represents\r\n    // a single pixel.\r\n    const float outlineLimitRatio \x3d (16.0 / 86.0);\r\n    float clampedOutlineSize \x3d sofetEdgeRatio * min(u_outlineSize, outlineLimitRatio * max(v_size.x, v_size.y));\r\n\r\n    outlinePixelColor *\x3d clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\r\n\r\n    // finally combine the outline and the fill colors\r\n    gl_FragColor \x3d v_transparency * mixColors(fillPixelColor, outlinePixelColor);\r\n  }\r\n  else {\r\n    gl_FragColor \x3d v_transparency * fillPixelColor;\r\n  }\r\n#else // not an SDF\r\n  lowp vec4 texColor \x3d texture2D(u_texture, v_tex);\r\n  gl_FragColor \x3d v_transparency * texColor;\r\n#endif // SDF\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"icon.vert":"attribute vec2 a_pos;\r\nattribute vec2 a_vertexOffset;\r\nattribute vec4 a_tex;\r\nattribute vec4 a_levelInfo;\r\n\r\n#ifdef DD\r\nattribute vec4 a_color;\r\nattribute mediump float a_size;\r\n#endif // DD\r\nuniform lowp vec4 u_color;\r\nuniform mediump float u_size;\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvarying lowp vec4 v_color;\r\n\r\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\r\n// relative to the tile's upper left corner\r\n// the extrusion vector.\r\nuniform highp mat4 u_transformMatrix;\r\n\r\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\r\nuniform highp mat4 u_extrudeMatrix;\r\n\r\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\r\nuniform highp vec2 u_normalized_origin;\r\n\r\n// the size of the mosaic given in pixels\r\nuniform vec2 u_mosaicSize;\r\n\r\n// the z of the layer. Given by the order of the layers in the style\r\nuniform mediump float u_depth;\r\n\r\n// the map's rotation from the north\r\nuniform mediump float u_mapRotation;\r\nuniform mediump float u_level;\r\n\r\n// indicate whether the current set of iconst should be kept upright when the map is rotated\r\nuniform lowp float u_keepUpright;\r\n\r\n// the rate of the change in the opacity (fade) of the icons\r\nuniform mediump float u_fadeSpeed;\r\n\r\n// the low level we transition (to/from)\r\nuniform mediump float u_minfadeLevel;\r\n\r\n// the high level we transition (to/from)\r\nuniform mediump float u_maxfadeLevel;\r\n\r\n// the amount of fade given teh current time past the last recorded level\r\nuniform mediump float u_fadeChange;\r\n\r\n// the opacity of the layer given by the painter\r\nuniform mediump float u_opacity;\r\n\r\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\r\nvarying mediump vec2 v_tex;\r\n\r\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\r\n// opacity of the layer given by the painter\r\nvarying lowp float v_transparency;\r\n\r\nvarying mediump vec2 v_size;\r\n\r\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precision we multiply the values\r\n// by 8 and then at the shader devide by the same number\r\nconst float C_OFFSET_PRECISION \x3d 1.0 / 8.0;\r\n\r\nconst float C_256_TO_RAD \x3d 3.14159265359 / 128.0;\r\nconst float C_DEG_TO_RAD \x3d 3.14159265359 / 180.0;\r\nconst float tileCoordRatio \x3d 1.0 / 8.0;\r\n\r\nvoid main()\r\n{\r\n  mediump float a_labelMinLevel \x3d a_levelInfo[0];\r\n  mediump float a_angle         \x3d a_levelInfo[1];\r\n  mediump float a_minLevel      \x3d a_levelInfo[2];\r\n  mediump float a_maxLevel      \x3d a_levelInfo[3];\r\n\r\n  // if the given vertex should not be visible simply clip it by adding it a value that will push it outside the clipping plane\r\n  mediump float delta_z \x3d 0.0;\r\n\r\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\r\n  mediump float rotated \x3d mod(a_angle + u_mapRotation, 256.0);\r\n  delta_z +\x3d (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated)); //ie. z +\x3d (flip \x3e 0) \x26\x26 (64 \x3c\x3d rotated) \x26\x26 (rotated \x3c 192)\r\n\r\n  // u_level is the current service level adjusted for the change in font size\r\n  delta_z +\x3d 1.0 - step(a_minLevel, u_level); // Test if (level \x3c minLevel)\r\n  delta_z +\x3d step(a_maxLevel, u_level); // Test if (maxLevel \x3c\x3d level)\r\n\r\n  // calculate the alpha given the change in the fade and the fade-speed\r\n  lowp float alpha \x3d clamp((u_fadeChange - a_labelMinLevel) / u_fadeSpeed, 0.0, 1.0);\r\n\r\n  // if the speed is positive we are zooming in and therefore we need to 'fade-in'. Else we need to 'fade-out'\r\n  v_transparency \x3d (u_fadeSpeed \x3e\x3d 0.0 ? alpha : 1.0 - alpha);\r\n\r\n  // now deal with the min/max fade-levels. If we exceeded the level we simply snap to 0 or 1\r\n  if (u_maxfadeLevel \x3c a_labelMinLevel)\r\n  {\r\n    v_transparency \x3d 0.0;\r\n  }\r\n  if (u_minfadeLevel \x3e\x3d a_labelMinLevel)\r\n  {\r\n    v_transparency \x3d 1.0;\r\n  }\r\n\r\n  // if label had been faded out, clip it\r\n  delta_z +\x3d step(v_transparency, 0.0);\r\n\r\n  vec2 offset \x3d C_OFFSET_PRECISION * a_vertexOffset;\r\n\r\n  v_size \x3d abs(offset);\r\n\r\n#ifdef SDF\r\n  offset \x3d (120.0 / 86.0) * offset;\r\n#endif // SDF\r\n\r\n#ifdef DD\r\n  mediump float icon_size \x3d a_size * u_size;\r\n#else\r\n  mediump float icon_size \x3d u_size;\r\n#endif // DD\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * icon_size * vec4(offset, delta_z, 0.0);\r\n\r\n#ifdef DD\r\n  v_color \x3d a_color * u_color;\r\n#else\r\n  v_color \x3d u_color;\r\n#endif // DD\r\n\r\n#ifdef ID\r\n  v_id \x3d u_id / 255.0;\r\n#endif // ID\r\n\r\n  v_tex \x3d a_tex.xy / u_mosaicSize;\r\n  v_transparency *\x3d v_color.w;\r\n}\r\n"},
line:{"line.frag":"varying mediump vec2 v_normal;\r\nvarying highp float v_accumulatedDistance;\r\n\r\nvarying mediump float v_lineHalfWidth;\r\nvarying lowp vec4 v_color;\r\n\r\nvarying mediump float v_blur;\r\n\r\n#ifdef PATTERN\r\nuniform mediump vec2 u_pattern_tl;\r\nuniform mediump vec2 u_pattern_br;\r\nuniform mediump vec2 u_spriteSize;\r\nuniform sampler2D u_texture;\r\n\r\n// Horizontal scale is used to scale the horizontal texture coordinate v_normal.x before adding it as an offset to the\r\n// accumulated distance. Most vertices will have v_normal.x \x3d\x3d 0, because the pattern must be sampled only depending on\r\n// the v_accumulatedDistance value. But tessellation at caps can have vertices with v_normal.x !\x3d 0, thus allowing to\r\n// \"keep moving\" for a few more pixel even when the line has ended or has not started yet.\r\nconst mediump float tileCoordRatio \x3d 8.0;\r\n#else\r\nvarying mediump vec2 v_dasharray;\r\n#endif\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvoid main()\r\n{\r\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\r\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\r\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\r\n  mediump float fragDist \x3d length(v_normal) * v_lineHalfWidth;\r\n\r\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\r\n  // We need to count for both sides of the line.\r\n  lowp float alpha \x3d clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\r\n\r\n#ifdef PATTERN\r\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance aliong the line\r\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\r\n  mediump float relativeTexX \x3d mod((v_accumulatedDistance + v_normal.x * v_lineHalfWidth * tileCoordRatio) / u_spriteSize.x, 1.0);\r\n\r\n  // in order to calculate the texture coordinates perpendicular to the line (Y axis), we use the interpolated normal values\r\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\r\n  // texture value should be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\r\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolated normal is 1.0\r\n  //              | -\x3e line-width / 2\r\n  //      - - - - - - - - - - - - - -\r\n  //              | -\x3e line-width / 2\r\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolated normal is -1.0\r\n\r\n  mediump float relativeTexY \x3d 0.5 + (v_normal.y * v_lineHalfWidth / u_spriteSize.y);\r\n\r\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\r\n  mediump vec2 texCoord \x3d mix(u_pattern_tl, u_pattern_br, vec2(relativeTexX, relativeTexY));\r\n\r\n  // get the color from the texture\r\n  lowp vec4 color \x3d texture2D(u_texture, texCoord);\r\n\r\n  // finally write the fragment value\r\n  gl_FragColor \x3d alpha * v_color[3] * color;\r\n#else\r\n  // now calculate the dashes given the accumulated distance of the line:\r\n  // start with calculating a normalized position along the line\r\n  lowp float dashPos \x3d  mod(v_accumulatedDistance, v_dasharray.x + v_dasharray.y);\r\n\r\n  // calculate the contribution to the alpha of the dash part. It is provided by the shortest portion of the position along the dash.\r\n  // we must clamp since the value might be bigger than 1 or smaller than zero (when over a dash).\r\n  //   | \x3c--- pos along the dash part\r\n  // -------_______-------_______\r\n  // when the dashPos is over the 'gap' part of the dash dasharray.x - dashPos is negative and therefore the alpha will\r\n  // get clamped to zero.\r\n  // when dasharray.x - dashPos is positive, or when dashPos is smaller than 1.0, it gives us a soft edge to each dash part.\r\n  // along the direction of the line.\r\n  lowp float dashAlpha \x3d clamp(min(dashPos, v_dasharray.x - dashPos) + 0.5, 0.0, 1.0);\r\n\r\n  // if we don't have a no-data part to the dash then it is a solid line\r\n  dashAlpha \x3d max(sign(-v_dasharray.y), dashAlpha);\r\n  // finally multiply the fragment's alpha by the calculated dash-alpha\r\n  alpha *\x3d dashAlpha;\r\n\r\n  // output the fragment color\r\n  gl_FragColor \x3d alpha * v_color;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"line.vert":"/* The implementation of the renderer is based on the article and implementation of MB described here:\r\n* https://www.mapbox.com/blog/drawing-antialiased-lines/\r\n*/\r\n\r\nattribute vec2 a_pos;\r\nattribute vec4 a_offsetAndNormal;\r\nattribute vec2 a_accumulatedDistance;\r\n\r\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\r\n// relative to the tile's upper left corner\r\n// the extrusion vector.\r\nuniform highp mat4 u_transformMatrix;\r\n\r\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\r\nuniform highp mat4 u_extrudeMatrix;\r\n\r\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\r\nuniform highp vec2 u_normalized_origin;\r\n\r\nuniform mediump float u_blur;\r\nuniform mediump float u_antialiasing; // the feather distance at which the line edge fades out\r\n\r\n// the z of the layer. Given by the order of the layers in the style\r\nuniform mediump float u_depth;\r\n\r\n// the interpolated normal to the line. the information is packed into the two LSBs of the vertex coordinate\r\nvarying mediump vec2 v_normal;\r\n\r\n// the accumulated distance along the line. We need this information in order to render the dashes.\r\nvarying highp float v_accumulatedDistance;\r\n\r\nconst float scale \x3d 1.0 / 31.0;\r\n\r\n#ifdef DD\r\nattribute vec4 a_color;\r\nattribute mediump float a_width;\r\n#endif // DD\r\nuniform lowp vec4 u_color;\r\nuniform mediump float u_width;\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvarying lowp vec4 v_color;\r\nvarying mediump float v_lineHalfWidth; // the inset and outset of the line\r\nvarying mediump float v_blur;\r\n\r\n#ifndef PATTERN\r\nuniform mediump vec2 u_dasharray;\r\nvarying mediump vec2 v_dasharray;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n  v_normal \x3d a_offsetAndNormal.zw * scale;\r\n\r\n#ifdef DD\r\n  v_lineHalfWidth \x3d a_width * u_width;\r\n#else\r\n  v_lineHalfWidth \x3d u_width;\r\n#endif // DD\r\n\r\n  v_lineHalfWidth +\x3d u_antialiasing;\r\n  v_lineHalfWidth *\x3d 0.5;\r\n\r\n#ifndef PATTERN\r\n#ifdef DD\r\n  v_dasharray \x3d u_dasharray * a_width;\r\n#else\r\n  v_dasharray \x3d u_dasharray * u_width;\r\n#endif // DD\r\n#endif\r\n\r\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\r\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\r\n  mediump vec2 dist \x3d v_lineHalfWidth * a_offsetAndNormal.xy * scale;\r\n\r\n  // transform the vertex\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * vec4(dist, 0.0, 0.0);\r\n\r\n  // the accumulated distance will be used to calculate the dashes (or the no-data...)\r\n  v_accumulatedDistance \x3d a_accumulatedDistance.x;\r\n\r\n  v_blur \x3d u_blur + u_antialiasing;\r\n\r\n  #ifdef DD\r\n    v_color \x3d a_color * u_color;\r\n  #else\r\n    v_color \x3d u_color;\r\n  #endif // DD\r\n\r\n  #ifdef ID\r\n    v_id \x3d u_id / 255.0;\r\n  #endif // ID\r\n}\r\n"},
outline:{"outline.frag":"varying lowp vec4 v_color;\r\nvarying mediump vec2 v_normal;\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nvoid main()\r\n{\r\n  // Calculate the distance of the pixel from the line in pixels.\r\n  lowp float dist \x3d abs(v_normal.y);\r\n\r\n  lowp float alpha \x3d smoothstep(1.0, 0.0, dist);\r\n  gl_FragColor \x3d alpha * v_color;\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"outline.vert":"attribute vec2 a_pos;\r\nattribute vec2 a_offset;\r\nattribute vec2 a_xnormal;\r\n\r\n#ifdef DD\r\nattribute vec4 a_color;\r\n#endif // DD\r\nuniform lowp vec4 u_color;\r\nvarying lowp vec4 v_color;\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform highp mat4 u_extrudeMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\nuniform mediump float u_outline_width;\r\n\r\nvarying lowp vec2 v_normal;\r\n\r\nconst float scale \x3d 1.0 / 15.0;\r\n\r\nvoid main()\r\n{\r\n#ifdef DD\r\n  v_color \x3d a_color * u_color;\r\n#else\r\n  v_color \x3d u_color;\r\n#endif // DD\r\n\r\n#ifdef ID\r\n  v_id \x3d u_id / 255.0;\r\n#endif // ID\r\n\r\n  v_normal \x3d a_xnormal;\r\n\r\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\r\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\r\n  mediump vec4 dist \x3d vec4(u_outline_width * a_offset * scale, 0.0, 0.0);\r\n\r\n  // Remove the texture normal bit of the position before scaling it with the\r\n  // model/view matrix. Add the extrusion vector *after* the model/view matrix\r\n  // because we're extruding the line in pixel space, regardless of the current\r\n  // tile's zoom level.\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * dist;\r\n}\r\n"},
text:{"text.frag":"uniform lowp sampler2D u_texture;\r\nuniform mediump float u_edgeDistance;\r\n\r\nvarying lowp vec2 v_tex;\r\nvarying lowp float v_transparency;\r\nvarying lowp vec4 v_color;\r\nvarying mediump float v_edgeWidth;\r\nvarying mediump float v_edgeDistance;\r\n\r\n#ifdef ID\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\n// this is taken from http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\r\n// and https://www.mapbox.com/blog/text-signed-distance-fields/\r\n// http://metalbyexample.com/rendering-text-in-metal-with-signed-distance-fields/\r\n\r\nvoid main()\r\n{\r\n  // read the distance from the SDF texture\r\n  lowp float dist \x3d texture2D(u_texture, v_tex).a;\r\n\r\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\r\n  mediump float alpha \x3d smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist) * v_transparency;\r\n\r\n  gl_FragColor \x3d alpha * v_color;\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"text.vert":"attribute vec2 a_pos;\r\nattribute vec2 a_vertexOffset;\r\nattribute vec4 a_tex;\r\nattribute vec4 a_levelInfo;\r\n\r\nuniform lowp vec4 u_color; // always defined as halo does not support data driven but text does\r\n#ifdef DD\r\nattribute vec4 a_color;\r\n#endif // DD\r\nvarying lowp vec4 v_color;\r\n\r\nuniform mediump float u_size;\r\n#ifdef DD\r\nattribute mediump float a_size;\r\n#endif // DD\r\nvarying mediump float v_size;\r\n\r\n#ifdef ID\r\nuniform mediump vec4 u_id;\r\nvarying mediump vec4 v_id;\r\n#endif // ID\r\n\r\n\r\n// attribute bool a_visible; // --\x3e a one bit controlling the visibility of the vertex\r\n\r\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\r\n// relative to the tile's upper left corner\r\n// the extrusion vector.\r\nuniform highp mat4 u_transformMatrix;\r\n\r\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\r\nuniform highp mat4 u_extrudeMatrix;\r\n\r\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\r\nuniform highp vec2 u_normalized_origin;\r\n\r\n// the size of the mosaic given in pixels\r\nuniform vec2 u_mosaicSize;\r\n\r\n// the z of the layer. Given by the order of the layers in the style\r\nuniform mediump float u_depth;\r\n\r\n// the map's rotation from the north\r\nuniform mediump float u_mapRotation;\r\nuniform mediump float u_level;\r\n\r\n// indicate whether the current set of iconst should be kept upright when the map is rotated\r\nuniform lowp float u_keepUpright;\r\n\r\n// the rate of the change in the opacity (fade) of the icons\r\nuniform mediump float u_fadeSpeed;\r\n\r\n// the low level we transition (to/from)\r\nuniform mediump float u_minfadeLevel;\r\n\r\n// the high level we transition (to/from)\r\nuniform mediump float u_maxfadeLevel;\r\n\r\n// the amount of fade given teh current time past the last recorded level\r\nuniform mediump float u_fadeChange;\r\n\r\n// the opacity of the layer given by the painter\r\nuniform mediump float u_opacity;\r\n\r\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\r\nvarying lowp vec2 v_tex;\r\n\r\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\r\n// opacity of the layer given by the painter\r\nvarying lowp float v_transparency;\r\n\r\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precision we multiply the values\r\n// by 8 and then at the shader divide by the same number\r\nconst float offsetPrecision \x3d 1.0 / 8.0;\r\n\r\n// outline position and appearance\r\nconst mediump float edgePos \x3d 0.75; // defined by the SDF encoding\r\nuniform mediump float u_edgeDistance;\r\nuniform mediump float u_edgeBlur;\r\nuniform mediump float u_antialiasingWidth; // antialiasing (factors in the pixel_ratio for high res devices)\r\n\r\nvarying mediump float v_edgeDistance; // will factor in the size\r\nvarying mediump float v_edgeWidth; // will factor in the size\r\n\r\nuniform lowp float u_halo; // needed to avoid using the color attribute for halo\r\n\r\nvoid main()\r\n{\r\n  mediump float a_labelMinLevel \x3d a_levelInfo[0];\r\n  mediump float a_angle        \x3d a_levelInfo[1];\r\n  mediump float a_minLevel    \x3d a_levelInfo[2];\r\n  mediump float a_maxLevel    \x3d a_levelInfo[3];\r\n\r\n  // if the given vertex should not be visible simply clip it by adding it a value that will push it outside the clipping plane\r\n  mediump float delta_z \x3d 0.0;\r\n\r\n  // TODO: force clipping the vertex in case that the vertex isn't visible\r\n  //delta_z +\x3d a_visible ? 0.0 : 1.0;\r\n\r\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\r\n  mediump float rotated \x3d mod(a_angle + u_mapRotation, 256.0);\r\n  delta_z +\x3d (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated)); //ie. z +\x3d (flip \x3e 0) \x26\x26 (64 \x3c\x3d rotated) \x26\x26 (rotated \x3c 192)\r\n\r\n  // u_level is the current service level adjusted for the change in font size\r\n  delta_z +\x3d 1.0 - step(a_minLevel, u_level); // Test if (level \x3c minLevel)\r\n  delta_z +\x3d step(a_maxLevel, u_level); // Test if (maxLevel \x3c\x3d level)\r\n\r\n  // calculate the alpha given the change in the fade and the fade-speed\r\n  lowp float alpha \x3d clamp((u_fadeChange - a_labelMinLevel) / u_fadeSpeed, 0.0, 1.0);\r\n\r\n  // if the speed is positive we are zooming in and therefore we need to 'fade-in'. Else we need to 'fade-out'\r\n  v_transparency \x3d (u_fadeSpeed \x3e\x3d 0.0 ? alpha : 1.0 - alpha);\r\n\r\n  // now deal with the min/max fade-levels. If we exceeded the level we simply snap to 0 or 1\r\n  if (u_maxfadeLevel \x3c a_labelMinLevel)\r\n  {\r\n    v_transparency \x3d 0.0;\r\n  }\r\n  if (u_minfadeLevel \x3e\x3d a_labelMinLevel)\r\n  {\r\n    v_transparency \x3d 1.0;\r\n  }\r\n\r\n  // if label has been faded out, clip it\r\n  delta_z +\x3d step(v_transparency, 0.0);\r\n\r\n  v_tex \x3d a_tex.xy / u_mosaicSize;\r\n\r\n#ifdef DD\r\n  if (u_halo \x3e 0.5)\r\n  {\r\n    v_color \x3d u_color;\r\n  }\r\n  else\r\n  {\r\n    v_color \x3d a_color * u_color;\r\n    // opacity already factored in a_color\r\n  }\r\n#else\r\n  v_color \x3d u_color;\r\n#endif // DD\r\n\r\n#ifdef DD\r\n  v_size \x3d a_size * u_size;\r\n#else\r\n  v_size \x3d u_size;\r\n#endif // DD\r\n\r\n#ifdef ID\r\n  v_id \x3d u_id / 255.0;\r\n#endif // ID\r\n\r\n  v_edgeDistance \x3d edgePos - u_edgeDistance / v_size;\r\n  v_edgeWidth \x3d (u_antialiasingWidth + u_edgeBlur) / v_size;\r\n\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * v_size * vec4(offsetPrecision * a_vertexOffset, delta_z, 0.0);\r\n}\r\n"},
tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\r\nvarying mediump vec2 v_tex;\r\n\r\nvoid main(void) {\r\n  lowp vec4 color \x3d texture2D(u_texture, v_tex);\r\n  gl_FragColor \x3d 0.75 * color;\r\n}\r\n","tileInfo.vert":"attribute vec2 a_pos;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform mediump vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\nuniform mediump float u_coord_ratio;\r\nuniform mediump vec2 u_delta; // in tile coordinates\r\nuniform mediump vec2 u_dimensions; // in tile coordinates\r\n\r\nvarying mediump vec2 v_tex;\r\n\r\nvoid main() {\r\n  mediump vec2 offests \x3d u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(offests, 0.0, 1.0);\r\n\r\n  v_tex \x3d a_pos;\r\n}\r\n"},
util:{"encoding.glsl":"// Factors to convert rgba back to float\r\nconst vec4 rgba2float_factors \x3d vec4(\r\n    255.0 / (256.0),\r\n    255.0 / (256.0 * 256.0),\r\n    255.0 / (256.0 * 256.0 * 256.0),\r\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\r\n  );\r\n\r\nfloat rgba2float(vec4 rgba) {\r\n  // Convert components from 0-\x3e1 back to 0-\x3e255 and then\r\n  // add the components together with their corresponding\r\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\r\n  return dot(rgba, rgba2float_factors);\r\n}\r\n"}}})},
"*noref":1}});
define("require exports ../../../core/tsSupport/declareExtendsHelper ../../../core/tsSupport/decorateHelper ../../../Graphic ../../../core/Handles ../../../core/promiseUtils ../../../core/accessorSupport/decorators ./LayerView2D ../tiling/TileInfoViewPOT ../tiling/TileKey ../tiling/TileQueue ../tiling/TileStrategy ../../vectorTiles/TileHandler ../../vectorTiles/VectorTileContainer ../../vectorTiles/VectorTileDisplayObject".split(" "),function(u,r,d,q,p,h,b,f,c,a,e,w,m,k,n,v){return function(c){function g(){var a=null!==
c&&c.apply(this,arguments)||this;a._fetchQueue=null;a._tileRequests=new Map;a._handles=new h;a._invalidateStyle=!1;a.container=new n;return a}d(g,c);g.prototype.initialize=function(){var b=this;this._tileInfoView=new a(this.layer.tileInfo,this.layer.fullExtent);this._tileHandler=new k(this.layer,window.devicePixelRatio||1,!0,this.container);this.handles.add(this.watch("layer.currentStyleInfo",function(a){b._start()}))};g.prototype.destroy=function(){this._stop();this.container.dispose();this._tileHandler.destroy();
this._tileHandler=null};g.prototype.hitTest=function(a,c){var d=this;return this.suspended?b.resolve(null):this.container.hitTest(a,c).then(function(a){var b=d._tileHandler.getStyleRepository().layers;if(null===a||0>a||a>=b.length)return null;a=new p({attributes:{layerId:a,layerName:b[a].id}});a.layer=d.layer;a.sourceLayer=d.layer;return a})};g.prototype.update=function(a){this.notifyChange("updating");var b=this._tileHandlerPromise;if(b&&b.isFulfilled())if(a.pixelRatio!==this._tileHandler.devicePixelRatio)this._start(),
this._tileHandler.devicePixelRatio=a.pixelRatio;else{this._invalidateStyle&&(this._issueStyleInvalidation(a),this._invalidateStyle=!1);this._fetchQueue.pause();this._fetchQueue.state=a.state;this._tileStrategy.update(a);this._fetchQueue.resume();for(var b=0,c=this.container.children;b<c.length;b++)this._tileHandler.updateTile(c[b],a)}};g.prototype.attach=function(){var a=this;this._start();this._handles.add(this.layer.on("paint-change",function(b){return a.container.requestRender()}));this._handles.add(this.layer.on("layout-change",
function(b){a._invalidateStyle=!0;a.requestUpdate()}))};g.prototype.detach=function(){this._stop();this._handles.removeAll()};g.prototype.moveStart=function(){this.requestUpdate()};g.prototype.viewChange=function(){this.requestUpdate()};g.prototype.moveEnd=function(){this.requestUpdate()};g.prototype.canResume=function(){var a=this.inherited(arguments),b=this.layer;if(a&&b.currentStyleInfo){var c=this.view.scale;(b=b.currentStyleInfo)&&b.layerDefinition&&(b=b.layerDefinition,b.minScale&&b.minScale<
c&&(a=!1),b.maxScale&&b.maxScale>c&&(a=!1))}return a};g.prototype.isUpdating=function(){var a=!0;this._tileRequests.forEach(function(b){a=a&&b.isFulfilled()});return!this._tileHandlerPromise||!this._tileHandlerPromise.isFulfilled()||!a};g.prototype.acquireTile=function(a){var b=this,c=e.pool.acquire();c.set(a.level,a.row,a.col,a.world);a=this.updateParameters.state.rotation;var d=this._tileHandler.getStyleRepository(),f=v.pool.acquire(c,c,this.layer.tileInfo,d,a);this._tileHandlerPromise.then(function(){var a=
b._tileHandler.getRefKey(c).then(function(a){if(a)return f.refKey=a,b._fetchQueue.push(f.key).then(function(a){f.setData(a.tileData,a.client);f.once("attach",function(){return b.requestUpdate()});b.container.addChild(f);b.notifyChange("updating")});f.setData(null,null);f.once("attach",function(){return b.requestUpdate()});b.container.addChild(f)});b._tileRequests.set(c.id,a);b.notifyChange("updating")});return f};g.prototype.releaseTile=function(a){var b=a.key.id,c=this._tileRequests.get(b);c&&(c.isFulfilled()||
c.cancel(),this._tileRequests.delete(b));this.container.removeChild(a);this.requestUpdate();a.once("detach",function(){return v.pool.release(a)});this.notifyChange("updating")};g.prototype._start=function(){var a=this;this._stop();if(this.layer.currentStyleInfo&&this.attached){var b=this._tileHandler.start().then(function(){a._tileHandlerPromise===b&&(a._tileStrategy=new m({cachePolicy:"keep",coveragePolicy:"smallest",acquireTile:function(b){return a.acquireTile(b)},releaseTile:function(b){return a.releaseTile(b)},
tileInfoView:a._tileInfoView}),a._fetchQueue=new w({tileInfoView:a._tileInfoView,process:function(b){return a._getTileData(b)}}),a.container.initialize(a._tileHandler.spriteMosaic,a._tileHandler.glyphMosaic,a.layer.tileInfo,a._tileInfoView),a.requestUpdate())});this._tileHandlerPromise=b}};g.prototype._stop=function(){this._tileHandlerPromise&&(this._tileHandlerPromise.isFulfilled()?this._tileHandlerPromise.isResolved()&&(this._tileHandlerPromise=null,this._fetchQueue.destroy(),this._fetchQueue=null,
this._tileStrategy.destroy(),this._tileStrategy=null,this.container.removeAllChildren(),this._tileHandler.stop(),v.pool.prune()):(this._tileHandlerPromise.cancel(),this._tileHandlerPromise=null))};g.prototype._getTileData=function(a){return this._tileHandler.getTileData(a,this.updateParameters.state.rotation)};g.prototype._issueStyleInvalidation=function(a){var b=this;this._tileHandler.updateStyle().then(function(){b._fetchQueue.pause();b._fetchQueue.clear();b._tileRequests.forEach(function(a,b){a.cancel()});
b._tileRequests.clear();b._fetchQueue.resume();b.requestUpdate()})};q([f.property({dependsOn:["view.scale","layer.currentStyleInfo"]})],g.prototype,"suspended",void 0);return g=q([f.subclass("esri.views.2d.layers.VectorTileLayerView2D")],g)}(f.declared(c))});