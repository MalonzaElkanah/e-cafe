// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.10/esri/copyright.txt for details.
//>>built
define(["require","exports"],function(a,b){return{background:{"background.frag":"uniform lowp vec4 u_color;\r\nvoid main() {\r\n  gl_FragColor \x3d u_color;\r\n}\r\n","background.vert":"attribute vec2 a_pos;\r\n\r\nuniform highp mat3 u_dvsMat3;\r\nuniform mediump float u_coord_range;\r\nuniform mediump float u_depth;\r\n\r\nvoid main() {\r\n  vec3 v_pos \x3d u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0);\r\n  gl_Position \x3d vec4(v_pos.xy, 0.0, 1.0);\r\n}\r\n"},bitBlit:{"bitBlit.frag":"uniform lowp sampler2D u_tex;\r\nuniform lowp float u_opacity;\r\n\r\nvarying mediump vec2 v_uv;\r\n\r\nvoid main() {\r\n  lowp vec4 color \x3d texture2D(u_tex, v_uv);\r\n\r\n  // Note: output in pre-multiplied alpha for correct alpha compositing\r\n  gl_FragColor \x3d color *  u_opacity;\r\n}\r\n",
"bitBlit.vert":"attribute vec2 a_pos;\r\nattribute vec2 a_tex;\r\n\r\nvarying mediump vec2 v_uv;\r\n\r\nvoid main(void) {\r\n  gl_Position \x3d vec4(a_pos, 0.0, 1.0);\r\n  v_uv \x3d a_tex;\r\n}\r\n"},highlight:{"blur.frag":"// A gaussian blur shader. It blurs the alpha channel of its input\r\n// according to 4 different sigma and stores the results into the\r\n// four channel of the target framebuffer.\r\n\r\n// It is intended to be called twice; the first time to perform an\r\n// horizontal blur, and a second time to perform a vertical blur.\r\n\r\n// This shader is used to turn the highlight mask into a highlight\r\n// map. The highlight map is an approximation of the signed distance\r\n// field of the mask.\r\n\r\n\r\n// Interpolated texture coordinates.\r\nvarying mediump vec2 v_texcoord;\r\n\r\n// Blur direction information. There are two possible\r\n// configurations that the host code can use.\r\n//  - [1, 0, 1/WIDTH, 0] Used when blurring horizontally. In this\r\n//    case u_direction[0] \x3d 1 is expressed in pixel and is fed to\r\n//    the gauss function to produce the value of the gaussian weight\r\n//    for that pixel, while u_direction[2] \x3d 1/WIDTH is in texel units\r\n//    and is used to sample the right texel from the texture map.\r\n//  - [0, 1, 0, 1/HEIGHT] Used when blurring vertically. In this\r\n//    case u_direction[1] \x3d 1 is expressed in pixel and is fed to\r\n//    the gauss function to produce the value of the gaussian weight\r\n//    for that pixel, while u_direction[3] \x3d 1/HEIGHT is in texel units\r\n//    and is used to sample the right texel from the texture map.\r\nuniform mediump vec4 u_direction;\r\n\r\n// Source to destination channel selection matrix.\r\nuniform mediump mat4 u_channelSelector;\r\n\r\n// The highlight map is obtained by blurring the alpha channel of the highlight\r\n// mask accroding to these 4 values of the gaussian's sigma parameter.\r\nuniform mediump vec4 u_sigmas;\r\n\r\n// This is the highlight mask if we have not blurred horizontally yet, otherwise\r\n// it is the horizontally blurred highlight map and blurring it one more time\r\n// vertically will complete the process.\r\nuniform sampler2D u_texture;\r\n\r\n// The gaussian kernel. Note that it lacks the normalization constant, because\r\n// we want to store it unnormalized in the highlight map (i.e. having a peak\r\n// value of 1). Note also that we are using the SIMD (single instruction, multiple\r\n// data) capabilities of the GPU to compute four different gaussian kernels, one\r\n// for each sigma.\r\nmediump vec4 gauss(mediump vec2 dir) {\r\n  return exp(-dot(dir, dir) / (2.0 * u_sigmas * u_sigmas));\r\n}\r\n\r\nmediump vec4 selectChannel(mediump vec4 sample) {\r\n  return u_channelSelector * sample;\r\n}\r\n\r\n// Sample the input texture and accumulated its gaussian weighted value and the\r\n// total weight.\r\nvoid accumGauss(mediump float i, inout mediump vec4 tot, inout mediump vec4 weight) {\r\n  // Computes the gaussian weights, one for each sigma.\r\n  // Note that u_direction.xy is [1, 0] when blurring horizontally and [0, 1] when blurring vertically.\r\n  mediump vec4 w \x3d gauss(i * u_direction.xy);\r\n\r\n  // Accumumates the values.\r\n  // Note that u_direction.xy is [1/WIDTH, 0] when blurring horizontally and [0, 1/HEIGHT] when blurring vertically.\r\n  tot +\x3d selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw)) * w;\r\n\r\n  // Accumulates the weights.\r\n  weight +\x3d w;\r\n}\r\n\r\nvoid main(void) {\r\n  // Initialize accumulated values and weights to zero.\r\n  mediump vec4 tot \x3d vec4(0.0, 0.0, 0.0, 0.0);\r\n  mediump vec4 weight \x3d vec4(0.0, 0.0, 0.0, 0.0);\r\n\r\n  // Accumulates enough samples. These will be taken\r\n  // horizontally or vertically depending on the value\r\n  // of u_direction.\r\n  accumGauss(-5.0, tot, weight);\r\n  accumGauss(-4.0, tot, weight);\r\n  accumGauss(-3.0, tot, weight);\r\n  accumGauss(-2.0, tot, weight);\r\n  accumGauss(-1.0, tot, weight);\r\n  accumGauss(0.0, tot, weight);\r\n  accumGauss(1.0, tot, weight);\r\n  accumGauss(2.0, tot, weight);\r\n  accumGauss(3.0, tot, weight);\r\n  accumGauss(4.0, tot, weight);\r\n  accumGauss(5.0, tot, weight);\r\n\r\n  // Compute blurred values.\r\n  mediump vec4 rgba \x3d tot / weight;\r\n\r\n  // Return the values. Note that each channel will contain\r\n  // the result of a different blur operation, one for each\r\n  // of the four chosen sigma.\r\n  gl_FragColor \x3d vec4(rgba);\r\n}\r\n",
"highlight.frag":"// Takes as input the highlight map, estimated the signed distance field,\r\n// and shades the fragments according to their estimated distance from the\r\n// edge of the highlighted feature.\r\n\r\n// A shade texture is used to turn distance values into colors; the shade\r\n// texture is basically a color gradient and is recomputed on the host\r\n// every time that the user alters the highlight options.\r\n\r\n// Interpolated texture coordinates.\r\nvarying mediump vec2 v_texcoord;\r\n\r\n// The highlight map. Each channel is a blurred\r\n// version of the alpha channel of the highlight mask.\r\n//  - Channel 0 (red) corresponds to a gaussian blur with sigma \x3d u_sigmas[0];\r\n//  - Channel 1 (green) corresponds to a gaussian blur with sigma \x3d u_sigmas[1];\r\n//  - Channel 2 (blue) corresponds to a gaussian blur with sigma \x3d u_sigmas[2];\r\n//  - Channel 3 (alpha) corresponds to a gaussian blur with sigma \x3d u_sigmas[3];\r\n// As of today, only channel 3 is used for distance estimation.\r\n// But the availability of different amounts of blur leaves the\r\n// door open to multi-scale approaches.\r\nuniform sampler2D u_texture;\r\n\r\n// The highlight map was obtained by blurring the alpha channel of the highlight\r\n// mask accroding to these 4 values of the gaussian's sigma parameter.\r\nuniform mediump vec4 u_sigmas;\r\n\r\n// A 1-D texture used to shade the highlight.\r\nuniform sampler2D u_shade;\r\n\r\n// The 1-D shade texture is spreaded between u_minMaxDistance[0] and u_minMaxDistance[1].\r\nuniform mediump vec2 u_minMaxDistance;\r\n\r\n// Signed distance estimation.\r\nmediump float estimateDistance() {\r\n  // Use the largest sigma and the corresponding distance value stored in the\r\n  // last channel of the highlight map.\r\n  mediump float sigma \x3d u_sigmas[3];\r\n  mediump float y \x3d texture2D(u_texture, v_texcoord)[3];\r\n\r\n  // Estimates the distance by linearization and local inversion around\r\n  // the inflection point. The inflection point is in x \x3d 0.\r\n  const mediump float y0 \x3d 0.5;                           // Value of the convolution at the inflection point.\r\n  mediump float m0 \x3d 1.0 / (sqrt(2.0 * 3.1415) * sigma);  // Slope of the convolution at the inflection point.\r\n  mediump float d \x3d (y - y0) / m0;                        // Inversion of a local linearization.\r\n\r\n  // Return the estimated distance.\r\n  return d;\r\n}\r\n\r\n// Shading based on estimated distance.\r\nmediump vec4 shade(mediump float d) {\r\n  // Maps the sampled distance from the [A, D] range (see HighlightRenderer::setHighlightOptions) to [0, 1].\r\n  mediump float mappedDistance \x3d (d - u_minMaxDistance.x) / (u_minMaxDistance.y - u_minMaxDistance.x);\r\n\r\n  // Force to [0, 1]; it should not be necessary because the shade texture uses the CLAMP address mode, so\r\n  // this should happen anyway internally to the sampler, but in practice it is needed to avoid weird\r\n  // banding artifacts.\r\n  // We don't really know if we need this or not.\r\n  mappedDistance \x3d clamp(mappedDistance, 0.0, 1.0);\r\n\r\n  // Sample the 1-D shade texture on its center line (i.e. on t\x3d0.5).\r\n  return texture2D(u_shade, vec2(mappedDistance, 0.5));\r\n}\r\n\r\nvoid main(void) {\r\n  // Estimate the distance.\r\n  mediump float d \x3d estimateDistance();\r\n\r\n  // Shade the distance.\r\n  gl_FragColor \x3d shade(d);\r\n}\r\n",
"textured.vert":"// Identity vertex shader that outputs an untransformed 2-D vertex\r\n// and passes its texture coordinates unchanged to the interpolator.\r\n\r\n// Vertex position.\r\nattribute mediump vec2 a_position;\r\n\r\n// Texture coordinates.\r\nattribute mediump vec2 a_texcoord;\r\n\r\n// Texture coordinates to be interpolated.\r\nvarying mediump vec2 v_texcoord;\r\n\r\nvoid main(void) {\r\n  // Pass the position unchanged.\r\n  gl_Position \x3d vec4(a_position, 0.0, 1.0);\r\n\r\n  // Pass the texture coordinates unchanged.\r\n  v_texcoord \x3d a_texcoord;\r\n}\r\n"},
materials:{fill:{"fill.frag":"precision lowp float;\r\n\r\n#ifdef PATTERN\r\nuniform lowp sampler2D u_texture;\r\n\r\nvarying mediump vec4 v_tlbr;\r\nvarying mediump vec2 v_tileTextureCoord;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif // ID\r\n\r\nvarying lowp vec4 v_color;\r\nvarying lowp float v_opacity;\r\n\r\nvoid main()\r\n{\r\n#ifdef PATTERN\r\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\r\n  mediump vec2 normalizedTextureCoord \x3d mod(v_tileTextureCoord, 1.0);\r\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\r\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\r\n  // we need to only sample from area that has our sprite in the mosaic.\r\n  mediump vec2 samplePos \x3d mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\r\n  // sample the sprite mosaic\r\n  lowp vec4 color \x3d texture2D(u_texture, samplePos);\r\n  gl_FragColor \x3d v_opacity * v_color * color;\r\n#else\r\n  gl_FragColor \x3d v_opacity * v_color;\r\n#endif // PATTERN\r\n\r\n#ifdef HIGHLIGHT\r\n  gl_FragColor.a \x3d step(1.0 / 255.0, gl_FragColor.a);\r\n#endif // HIGHLIGHT\r\n\r\n#ifdef ID\r\n  //if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n  //  discard;\r\n  //}\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"fill.vert":"precision mediump float;\r\n\r\nattribute vec2 a_pos;\r\nattribute vec4 a_id; // since we need to render the Id as a color we need to break it into RGBA components. so just like a color, the Id is normalized.\r\nattribute vec4 a_color;\r\nattribute vec4 a_tlbr;\r\nattribute vec4 a_aux1;\r\nattribute vec2 a_aux2;\r\n\r\nattribute float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\r\n\r\n// T: TileCoords -\x3e DisplayCoords\r\n// Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\r\nuniform highp mat3 u_dvsMat3;\r\n\r\nvarying lowp vec4 v_color;\r\nvarying lowp float v_opacity;\r\n\r\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\r\n#include \x3cmaterials/fill/vvUniforms.glsl\x3e\r\n#include \x3cmaterials/fill/vvFunctions.glsl\x3e\r\n\r\n#ifdef PATTERN\r\nuniform mediump float u_zoomFactor;\r\nuniform mediump vec2 u_mosaicSize;\r\n\r\nvarying mediump vec4 v_tlbr;\r\nvarying mediump vec2 v_tileTextureCoord;\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif // ID\r\n\r\nconst float SIGNED_BYTE_TO_UNSIGNED \x3d 128.0;\r\n\r\nvoid main()\r\n{\r\n#ifdef VV_OPACITY\r\n  v_opacity \x3d getVVOpacity(a_vv.y);\r\n#else\r\n  v_opacity \x3d 1.0;\r\n#endif\r\n\r\n#ifdef VV_COLOR\r\n  v_color \x3d getVVColor(a_vv.x, a_color);\r\n#else\r\n  v_color \x3d a_color;\r\n#endif // VV_COLOR\r\n\r\n#ifdef ID\r\n  v_id \x3d a_id;\r\n#endif // ID\r\n\r\n#ifdef PATTERN\r\n  vec2 aux2 \x3d (1.0 / SIGNED_BYTE_TO_UNSIGNED) * a_aux2;\r\n\r\n  // calculate the pattern matrix\r\n  mat3 patternMatrix \x3d mat3(1.0, 0.0, 0.0,\r\n                            0.0, 1.0, 0.0,\r\n                            0.0, 0.0, 1.0);\r\n\r\n  patternMatrix[0][0] \x3d 1.0 / (u_zoomFactor * a_aux1.x * aux2.x);\r\n  patternMatrix[1][1] \x3d 1.0 / (u_zoomFactor * a_aux1.y * aux2.y);\r\n\r\n  vec2 symbolOffset \x3d u_zoomFactor * (a_aux1.zw - vec2(SIGNED_BYTE_TO_UNSIGNED));\r\n\r\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\r\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from\r\n  // tile coordinates to texture coordinates.\r\n  v_tileTextureCoord \x3d (patternMatrix * vec3(a_pos + symbolOffset, 1.0)).xy;\r\n  v_tlbr \x3d vec4(a_tlbr.x / u_mosaicSize.x, a_tlbr.y / u_mosaicSize.y, a_tlbr.z / u_mosaicSize.x, a_tlbr.w / u_mosaicSize.y);\r\n#endif // PATTERN\r\n\r\n  float z \x3d 2.0 * (1.0 - a_visible); // clip the vertex if the geometry isn't visible\r\n  vec3 v_pos \x3d u_dvsMat3 * vec3(a_pos, 1.);\r\n\r\n  gl_Position \x3d vec4(v_pos.xy, z, 1.0);\r\n}\r\n",
"vvFunctions.glsl":"const highp float nanValue \x3d 1e-30;\r\n\r\nbool isNan(float val) {\r\n  return (val \x3d\x3d nanValue);\r\n  //return !(val \x3c 0.0 || -1.0 \x3c (val - 1.0) || val \x3d\x3d 0.0);\r\n}\r\n\r\n#ifdef VV_OPACITY\r\nconst int VV_OPACITY_N \x3d 8;\r\n\r\nfloat getVVOpacity(float opacityValue) {\r\n  if (isNan(opacityValue)) {\r\n    return 1.0;\r\n  }\r\n\r\n  if (opacityValue \x3c\x3d u_vvOpacityValues[0]) {\r\n    return u_vvOpacities[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_OPACITY_N; ++i) {\r\n    if (u_vvOpacityValues[i] \x3e\x3d opacityValue) {\r\n      float f \x3d (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\r\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvOpacities[VV_OPACITY_N - 1];\r\n}\r\n#endif // VV_OPACITY\r\n\r\n#ifdef VV_COLOR\r\nconst int VV_COLOR_N \x3d 8;\r\n\r\nvec4 getVVColor(float colorValue, vec4 fallback) {\r\n  if (isNan(colorValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  if (colorValue \x3c\x3d u_vvColorValues[0]) {\r\n    return u_vvColors[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_COLOR_N; ++i) {\r\n    if (u_vvColorValues[i] \x3e\x3d colorValue) {\r\n      float f \x3d (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\r\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvColors[VV_COLOR_N - 1];\r\n}\r\n#endif // VV_COLOR\r\n",
"vvUniforms.glsl":"#if defined(VV_COLOR)|| defined(VV_OPACITY)\r\nattribute highp vec4 a_vv;\r\n#endif // VV_COLOR || VV_OPACITY\r\n\r\n#ifdef VV_COLOR\r\nuniform highp float u_vvColorValues[8];\r\nuniform vec4 u_vvColors[8];\r\n#endif // VV_COLOR\r\n\r\n#ifdef VV_OPACITY\r\nuniform highp float u_vvOpacityValues[8];\r\nuniform float u_vvOpacities[8];\r\n#endif // VV_OPACITY\r\n"},icon:{"icon.frag":"precision mediump float;\r\n\r\nuniform lowp sampler2D u_texture;\r\n\r\nvarying lowp vec2 v_tex;\r\nvarying lowp float v_transparency;\r\nvarying mediump vec2 v_size;\r\nvarying lowp vec4 v_color;\r\n\r\n#ifdef SDF\r\nvarying lowp vec4 v_outlineColor;\r\nvarying mediump float v_outlineWidth;\r\n\r\n// we need the conversion function from RGBA to float\r\n#include \x3cutil/encoding.glsl\x3e\r\n#endif // SDF\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif // ID\r\n\r\nconst float softEdgeRatio \x3d 1.0; // use blur here if needed\r\n\r\nvoid main()\r\n{\r\n#ifdef SDF\r\n  lowp vec4 fillPixelColor \x3d v_color;\r\n\r\n  // calculate the distance from the edge [-0.5, 0.5]\r\n  float d \x3d 0.5 - rgba2float(texture2D(u_texture, v_tex));\r\n\r\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\r\n  float size \x3d max(v_size.x, v_size.y);\r\n  float dist \x3d d * size * softEdgeRatio;\r\n\r\n  // set the fragment's transparency according to the distance from the edge\r\n  fillPixelColor *\x3d clamp(0.5 - dist, 0.0, 1.0);\r\n\r\n  // count for the outline\r\n  // therefore tint the entire icon area.\r\n  if (v_outlineWidth \x3e 0.25) {\r\n    lowp vec4 outlinePixelColor \x3d v_outlineColor;\r\n\r\n    // outlines can't be larger than the size of the symbol\r\n    float clampedOutlineSize \x3d min(v_outlineWidth, size);\r\n\r\n    outlinePixelColor *\x3d clamp(0.5 - abs(dist) + clampedOutlineSize * 0.5, 0.0, 1.0);\r\n\r\n    // finally combine the outline and the fill colors (outline draws on top of fill)\r\n    gl_FragColor \x3d v_transparency * ((1.0 - outlinePixelColor.a) * fillPixelColor + outlinePixelColor);\r\n  }\r\n  else {\r\n    gl_FragColor \x3d v_transparency * fillPixelColor;\r\n  }\r\n#else // not an SDF\r\n   lowp vec4 texColor \x3d texture2D(u_texture, v_tex);\r\n   gl_FragColor \x3d v_transparency * texColor;\r\n#endif // SDF\r\n\r\n#ifdef HIGHLIGHT\r\n  gl_FragColor.a \x3d step(1.0 / 255.0, gl_FragColor.a);\r\n#endif // HIGHLIGHT\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"icon.vert":"precision mediump float;\r\n\r\n//const float C_256_TO_RAD \x3d 3.14159265359 / 128.0;\r\nconst float C_DEG_TO_RAD \x3d 3.14159265359 / 180.0;\r\nconst vec2 SIGNED_BYTE_TO_UNSIGNED \x3d vec2(128.0);\r\n\r\n// per quad (instance) attributes (20 bytes \x3d\x3d\x3e equivalent of 5 bytes per vertex)\r\nattribute vec2 a_pos;\r\nattribute vec4 a_vertexOffsetAndTex;\r\nattribute vec4 a_id; // since we need to render the Id as a color we need to break it into RGBA components. so just like a color, the Id is normalized.\r\nattribute vec4 a_color;\r\nattribute vec4 a_outlineColor;\r\nattribute vec4 a_sizeAndOutlineWidth;\r\n\r\nattribute float a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\r\n\r\nuniform highp mat3 u_dvsMat3;\r\nuniform highp mat3 u_displayMat3;\r\n\r\n// the size of the mosaic given in pixels\r\nuniform vec2 u_mosaicSize;\r\n\r\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\r\nvarying mediump vec2 v_tex;\r\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\r\n// opacity of the layer given by the painter\r\nvarying lowp float v_transparency;\r\n// the of the icon given in pixels\r\nvarying mediump vec2 v_size;\r\n\r\n// icon color. If is a picture-marker it is used to tint the texture color\r\nvarying lowp vec4 v_color;\r\n\r\n#ifdef SDF\r\nvarying lowp vec4 v_outlineColor;\r\nvarying mediump float v_outlineWidth;\r\n#endif // SDF\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif // ID\r\n\r\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\r\n#include \x3cmaterials/icon/vvUniforms.glsl\x3e\r\n#include \x3cmaterials/icon/vvFunctions.glsl\x3e\r\n\r\nvoid main()\r\n{\r\n  vec2 a_offset \x3d a_vertexOffsetAndTex.xy;\r\n  vec2 a_tex \x3d a_vertexOffsetAndTex.zw + SIGNED_BYTE_TO_UNSIGNED; // offset to change from signed to unsigned byte\r\n  vec2 a_size \x3d a_sizeAndOutlineWidth.xy;\r\n\r\n  // default values (we need them for the variations to come)\r\n  float a_angle \x3d 0.0;\r\n  float delta_z \x3d 2.0 * (1.0 - a_visible);\r\n  float depth \x3d 0.0;\r\n  v_transparency \x3d 1.0;\r\n\r\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\r\n\r\n#ifdef VV_SIZE_MIN_MAX_VALUE\r\n  // vv size override the original symbol's size\r\n  float h \x3d getVVMinMaxSize(a_vv.x, a_size.y);\r\n#endif // VV_SIZE_MIN_MAX_VALUE\r\n\r\n#ifdef VV_SIZE_SCALE_STOPS\r\n  float h \x3d u_vvSizeScaleStopsValue;\r\n#endif // VV_SIZE_SCALE_STOPS\r\n\r\n#ifdef VV_SIZE_FIELD_STOPS\r\n  float h \x3d getVVStopsSize(a_vv.x, a_size.y);\r\n#endif // VV_SIZE_FIELD_STOPS\r\n\r\n#ifdef VV_SIZE_UNIT_VALUE\r\n  float h \x3d getVVUnitValue(a_vv.x, a_size.y);\r\n#endif // VV_SIZE_UNIT_VALUE\r\n\r\n  // make sure to preserve the aspect ratio of the symbol\r\n  vec2 size \x3d vec2(h * a_size.x / a_size.y, h);\r\n  vec3 offset \x3d vec3(a_offset * size / a_size, 0.0);\r\n  v_size \x3d size;\r\n#else\r\n  vec3 offset \x3d vec3(a_offset, 0.0);\r\n  v_size \x3d a_size;\r\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\r\n\r\n#ifdef SDF\r\n  offset *\x3d 2.0;\r\n#endif // SDF\r\n\r\n\r\n#ifdef VV_ROTATION\r\n  // If we have a rotation VV, we need to rotate our offset\r\n  offset \x3d u_displayMat3 * getVVRotationMat3(a_vv.w) * offset;\r\n#else\r\n  offset \x3d u_displayMat3 * offset;\r\n#endif // VV_ROTATION\r\n  vec3 pos \x3d u_dvsMat3 * vec3(a_pos, 1.0) + offset;\r\n\r\n  gl_Position \x3d vec4(pos.xy, delta_z, 1.0);\r\n\r\n#ifdef VV_OPACITY\r\n  v_transparency \x3d getVVOpacity(a_vv.z);\r\n#else\r\n  v_transparency \x3d 1.0;\r\n#endif // VV_OPACITY\r\n\r\n#ifdef VV_COLOR\r\n  v_color \x3d getVVColor(a_vv.y, a_color);\r\n#else\r\n  v_color \x3d a_color;\r\n#endif // VV_COLOR\r\n\r\n  // output the texture coordinates and the transparency\r\n  v_tex \x3d a_tex / u_mosaicSize;\r\n\r\n#ifdef SDF\r\n  v_outlineColor \x3d a_outlineColor;\r\n  // YF: in practice v_size.x and v_size.y are identical since we're mostly dealing with sms\r\n  v_outlineWidth \x3d min(a_sizeAndOutlineWidth.z, max(v_size.x - 0.99, 0.0));\r\n#endif // SDF\r\n\r\n#ifdef ID\r\n  v_id \x3d a_id;\r\n#endif // ID\r\n}\r\n",
"vvFunctions.glsl":"const highp float nanValue \x3d 1e-30;\r\n\r\nbool isNan(float val) {\r\n  return (val \x3d\x3d nanValue);\r\n  //return !( val \x3c 0.0 || 0.0 \x3c val || val \x3d\x3d 0.0 );\r\n}\r\n\r\n#ifdef VV_SIZE_MIN_MAX_VALUE\r\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\r\n  if (isNan(sizeValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  // we need to multiply by 8 in order to translate to tile coordinates\r\n  float interpolationRatio \x3d (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\r\n  interpolationRatio \x3d clamp(interpolationRatio, 0.0, 1.0);\r\n  return u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z);\r\n}\r\n#endif // VV_SIZE_MIN_MAX_VALUE\r\n\r\n#ifdef VV_SIZE_FIELD_STOPS\r\nconst int VV_SIZE_N \x3d 6;\r\nfloat getVVStopsSize(float sizeValue, float fallback) {\r\n  if (isNan(sizeValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  if (sizeValue \x3c\x3d u_vvSizeFieldStopsValues[0]) {\r\n    return u_vvSizeFieldStopsSizes[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_SIZE_N; ++i) {\r\n    if (u_vvSizeFieldStopsValues[i] \x3e\x3d sizeValue) {\r\n      float f \x3d (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\r\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\r\n}\r\n#endif // VV_SIZE_FIELD_STOPS\r\n\r\n#ifdef VV_SIZE_UNIT_VALUE\r\nfloat getVVUnitValue(float sizeValue, float fallback) {\r\n  if (isNan(sizeValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\r\n}\r\n#endif // VV_SIZE_UNIT_VALUE\r\n\r\n#ifdef VV_OPACITY\r\nconst int VV_OPACITY_N \x3d 8;\r\nfloat getVVOpacity(float opacityValue) {\r\n  if (isNan(opacityValue)) {\r\n    return 1.0;\r\n  }\r\n\r\n  if (opacityValue \x3c\x3d u_vvOpacityValues[0]) {\r\n    return u_vvOpacities[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_OPACITY_N; ++i) {\r\n    if (u_vvOpacityValues[i] \x3e\x3d opacityValue) {\r\n      float f \x3d (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\r\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvOpacities[VV_OPACITY_N - 1];\r\n}\r\n#endif // VV_OPACITY\r\n\r\n#ifdef VV_ROTATION\r\nmat4 getVVRotation(float rotationValue) {\r\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\r\n  if (isNan(rotationValue)) {\r\n    return mat4(1, 0, 0, 0,\r\n                0, 1, 0, 0,\r\n                0, 0, 1, 0,\r\n                0, 0, 0, 1);\r\n  }\r\n\r\n  float rotation \x3d rotationValue;\r\n  if (u_vvRotationType \x3d\x3d 1.0) {\r\n    rotation \x3d 90.0 - rotation;\r\n  }\r\n\r\n  float angle \x3d C_DEG_TO_RAD * rotation;\r\n\r\n  float sinA \x3d sin(angle);\r\n  float cosA \x3d cos(angle);\r\n\r\n  return mat4(cosA, sinA, 0, 0,\r\n              -sinA,  cosA, 0, 0,\r\n              0,     0, 1, 0,\r\n              0,     0, 0, 1);\r\n}\r\n\r\nmat3 getVVRotationMat3(float rotationValue) {\r\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\r\n  if (isNan(rotationValue)) {\r\n    return mat3(1, 0, 0,\r\n                0, 1, 0,\r\n                0, 0, 1);\r\n  }\r\n\r\n  float rotation \x3d rotationValue;\r\n  if (u_vvRotationType \x3d\x3d 1.0) {\r\n    rotation \x3d 90.0 - rotation;\r\n  }\r\n\r\n  float angle \x3d C_DEG_TO_RAD * -rotation;\r\n\r\n  float sinA \x3d sin(angle);\r\n  float cosA \x3d cos(angle);\r\n\r\n  return mat3(cosA, -sinA, 0,\r\n             sinA, cosA, 0,\r\n              0,    0,    1);\r\n}\r\n#endif // VV_ROTATION\r\n\r\n#ifdef VV_COLOR\r\nconst int VV_COLOR_N \x3d 8;\r\n\r\nvec4 getVVColor(float colorValue, vec4 fallback) {\r\n  if (isNan(colorValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  if (colorValue \x3c\x3d u_vvColorValues[0]) {\r\n    return u_vvColors[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_COLOR_N; ++i) {\r\n    if (u_vvColorValues[i] \x3e\x3d colorValue) {\r\n      float f \x3d (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\r\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvColors[VV_COLOR_N - 1];\r\n}\r\n#endif // VV_COLOR\r\n",
"vvUniforms.glsl":"#if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY) || defined(VV_ROTATION)\r\nattribute highp vec4 a_vv;\r\n#endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY || VV_ROTATION\r\n\r\n#ifdef VV_COLOR\r\nuniform highp float u_vvColorValues[8];\r\nuniform vec4 u_vvColors[8];\r\n#endif // VV_COLOR\r\n\r\n#ifdef VV_SIZE_MIN_MAX_VALUE\r\nuniform highp vec4 u_vvSizeMinMaxValue;\r\n#endif // VV_SIZE_MIN_MAX_VALUE\r\n\r\n#ifdef VV_SIZE_SCALE_STOPS\r\nuniform highp float u_vvSizeScaleStopsValue;\r\n#endif // VV_SIZE_SCALE_STOPS\r\n\r\n#ifdef VV_SIZE_FIELD_STOPS\r\nuniform highp float u_vvSizeFieldStopsValues[6];\r\nuniform float u_vvSizeFieldStopsSizes[6];\r\n#endif // VV_SIZE_FIELD_STOPS\r\n\r\n#ifdef VV_SIZE_UNIT_VALUE\r\nuniform highp float u_vvSizeUnitValueWorldToPixelsRatio;\r\n#endif // VV_SIZE_UNIT_VALUE\r\n\r\n#ifdef VV_OPACITY\r\nuniform highp float u_vvOpacityValues[8];\r\nuniform float u_vvOpacities[8];\r\n#endif // VV_OPACITY\r\n\r\n#ifdef VV_ROTATION\r\nuniform lowp float u_vvRotationType;\r\n#endif // VV_ROTATION\r\n"},
label:{"label.frag":"precision lowp float;\r\n\r\nuniform mediump sampler2D u_referenceTex;\r\nuniform mediump vec2 u_screenSize;\r\nuniform mediump float u_pixelRatio;\r\n\r\nvarying mediump float v_antialiasingWidth;\r\nvarying mediump float v_edgeDistanceOffset;\r\nvarying mediump vec2 v_tex;\r\n\r\n#ifdef ID\r\nvarying mediump float v_fadeStep;\r\n#else\r\nuniform lowp sampler2D u_texture;\r\nvarying mediump vec4 v_color;\r\n#endif // ID\r\n\r\nconst vec3 epsilon \x3d vec3(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\r\n\r\nvoid main()\r\n{\r\n  mediump vec2 refTextPos \x3d gl_FragCoord.xy / (u_pixelRatio * u_screenSize.xy);\r\n  mediump vec4 referenceFragment \x3d texture2D(u_referenceTex, refTextPos);\r\n#ifdef ID\r\n  mediump float alpha \x3d clamp(referenceFragment.a + v_fadeStep, 0.0, 1.0);\r\n  // fill the whole quad\r\n  gl_FragColor \x3d vec4(alpha);\r\n#else\r\n  // read the fade alpha\r\n  lowp float fadeAlpha \x3d referenceFragment.a;\r\n\r\n  // read the distance from the SDF texture\r\n  lowp float dist \x3d texture2D(u_texture, v_tex).a;\r\n\r\n  // the edge distance if a factor of the outline width\r\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\r\n  float glyphEdgeDistance \x3d max(0.75 - v_edgeDistanceOffset, 0.25);\r\n\r\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\r\n  lowp float sdfAlpha \x3d smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist);\r\n\r\n  gl_FragColor \x3d fadeAlpha * sdfAlpha * v_color;\r\n#endif\r\n}\r\n",
"label.vert":"precision mediump float;\r\n\r\nattribute vec2 a_pos;                  // 2 * 2 (2 x signed 16)\r\nattribute vec4 a_color;                // 4 (4 x unsigned byte)\r\nattribute vec2 a_vertexOffset;         // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\r\nattribute vec4 a_texAndSize;          // 4 (4 x unsigned byte) texture coordinatesm and font size. w is for the halo size\r\nattribute vec4 a_refSymbolAndPlacementOffset; // 4 (4 x unsigned byte) the offset of the reference symbol of the feature (x,y) and the placement offset (z, w) all given in pixels\r\nattribute float a_vvSize;\r\n\r\nattribute lowp float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\r\n\r\nattribute mediump vec2 a_visibilityRange; // 2 x unsigned byte;\r\n\r\n// T: TileCoords -\x3e DisplayCoords\r\n// Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\r\nuniform highp mat3 u_dvsMat3;\r\nuniform highp mat3 u_displayMat3;\r\n\r\n\r\nuniform float u_mapRotation;\r\nuniform float u_mapAligned;\r\n\r\nuniform vec2 u_mosaicSize;\r\nuniform float u_pixelRatio;\r\n\r\n// the curent zoom\r\nuniform mediump float u_zoomLevel; // the current zoom level X 10\r\n\r\nvarying mediump float v_antialiasingWidth;\r\nvarying mediump float v_edgeDistanceOffset;\r\n\r\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\r\nvarying mediump vec2 v_tex;\r\n\r\n#ifdef ID\r\nuniform mediump float u_fadeStep;\r\nvarying mediump float v_fadeStep;\r\n#else\r\nvarying mediump vec4 v_color;\r\n#endif // ID\r\n\r\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precission we multiply the values\r\n// by 16 and then at the shader devide by the same number\r\nconst float offsetPrecision \x3d 1.0 / 8.0;\r\nconst float outlineScale \x3d 1.0 / 5.0;\r\nconst float sdfFontSize \x3d 24.0;\r\n\r\n// maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the geometry to 6 on the outside.\r\n// 6 is actually the maximum distance outside the glyph, therefore it is the limitation of the halo which is 1/4 of the geometry size.\r\nconst float maxSdfDistance \x3d 8.0;\r\n\r\nconst float C_DEG_TO_RAD \x3d 3.14159265359 / 180.0;\r\nconst float PLACEMENT_PADDING \x3d 8.0;\r\n\r\n#include \x3cmaterials/icon/vvUniforms.glsl\x3e\r\n#include \x3cmaterials/icon/vvFunctions.glsl\x3e\r\n\r\nvoid main()\r\n{\r\n  float refSymbolSize \x3d a_refSymbolAndPlacementOffset.y;\r\n    \r\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\r\n\r\n  #ifdef VV_SIZE_MIN_MAX_VALUE\r\n    // vv size override the original symbol's size\r\n    float h \x3d getVVMinMaxSize(a_vvSize, refSymbolSize);\r\n  #endif // VV_SIZE_MIN_MAX_VALUE\r\n\r\n  #ifdef VV_SIZE_SCALE_STOPS\r\n    float h \x3d u_vvSizeScaleStopsValue;\r\n  #endif // VV_SIZE_SCALE_STOPS\r\n\r\n  #ifdef VV_SIZE_FIELD_STOPS\r\n    float h \x3d getVVStopsSize(a_vvSize, refSymbolSize);\r\n  #endif // VV_SIZE_FIELD_STOPS\r\n\r\n  #ifdef VV_SIZE_UNIT_VALUE\r\n    float h \x3d getVVUnitValue(a_vvSize, refSymbolSize);\r\n  #endif // VV_SIZE_UNIT_VALUE\r\n    // make sure to preserve the aspect ratio of the symbol\r\n    float halfSize \x3d h / 2.0;\r\n#else\r\n    float halfSize \x3d refSymbolSize / 2.0;\r\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\r\n\r\n  // make sure to clip the vertices in case that given record is marked as invisible\r\n  float z \x3d 2.0 * (1.0 - a_visible);\r\n  float glyphAngle \x3d a_refSymbolAndPlacementOffset.x * 360.0 / 254.0;\r\n  float mapAngle \x3d u_mapRotation * 360.0 / 254.0;\r\n  float diffAngle \x3d min(360.0 - abs(mapAngle - glyphAngle), abs(mapAngle - glyphAngle));\r\n  \r\n  // make sure range is inclusive\r\n  z +\x3d 2.0 * (1.0 - step(a_visibilityRange.x, u_zoomLevel));\r\n  z +\x3d 2.0 * (1.0 - step(u_zoomLevel, a_visibilityRange.y));\r\n  z +\x3d 2.0 * u_mapAligned * step(90.0, diffAngle); \r\n\r\n  // encoded as dir + 1.0\r\n  vec2 placementDir \x3d a_refSymbolAndPlacementOffset.zw - 1.0; \r\n  \r\n  // we use the list significant bit of the position in order to store the indication\r\n  // whether the vertex is of a halow of a glyph\r\n  mediump float halo \x3d mod(a_pos, 2.0).x;\r\n  vec3 pos \x3d vec3(floor(a_pos * 0.5), 1.0);\r\n\r\n  float fontSize \x3d a_texAndSize.z;\r\n  float fontScale \x3d fontSize / sdfFontSize;\r\n\r\n  vec2 vertexOffset \x3d offsetPrecision * a_vertexOffset;\r\n  vec2 placementOffset \x3d placementDir * (halfSize + PLACEMENT_PADDING);\r\n  vec3 glyphOffset \x3d u_displayMat3 * vec3(vertexOffset + placementOffset, 0.0);\r\n  vec3 v_pos \x3d u_dvsMat3 * pos + glyphOffset;\r\n\r\n  gl_Position \x3d vec4(v_pos.xy, z, 1.0);\r\n\r\n  v_tex \x3d a_texAndSize.xy / u_mosaicSize;\r\n  v_antialiasingWidth \x3d 0.106 * sdfFontSize / fontSize / u_pixelRatio;\r\n  // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\r\n  v_edgeDistanceOffset \x3d halo * outlineScale * a_texAndSize.w / fontScale / maxSdfDistance;\r\n\r\n#ifdef ID\r\n  v_fadeStep \x3d u_fadeStep;\r\n#else\r\n  v_color \x3d a_color;\r\n  // Enable this code to visualize hidden glyphs\r\n  // float a \x3d 1.0;\r\n  // if (z !\x3d 0.0)  {\r\n  //   a \x3d 0.645;\r\n  // }\r\n  // v_color \x3d vec4(a_color.rgb, a);\r\n#endif // ID\r\n}\r\n"},
line:{"constants.glsl":"const float thinLineHalfWidth \x3d 1.0; // meaning that a 2 pixels line width is considered a thin line\r\nconst float thinLineWidthFactor \x3d 1.1;\r\n","line.frag":"precision lowp float;\r\n\r\nuniform lowp float u_blur;\r\nuniform mediump float u_antialiasing;\r\n\r\nvarying mediump vec2 v_normal;\r\nvarying mediump float v_lineHalfWidth;\r\nvarying lowp vec4 v_color;\r\nvarying lowp float v_transparency;\r\n\r\n#if defined(PATTERN) || defined(SDF)\r\nuniform sampler2D u_texture;\r\nuniform mediump float u_zoomFactor;\r\n\r\nvarying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\r\nvarying mediump vec2 v_patternSize;\r\nvarying highp float v_accumulatedDistance;\r\n#endif // PATTERN SDF\r\n\r\n#ifdef SDF\r\nconst float sdfPatternHalfWidth \x3d 15.5; // YF: assumed that the width will be set to 31\r\nconst float widthFactor \x3d 2.0;\r\n\r\n// we need the conversion function from RGBA to float\r\n#include \x3cutil/encoding.glsl\x3e\r\n#endif // SDF\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif // ID\r\n\r\n// include the thin line parameters (thinLineHalfWidth and thinLineWidthFactor)\r\n#include \x3cmaterials/line/constants.glsl\x3e\r\n\r\nvoid main()\r\n{\r\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides of the centerline)\r\n  mediump float thinLineFactor \x3d max(thinLineWidthFactor * step(v_lineHalfWidth, thinLineHalfWidth), 1.0);\r\n\r\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\r\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\r\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\r\n  mediump float fragDist \x3d length(v_normal) * v_lineHalfWidth;\r\n\r\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\r\n  // when it is a thin line then use a slightly shallower slope in order to add more feathering\r\n  lowp float alpha \x3d clamp(thinLineFactor * (v_lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\r\n\r\n#if defined(SDF)\r\n  mediump float lineHalfWidth \x3d widthFactor * v_lineHalfWidth;\r\n  mediump float lineWidthRatio \x3d lineHalfWidth / sdfPatternHalfWidth;\r\n  mediump float relativeTexX \x3d mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * lineHalfWidth) / (lineWidthRatio * v_patternSize.x), 1.0);\r\n  mediump float relativeTexY \x3d 0.5 + 0.5 * v_normal.y;\r\n\r\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\r\n  mediump vec2 texCoord \x3d mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\r\n\r\n  // calculate the distance from the edge [-0.5, 0.5]\r\n  mediump float d \x3d rgba2float(texture2D(u_texture, texCoord)) - 0.5;\r\n\r\n  // the distance is a proportional to the line width\r\n  float dist \x3d d * lineHalfWidth;\r\n\r\n  lowp vec4 fillPixelColor \x3d v_transparency * alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\r\n  gl_FragColor \x3d fillPixelColor;\r\n#elif defined(PATTERN)\r\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance along the line\r\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\r\n  mediump float relativeTexX \x3d mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * v_lineHalfWidth) / v_patternSize.x, 1.0);\r\n\r\n  // in order to calculate the texture coordinates prependicular to the line (Y axis), we use the interpolated normal values\r\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\r\n  // texture value shpould be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\r\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolatedf normal is 1.0\r\n  //              | -\x3e line-width / 2\r\n  //      - - - - - - - - - - - - - -\r\n  //              | -\x3e line-width / 2\r\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolatedf normal is -1.0\r\n\r\n  mediump float relativeTexY \x3d 0.5 + (v_normal.y * v_lineHalfWidth / v_patternSize.y);\r\n\r\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\r\n  mediump vec2 texCoord \x3d mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\r\n\r\n  // get the color from the texture\r\n  lowp vec4 color \x3d texture2D(u_texture, texCoord);\r\n\r\n  gl_FragColor \x3d v_transparency * alpha * v_color * color;\r\n#else // solid line (no texture, no pattern)\r\n  // output the fragment color\r\n  gl_FragColor \x3d v_transparency * alpha * v_color;\r\n#endif // SDF\r\n\r\n#ifdef HIGHLIGHT\r\n  gl_FragColor.a \x3d step(1.0 / 255.0, gl_FragColor.a);\r\n#endif // HIGHLIGHT\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"line.vert":"precision mediump float;\r\n\r\nattribute vec2 a_pos;\r\nattribute vec4 a_id;\r\nattribute vec4 a_color;\r\nattribute vec4 a_offsetAndNormal;\r\nattribute vec2 a_accumulatedDistanceAndHalfWidth;\r\nattribute vec4 a_tlbr;\r\nattribute vec4 a_segmentDirection;\r\n\r\nattribute float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\r\n\r\n// T: TileCoords -\x3e DisplayCoords\r\n// Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\r\nuniform highp mat3 u_dvsMat3;\r\n// T: ScreenCoords -\x3e DisplayCoords\r\n// Premultiplies DisplayMat3 * ViewMat3\r\nuniform highp mat3 u_dvMat3;\r\n\r\nuniform mediump float u_zoomFactor;\r\nuniform mediump float u_antialiasing;\r\n\r\n// the interpolated normal to the line. the information is packed into the two LSBs of the vertex coordinate\r\nvarying mediump vec2 v_normal;\r\nvarying mediump float v_lineHalfWidth;\r\nvarying lowp vec4 v_color;\r\nvarying lowp float v_transparency;\r\n\r\nconst float scale \x3d 1.0 / 31.0;\r\n#ifdef SDF\r\nconst float widthFactor \x3d 2.0;\r\n#else\r\nconst float widthFactor \x3d 1.0;\r\n#endif\r\n\r\n\r\n#ifdef PATTERN\r\nuniform mediump vec2 u_mosaicSize;\r\n\r\nvarying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\r\nvarying mediump vec2 v_patternSize;\r\n#endif // PATTERN\r\n\r\n// we need to accumulated distance only if it is a pattern or an SDF line\r\n#if defined(PATTERN) || defined(SDF)\r\nvarying highp float v_accumulatedDistance;\r\n#endif // PATTERN SDF\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif // ID\r\n\r\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\r\n#include \x3cmaterials/line/vvUniforms.glsl\x3e\r\n#include \x3cmaterials/line/vvFunctions.glsl\x3e\r\n\r\n// include the thin line parameters (thinLineHalfWidth and thinLineWidthFactor)\r\n#include \x3cmaterials/line/constants.glsl\x3e\r\n\r\nvoid main()\r\n{\r\n// size VV block\r\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\r\n\r\n#ifdef VV_SIZE_MIN_MAX_VALUE\r\n  mediump float lineHalfWidth \x3d 0.5 * getVVMinMaxSize(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\r\n#endif // VV_SIZE_MIN_MAX_VALUE\r\n\r\n#ifdef VV_SIZE_SCALE_STOPS\r\n  mediump float lineHalfWidth \x3d 0.5 * u_vvSizeScaleStopsValue;\r\n#endif // VV_SIZE_SCALE_STOPS\r\n\r\n#ifdef VV_SIZE_FIELD_STOPS\r\n  mediump float lineHalfWidth \x3d 0.5 * getVVStopsSize(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\r\n#endif // VV_SIZE_FIELD_STOPS\r\n\r\n#ifdef VV_SIZE_UNIT_VALUE\r\n  mediump float lineHalfWidth \x3d 0.5 * getVVUnitValue(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\r\n#endif // VV_SIZE_UNIT_VALUE\r\n\r\n#else // no VV\r\n  mediump float lineHalfWidth \x3d a_accumulatedDistanceAndHalfWidth.y * scale;\r\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\r\n\r\n#ifdef VV_OPACITY\r\nv_transparency \x3d getVVOpacity(a_vv.z);\r\n#else\r\nv_transparency \x3d 1.0;\r\n#endif // VV_OPACITY\r\n\r\n#ifdef VV_COLOR\r\nv_color \x3d getVVColor(a_vv.y, a_color);\r\n#else\r\nv_color \x3d a_color;\r\n#endif // VV_COLOR\r\n\r\n  // make sure to clip the vertices in case that the width of the line is 0 (or negative),\r\n  // or in case that the line is not visible\r\n  float z \x3d 2.0 * (step(lineHalfWidth, 0.0) + (1.0 - a_visible));\r\n\r\n  // add an antialiasing distance. We use 0.2 rather than 0.5 in order to match the SVG renderer\r\n  // also limit the total line width to 1.3 pixels. Below this value lines don't look good compared\r\n  // to the SVG renderer\r\n  lineHalfWidth \x3d max(lineHalfWidth, 0.45) + 0.2 * u_antialiasing;\r\n\r\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides\r\n  // of the centerline) in practice, a thin line is a line who's half width vary from 0.45px to\r\n  // the value of thinLineHalfWidth, as the value is claped in line 221 above\r\n  mediump float thinLineFactor \x3d max(thinLineWidthFactor * step(lineHalfWidth, thinLineHalfWidth), 1.0);\r\n\r\n  v_lineHalfWidth \x3d lineHalfWidth;\r\n\r\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is\r\n  // given in integers (for the sake of using less attribute memory, we need to scale it back to\r\n  // the original range of ~ [0, 1]) in a case of a thin line we move each vertex twice as far\r\n  mediump vec2 dist \x3d thinLineFactor * widthFactor * lineHalfWidth * a_offsetAndNormal.xy * scale;\r\n\r\n  vec3 offset \x3d u_dvMat3 * vec3(dist, 0.0);\r\n  vec3 v_pos \x3d u_dvsMat3 * vec3(a_pos.xy, 1.0) + offset;\r\n\r\n  gl_Position \x3d vec4(v_pos.xy, z, 1.0);\r\n\r\n  v_normal \x3d a_offsetAndNormal.zw * scale;\r\n\r\n#if defined(PATTERN) || defined(SDF)\r\n  v_accumulatedDistance \x3d a_accumulatedDistanceAndHalfWidth.x + dot(scale * a_segmentDirection.xy, dist / u_zoomFactor);\r\n#endif // PATTERN || SDF\r\n\r\n#ifdef PATTERN\r\nv_tlbr \x3d vec4(a_tlbr.x / u_mosaicSize.x, a_tlbr.y / u_mosaicSize.y, a_tlbr.z / u_mosaicSize.x, a_tlbr.w / u_mosaicSize.y);\r\nv_patternSize \x3d vec2(a_tlbr.z - a_tlbr.x, a_tlbr.w - a_tlbr.y);\r\n#endif // PATTERN\r\n\r\n#ifdef ID\r\nv_id \x3d a_id;\r\n#endif // ID\r\n}\r\n",
"vvFunctions.glsl":"const highp float nanValue \x3d 1e-30;\r\n\r\nbool isNan(float val) {\r\n  return (val \x3d\x3d nanValue);\r\n  //return !( val \x3c 0.0 || 0.0 \x3c val || val \x3d\x3d 0.0 );\r\n}\r\n\r\n#ifdef VV_SIZE_MIN_MAX_VALUE\r\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\r\n  if (isNan(sizeValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  float f \x3d (sizeValue - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\r\n  return clamp(mix(u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w, f), u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w);\r\n}\r\n#endif // VV_SIZE_MIN_MAX_VALUE\r\n\r\n#ifdef VV_SIZE_FIELD_STOPS\r\nconst int VV_SIZE_N \x3d 6;\r\nfloat getVVStopsSize(float sizeValue, float fallback) {\r\n  if (isNan(sizeValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  if (sizeValue \x3c\x3d u_vvSizeFieldStopsValues[0]) {\r\n    return u_vvSizeFieldStopsSizes[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_SIZE_N; ++i) {\r\n    if (u_vvSizeFieldStopsValues[i] \x3e\x3d sizeValue) {\r\n      float f \x3d (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\r\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\r\n}\r\n#endif // VV_SIZE_FIELD_STOPS\r\n\r\n#ifdef VV_SIZE_UNIT_VALUE\r\nfloat getVVUnitValue(float sizeValue, float fallback) {\r\n  if (isNan(sizeValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\r\n}\r\n#endif // VV_SIZE_UNIT_VALUE\r\n\r\n#ifdef VV_OPACITY\r\nconst int VV_OPACITY_N \x3d 8;\r\nfloat getVVOpacity(float opacityValue) {\r\n  if (isNan(opacityValue)) {\r\n    return 1.0;\r\n  }\r\n\r\n  if (opacityValue \x3c\x3d u_vvOpacityValues[0]) {\r\n    return u_vvOpacities[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_OPACITY_N; ++i) {\r\n    if (u_vvOpacityValues[i] \x3e\x3d opacityValue) {\r\n      float f \x3d (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\r\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvOpacities[VV_OPACITY_N - 1];\r\n}\r\n#endif // VV_OPACITY\r\n\r\n#ifdef VV_COLOR\r\nconst int VV_COLOR_N \x3d 8;\r\n\r\nvec4 getVVColor(float colorValue, vec4 fallback) {\r\n  if (isNan(colorValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  if (colorValue \x3c\x3d u_vvColorValues[0]) {\r\n    return u_vvColors[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_COLOR_N; ++i) {\r\n    if (u_vvColorValues[i] \x3e\x3d colorValue) {\r\n      float f \x3d (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\r\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvColors[VV_COLOR_N - 1];\r\n}\r\n#endif // VV_COLOR\r\n",
"vvUniforms.glsl":"#if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY)\r\nattribute highp vec3 a_vv;\r\n#endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY\r\n\r\n#ifdef VV_COLOR\r\nuniform highp float u_vvColorValues[8];\r\nuniform vec4 u_vvColors[8];\r\n#endif // VV_COLOR\r\n\r\n#ifdef VV_SIZE_MIN_MAX_VALUE\r\nuniform highp vec4 u_vvSizeMinMaxValue;\r\n#endif // VV_SIZE_MIN_MAX_VALUE\r\n\r\n#ifdef VV_SIZE_SCALE_STOPS\r\nuniform highp float u_vvSizeScaleStopsValue;\r\n#endif\r\n\r\n#ifdef VV_SIZE_FIELD_STOPS\r\nuniform highp float u_vvSizeFieldStopsValues[6];\r\nuniform float u_vvSizeFieldStopsSizes[6];\r\n#endif // VV_SIZE_FIELD_STOPS\r\n\r\n#ifdef VV_SIZE_UNIT_VALUE\r\nuniform float u_vvSizeUnitValueWorldToPixelsRatio;\r\n#endif // VV_SIZE_UNIT_VALUE\r\n\r\n#ifdef VV_OPACITY\r\nuniform highp float u_vvOpacityValues[8];\r\nuniform float u_vvOpacities[8];\r\n#endif // VV_OPACITY\r\n"},
text:{"text.frag":"precision lowp float;\r\n\r\nuniform lowp sampler2D u_texture;\r\n\r\nvarying mediump vec4 v_color;\r\nvarying mediump float v_antialiasingWidth;\r\nvarying mediump float v_edgeDistanceOffset;\r\nvarying mediump vec2 v_tex;\r\nvarying lowp float v_transparency;\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif // ID\r\n\r\nvoid main()\r\n{\r\n  // read the distance from the SDF texture\r\n  lowp float dist \x3d texture2D(u_texture, v_tex).a;\r\n\r\n  // the edge distance if a factor of the outline width\r\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\r\n  float glyphEdgeDistance \x3d max(0.75 - v_edgeDistanceOffset, 0.25);\r\n  \r\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\r\n  lowp float alpha \x3d smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist) * v_transparency;\r\n\r\n  gl_FragColor \x3d alpha * v_color;\r\n\r\n#ifdef ID\r\n  if (gl_FragColor.a \x3c 1.0 / 255.0) {\r\n    discard;\r\n  }\r\n  gl_FragColor \x3d v_id;\r\n#endif // ID\r\n}\r\n",
"text.vert":"precision mediump float;\r\n\r\nconst float C_DEG_TO_RAD \x3d 3.14159265359 / 180.0;\r\n\r\nattribute vec2 a_pos;           // 2 * 2 (2 x signed 16)\r\nattribute vec4 a_id;            // 4 (4 x unsigned byte)\r\nattribute vec4 a_color;         // 4 (4 x unsigned byte)\r\nattribute vec2 a_vertexOffset; // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\r\nattribute vec4 a_texFontSize; // 4 (4 x unsigned byte) texture coordinatesm and font size\r\n\r\nattribute lowp float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\r\n\r\nuniform vec2 u_mosaicSize;\r\nuniform float u_pixelRatio;\r\n\r\n// T: TileCoords -\x3e DisplayCoords\r\n// Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\r\nuniform highp mat3 u_dvsMat3;\r\nuniform highp mat3 u_displayMat3;\r\n\r\nvarying mediump vec4 v_color;\r\nvarying mediump float v_antialiasingWidth;\r\nvarying mediump float v_edgeDistanceOffset;\r\n\r\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\r\nvarying mediump vec2 v_tex;\r\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\r\n// opacity of the layer given by the painter\r\nvarying lowp float v_transparency;\r\n\r\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precission we multiply the values\r\n// by 16 and then at the shader devide by the same number\r\nconst float offsetPrecision \x3d 1.0 / 8.0;\r\nconst float outlineScale \x3d 1.0 / 5.0;\r\nconst float sdfFontSize \x3d 24.0;\r\n\r\n// maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the geometry to 6 on the outside.\r\n// 6 is actually the maximum distance outside the glyph, therefore it is the limitation of the halo which is 1/4 of the geometry size.\r\nconst float maxSdfDistance \x3d 8.0;\r\n\r\n#ifdef ID\r\nvarying highp vec4 v_id;\r\n#endif // ID\r\n\r\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\r\n#include \x3cmaterials/text/vvUniforms.glsl\x3e\r\n#include \x3cmaterials/text/vvFunctions.glsl\x3e\r\n\r\nvoid main()\r\n{\r\n  // make sure to clip the vertices in case that given record is marked as invisible\r\n  float z \x3d 2.0 * (1.0 - a_visible);\r\n\r\n  // we use the list significant bit of the position in order to store the indication whethe the vertex is of a halow of a glyph\r\n  mediump float halo \x3d mod(a_pos, 2.0).x;\r\n\r\n  float fontSize \x3d a_texFontSize.z;\r\n  float scale \x3d 1.0;\r\n\r\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\r\n\r\n  #ifdef VV_SIZE_MIN_MAX_VALUE\r\n    // vv size override the original symbol's size\r\n    vec2 size \x3d vec2(getVVMinMaxSize(a_vv.x, a_texFontSize.z));\r\n  #endif // VV_SIZE_MIN_MAX_VALUE\r\n\r\n  #ifdef VV_SIZE_SCALE_STOPS\r\n    vec2 size \x3d vec2(u_vvSizeScaleStopsValue);\r\n  #endif // VV_SIZE_SCALE_STOPS\r\n\r\n  #ifdef VV_SIZE_FIELD_STOPS\r\n    vec2 size \x3d vec2(getVVStopsSize(a_vv.x, a_texFontSize.z));\r\n  #endif // VV_SIZE_FIELD_STOPS\r\n\r\n  #ifdef VV_SIZE_UNIT_VALUE\r\n    vec2 size \x3d vec2(getVVUnitValue(a_vv.x, a_texFontSize.z));\r\n  #endif // VV_SIZE_UNIT_VALUE\r\n\r\n    scale \x3d size.x / fontSize;\r\n    fontSize \x3d size.x;\r\n\r\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\r\n\r\n  float fontScale \x3d fontSize / sdfFontSize;\r\n  vec3 pos \x3d vec3(floor(a_pos * 0.5), 1.0);\r\n  vec3 offset \x3d vec3(offsetPrecision * a_vertexOffset * scale, 0.0);\r\n\r\n#ifdef VV_ROTATION\r\n  vec3 glyphOffset \x3d u_displayMat3 * getVVRotationMat3(a_vv.w) * offset;\r\n#else\r\n  vec3 glyphOffset \x3d u_displayMat3 * offset;\r\n#endif // VV_ROTATION\r\n\r\n  vec3 v_pos \x3d u_dvsMat3 * pos + glyphOffset;\r\n  gl_Position \x3d vec4(v_pos.xy, z, 1.0);\r\n\r\n\r\n  v_tex \x3d a_texFontSize.xy / u_mosaicSize;\r\n  v_antialiasingWidth \x3d 0.105 * sdfFontSize / fontSize / u_pixelRatio;\r\n  // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\r\n  v_edgeDistanceOffset \x3d halo * outlineScale * a_texFontSize.w / fontScale / maxSdfDistance;\r\n\r\n#ifdef VV_OPACITY\r\n  v_transparency \x3d getVVOpacity(a_vv.z);\r\n#else\r\n  v_transparency \x3d 1.0;\r\n#endif // VV_OPACITY\r\n\r\n#ifdef VV_COLOR\r\n  // we don't want to override the halo color\r\n  v_color \x3d halo * a_color + (1.0 - halo) * getVVColor(a_vv.y, a_color);\r\n#else\r\n  v_color \x3d a_color;\r\n#endif // VV_COLOR\r\n\r\n#ifdef ID\r\n  v_id \x3d a_id;\r\n#endif // ID\r\n}\r\n",
"vvFunctions.glsl":"const highp float nanValue \x3d 1e-30;\r\n\r\nbool isNan(float val) {\r\n  return (val \x3d\x3d nanValue);\r\n  //return !( val \x3c 0.0 || 0.0 \x3c val || val \x3d\x3d 0.0 );\r\n}\r\n\r\n#ifdef VV_SIZE_MIN_MAX_VALUE\r\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\r\n  if (isNan(sizeValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  // we need to multiply by 8 in order to translate to tile coordinates\r\n  float interpolationRatio \x3d (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\r\n  return clamp(u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z), u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w);\r\n}\r\n#endif // VV_SIZE_MIN_MAX_VALUE\r\n\r\n#ifdef VV_SIZE_FIELD_STOPS\r\nconst int VV_SIZE_N \x3d 6;\r\nfloat getVVStopsSize(float sizeValue, float fallback) {\r\n  if (isNan(sizeValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  if (sizeValue \x3c\x3d u_vvSizeFieldStopsValues[0]) {\r\n    return u_vvSizeFieldStopsSizes[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_SIZE_N; ++i) {\r\n    if (u_vvSizeFieldStopsValues[i] \x3e\x3d sizeValue) {\r\n      float f \x3d (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\r\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\r\n}\r\n#endif // VV_SIZE_FIELD_STOPS\r\n\r\n#ifdef VV_SIZE_UNIT_VALUE\r\nfloat getVVUnitValue(float sizeValue, float fallback) {\r\n  if (isNan(sizeValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\r\n}\r\n#endif // VV_SIZE_UNIT_VALUE\r\n\r\n#ifdef VV_OPACITY\r\nconst int VV_OPACITY_N \x3d 8;\r\nfloat getVVOpacity(float opacityValue) {\r\n  if (isNan(opacityValue)) {\r\n    return 1.0;\r\n  }\r\n\r\n  if (opacityValue \x3c\x3d u_vvOpacityValues[0]) {\r\n    return u_vvOpacities[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_OPACITY_N; ++i) {\r\n    if (u_vvOpacityValues[i] \x3e\x3d opacityValue) {\r\n      float f \x3d (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\r\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvOpacities[VV_OPACITY_N - 1];\r\n}\r\n#endif // VV_OPACITY\r\n\r\n#ifdef VV_ROTATION\r\nmat4 getVVRotation(float rotationValue) {\r\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\r\n  if (isNan(rotationValue)) {\r\n    return mat4(1, 0, 0, 0,\r\n                0, 1, 0, 0,\r\n                0, 0, 1, 0,\r\n                0, 0, 0, 1);\r\n  }\r\n\r\n  float rotation \x3d rotationValue;\r\n  if (u_vvRotationType \x3d\x3d 1.0) {\r\n    rotation \x3d 90.0 - rotation;\r\n  }\r\n\r\n  float angle \x3d C_DEG_TO_RAD * rotation;\r\n\r\n  float sinA \x3d sin(angle);\r\n  float cosA \x3d cos(angle);\r\n\r\n  return mat4(cosA, sinA, 0, 0,\r\n              -sinA,  cosA, 0, 0,\r\n              0,     0, 1, 0,\r\n              0,     0, 0, 1);\r\n}\r\n\r\nmat3 getVVRotationMat3(float rotationValue) {\r\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\r\n  if (isNan(rotationValue)) {\r\n    return mat3(1, 0, 0,\r\n                0, 1, 0,\r\n                0, 0, 1);\r\n  }\r\n\r\n  float rotation \x3d rotationValue;\r\n  if (u_vvRotationType \x3d\x3d 1.0) {\r\n    rotation \x3d 90.0 - rotation;\r\n  }\r\n\r\n  float angle \x3d C_DEG_TO_RAD * -rotation;\r\n\r\n  float sinA \x3d sin(angle);\r\n  float cosA \x3d cos(angle);\r\n\r\n  return mat3(cosA, -sinA, 0,\r\n             sinA, cosA, 0,\r\n              0,    0,    1);\r\n}\r\n\r\n#endif // VV_ROTATION\r\n\r\n#ifdef VV_COLOR\r\nconst int VV_COLOR_N \x3d 8;\r\n\r\nvec4 getVVColor(float colorValue, vec4 fallback) {\r\n  if (isNan(colorValue)) {\r\n    return fallback;\r\n  }\r\n\r\n  if (colorValue \x3c\x3d u_vvColorValues[0]) {\r\n    return u_vvColors[0];\r\n  }\r\n\r\n  for (int i \x3d 1; i \x3c VV_COLOR_N; ++i) {\r\n    if (u_vvColorValues[i] \x3e\x3d colorValue) {\r\n      float f \x3d (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\r\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\r\n    }\r\n  }\r\n\r\n  return u_vvColors[VV_COLOR_N - 1];\r\n}\r\n#endif // VV_COLOR\r\n",
"vvUniforms.glsl":"#if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY) || defined(VV_ROTATION)\r\nattribute highp vec4 a_vv;\r\n#endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY || VV_ROTATION\r\n\r\n#ifdef VV_COLOR\r\nuniform highp float u_vvColorValues[8];\r\nuniform vec4 u_vvColors[8];\r\n#endif // VV_COLOR\r\n\r\n#ifdef VV_SIZE_MIN_MAX_VALUE\r\nuniform highp vec4 u_vvSizeMinMaxValue;\r\n#endif // VV_SIZE_MIN_MAX_VALUE\r\n\r\n#ifdef VV_SIZE_SCALE_STOPS\r\nuniform highp float u_vvSizeScaleStopsValue;\r\n#endif // VV_SIZE_SCALE_STOPS\r\n\r\n#ifdef VV_SIZE_FIELD_STOPS\r\nuniform highp float u_vvSizeFieldStopsValues[6];\r\nuniform float u_vvSizeFieldStopsSizes[6];\r\n#endif // VV_SIZE_FIELD_STOPS\r\n\r\n#ifdef VV_SIZE_UNIT_VALUE\r\nuniform float u_vvSizeUnitValueWorldToPixelsRatio;\r\n#endif // VV_SIZE_UNIT_VALUE\r\n\r\n#ifdef VV_OPACITY\r\nuniform highp float u_vvOpacityValues[8];\r\nuniform float u_vvOpacities[8];\r\n#endif // VV_OPACITY\r\n\r\n#ifdef VV_ROTATION\r\nuniform lowp float u_vvRotationType;\r\n#endif // VV_ROTATION\r\n"}},
raster:{"solid.frag":"precision mediump float;\r\n\r\nvoid main(void) {\r\n  gl_FragColor \x3d vec4(1.0, 0.0, 0.0, 1.0);\r\n}\r\n","texture.frag":"precision mediump float;\r\n\r\n// Texture coordinates.\r\nvarying vec2 v_texcoord;\r\n\r\n// Texture sampler.\r\nuniform sampler2D u_texture;\r\n\r\n// Opacity.\r\nuniform float u_opacity;\r\n\r\nvoid main(void) {\r\n  vec4 color \x3d texture2D(u_texture, v_texcoord);\r\n  color.a *\x3d u_opacity;\r\n  gl_FragColor \x3d vec4(color.rgb * color.a, color.a);\r\n}\r\n",
"transform.vert":'precision mediump float;\r\n\r\n// Vertex position. Assumed normalized in the [-1, 1] range.\r\nattribute vec2 a_position;\r\n\r\n// Texture coordinates. Assumed normalized in the [-1, 1] range.\r\nattribute vec2 a_texcoord;\r\n\r\n// Transform matrix.\r\nuniform mat4 u_transform;\r\n\r\n// Scales applied to position and texture coordinates to get the\r\n// "unnormalized" value.\r\nuniform float u_positionScale;\r\nuniform float u_texcoordScale;\r\n\r\n// Output texture coordinates, for interpolation.\r\nvarying vec2 v_texcoord;\r\n\r\nvoid main(void) {\r\n  gl_Position \x3d u_transform * vec4(a_position * u_positionScale, 0.0, 1.0);\r\n  v_texcoord \x3d a_texcoord * u_texcoordScale;\r\n}\r\n'},
stencil:{"stencil.frag":"void main() {\r\n  gl_FragColor \x3d vec4(1.0, 1.0, 1.0, 1.0);\r\n}\r\n","stencil.vert":"attribute vec2 a_pos;\r\n\r\nvoid main() {\r\n  gl_Position \x3d vec4(a_pos, 0.0, 1.0);\r\n}\r\n"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\r\nvarying mediump vec2 v_tex;\r\n\r\nvoid main(void) {\r\n  lowp vec4 color \x3d texture2D(u_texture, v_tex);\r\n  gl_FragColor \x3d 0.75 * color;\r\n}\r\n","tileInfo.vert":"attribute vec2 a_pos;\r\n\r\nuniform highp mat3 u_dvsMat3;\r\n\r\nuniform mediump float u_depth;\r\nuniform mediump float u_coord_ratio;\r\nuniform mediump vec2 u_delta; // in tile coordinates\r\nuniform mediump vec2 u_dimensions; // in tile coordinates\r\n\r\nvarying mediump vec2 v_tex;\r\n\r\nvoid main() {\r\n  mediump vec2 offset \x3d u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\r\n  vec3 v_pos \x3d u_dvsMat3 * vec3(offset, 1.0);\r\n  \r\n  gl_Position \x3d vec4(v_pos.xy, 0.0, 1.0);\r\n\r\n  v_tex \x3d a_pos;\r\n}\r\n"},
util:{"encoding.glsl":"// Factors to convert rgba back to float\r\nconst vec4 rgba2float_factors \x3d vec4(\r\n    255.0 / (256.0),\r\n    255.0 / (256.0 * 256.0),\r\n    255.0 / (256.0 * 256.0 * 256.0),\r\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\r\n  );\r\n\r\nfloat rgba2float(vec4 rgba) {\r\n  // Convert components from 0-\x3e1 back to 0-\x3e255 and then\r\n  // add the components together with their corresponding\r\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\r\n  return dot(rgba, rgba2float_factors);\r\n}\r\n"}}});